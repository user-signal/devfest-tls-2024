<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" dir="ltr">
<head>
<title>JSR 335: Lambda Expressions for the Java™ Programming Language</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="MediaWiki 1.16.5" />

<style type="text/css">
p,li,dd,dt,tr { line-height:120%; }
li { margin-top:4pt; }
a { text-decoration:none; }
dt { font-weight:bold; margin-top:8pt; }
dd { margin-left:0pt; }
.assertion-id { visibility:hidden; font-style:italic; }
</style>
</head>
<body class="mediawiki ltr ns-0 ns-subject page-JSR_335_Lambda_Expressions_for_the_Java™_Programming_Language skin-monobook">
	<a id="top"></a>
	
	<a id="overview"/><h1 id="firstHeading" class="firstHeading">JSR 335: Lambda Expressions for the Java™ Programming Language</h1>
									<p><small>Version 0.9.3.  Copyright © 2014 Oracle America, Inc.  <a href="#Legal_Notice" title="Lambda Specification" class="mw-redirect">Legal Notice</a>.</small>
</p>
<h2> <span class="mw-headline" id="Outline"> Outline </span></h2>
<ul><li> <b><a href="#A" title="Lambda A" class="mw-redirect">Part A: Functional Interfaces</a></b>: Provides a definition of functional interfaces, which lambda expressions and method references can be used to instantiate.
</li><li> <b><a href="#B" title="Lambda B" class="mw-redirect">Part B: Lambda Expressions</a></b>: Defines the syntax of lambda expressions, including rules for the new kinds of parameter lists and statement lists.
</li><li> <b><a href="#C" title="Lambda C" class="mw-redirect">Part C: Method References</a></b>: Defines the syntax of method references.
</li><li> <b><a href="#D" title="Lambda D" class="mw-redirect">Part D: Poly Expressions</a></b>: Describes poly expressions, which are a category of expressions that can adapt their typing to conform to a particular context.
</li><li> <b><a href="#E" title="Lambda E" class="mw-redirect">Part E: Typing and Evaluation</a></b>: Specifies the typing rules and evaluation behavior of lambda expressions and method references.
</li><li> <b><a href="#F" title="Lambda F" class="mw-redirect">Part F: Overload Resolution</a></b>: Adapts overload resolution to handle lambda expressions and other poly expressions.
</li><li> <b><a href="#G" title="Lambda G" class="mw-redirect">Part G: Type Inference</a></b>: Redefines type inference to support lambda expressions and method references, and to allow context to be pushed down to nested poly expressions.
</li><li> <b><a href="#H" title="Lambda H" class="mw-redirect">Part H: Default Methods</a></b>: Describes the syntax and inheritance behavior of default methods, which are members of interfaces.
</li><li> <b><a href="#J" title="Lambda J" class="mw-redirect">Part J: Java Virtual Machine</a></b>: Enhances the JVM specification to support code-carrying methods in interfaces.
</li></ul>
<h2> <span class="mw-headline" id="Introduction"> Introduction </span></h2>
<p>This document presents the language and virtual machine specification changes for JSR 335: Lambda Expressions for the Java™ Programming Language.
</p><p>The new language features are described with reference to existing structure and definitions in the <a href="http://docs.oracle.com/javase/specs/jls/se7/html/index.html" class="external text" rel="nofollow">Java Language Specification, Java SE 7 Edition</a>.  Unless stated otherwise, section numbers interspersed throughout the document refer to the Java Language Specification (possibly as amended by this document).  The bulk of the changes apply to the following JLS chapters:
</p>
<ul><li> 5. Conversions and Promotions
</li><li> 8. Classes
</li><li> 9. Interfaces
</li><li> 14. Blocks and Statements
</li><li> 15. Expressions
</li></ul>
<p>Edits to the JLS are not presented sequentially; rather, they are organized into parts that group together related changes.  Some JLS sections have multiple edits, each in a different part.
</p><p>A small addendum to the <a href="http://docs.oracle.com/javase/7/docs/platform/serialization/spec/serialTOC.html" class="external text" rel="nofollow">Java Object Serialization Specification</a> is made in <a href="#ESerialization" title="Lambda E" class="mw-redirect">Part E</a>.
</p><p>Changes to the <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/index.html" class="external text" rel="nofollow">Java Virtual Machine Specification, Java SE 7 Edition</a>, are also necessary to support default methods.  These changes are indicated in <a href="#J" title="Lambda J" class="mw-redirect">Part J</a>.
</p><p>Except to ensure that necessary functionality is made available by a Java Virtual Machine, this document does not consider implementation.  The mapping of lambda expressions to objects, for example, is only minimally specified as required by type safety—our goal is to allow the implementer freedom as to how and when the object expressed by a lambda expression is created.
</p>
<h3> <span class="mw-headline" id="Notation"> Notation </span></h3>
<p>In a section tagged [New] or [Addendum], everything is new text.
</p><p>In a section tagged [Modified], this is existing text, <u>this is new text</u> <del>this has been removed</del>, and this is more existing text.
</p><p>The following is a formula: <em>f(x)=z</em>.
</p><p>The following is literal program text: <code style="background-color:inherit;font-size:medium">final int x</code>.
</p><p>This sentence introduces a <i>new term</i>.
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>This is a note containing discussion or examples.  Such notes are not typically intended to appear in the revised language specification.</div></blockquote>
<h2> <span class="mw-headline" id="Summary"> Summary </span></h2>
<p>For the reader interested in a broad view of this document, a summary from each part is reproduced below.
</p>
<h4> <span class="mw-headline" id="Part_A"> <a href="#A" title="Lambda A" class="mw-redirect">Part A</a> </span></h4>
<p>A <i>functional interface</i> is an interface that has just one abstract method (aside from the methods of <code style="background-color:inherit;font-size:medium">Object</code>), and thus represents a single function contract.  (In some cases, this "single" method may take the form of multiple abstract methods with override-equivalent signatures inherited from superinterfaces; in this case, the inherited methods logically represent a single method.)
</p><p>In addition to the usual process of creating an interface instance by declaring and instantiating a class, instances of functional interfaces can be created with <i>lambda expressions</i> or <i>method references</i>.
</p><p>The <i>function type</i> of a functional interface <em>I</em> is a method type—type parameters, formal parameter types, return types, and thrown types—that can be used to legally override the abstract method(s) of <em>I</em>.
</p><p>The term <i>functional interface type</i> refers to a non-generic functional interface, a parameterization of a functional interface, a raw functional interface, or an intersection type inducing a functional interface.
</p>
<h4> <span class="mw-headline" id="Part_B"> <a href="#B" title="Lambda B" class="mw-redirect">Part B</a> </span></h4>
<p>A lambda expression is like a method: it provides a list of formal parameters and a body—an expression or block—expressed in terms of those parameters.
</p><p>Examples of lambda expressions:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
s -&gt; s.length()

(int x, int y) -&gt; x+y

() -&gt; 42

(x, y, z) -&gt; {
  if (true) return x;
  else {
    int result = y;
    for (int i = 1; i &lt; z; i++)
      result *= i;
    return result;
  }
}
</pre>
<p>This particular syntax was chosen principally because something similar has been generally well-received in other Java-like languages (C# and Scala), and a clearly "better" alternative did not present itself. It has the advantage over alternate proposals of minimizing bracketing noise around simple lambda expressions.  When some extra bracketing is needed to visually distinguish either the full lambda expression or its body expression, parentheses are naturally supported (just as in other cases in which operator precedence is unclear).
</p><p>The formal parameters of a lambda expression may have either declared types or inferred types. We refer to a lambda expression whose formal parameters have declared types as <i>explicitly-typed</i>, and a lambda expression whose formal parameters have inferred types as <i>implicitly-typed</i>.  The parameter types of an implicitly-typed lambda are derived from the functional interface type targeted by the expression.
</p><p>A lambda body is either a single expression or a block. Like a method body, a lambda body describes code that will be executed whenever an invocation occurs.
</p><p>Unlike code appearing in anonymous class declarations, the meaning of names and the <code style="background-color:inherit;font-size:medium">this</code> and <code style="background-color:inherit;font-size:medium">super</code> keywords appearing in a lambda body are the same as in the surrounding context (except that lambda parameters introduce new names).
</p><p>For both lambda bodies and inner classes, local variables in the enclosing context can only be referenced if they are <code style="background-color:inherit;font-size:medium">final</code> or <i>effectively final</i>. A variable is <i>effectively final</i> if it is never assigned to after its initialization.
</p><p>Block lambda bodies that don't return anything are considered <i>void-compatible</i>; block lambda bodies that return a value from every execution path are considered <i>value-compatible</i>. In a value-compatible lambda body, the <i>result expressions</i> are any expressions that may produce an invocation's value.
</p>
<h4> <span class="mw-headline" id="Part_C"> <a href="#C" title="Lambda C" class="mw-redirect">Part C</a> </span></h4>
<p>A method reference is used to refer to the invocation of a method without actually performing the invocation.  Certain forms of method references also allow class instance creation or array creation to be treated as if it were a method invocation.
</p><p>Examples of method references:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
System::getProperty
&quot;abc&quot;::length
System.out::println
String::length
super::toString
ArrayList::new
int[]::new
</pre>
<p>The target reference (i.e., the "receiver") of an instance method may be provided by the method reference expression or it may be provided later when the method is invoked.  The immediately enclosing instance of a new inner class instance must be provided by a lexically enclosing instance of <code style="background-color:inherit;font-size:medium">this</code>.
</p><p>When more than one member method of a type has the same name, or when a class has more than one constructor, the appropriate method or constructor is selected based on the functional interface type targeted by the expression.
</p>
<h4> <span class="mw-headline" id="Part_D"> <a href="#D" title="Lambda D" class="mw-redirect">Part D</a> </span></h4>
<p>Every expression written in the Java programming language either produces no result (<code style="background-color:inherit;font-size:medium">void</code>) or has a type that can be deduced at compile time.  When an expression appears in most contexts, it must be <i>compatible</i> with a type expected in that context; this type is called the <i>target type</i>.  For convenience, compatibility of an expression with its surrounding context is facilitated by the language in two ways:
</p>
<ul><li> First, for some expressions, termed <i>poly expressions</i>, the deduced type can be influenced by the target type.  The same expression can have different types in different contexts.
</li><li> Second, after the type of the expression has been deduced, an implicit <i>conversion</i> from the type of the expression to the target type can sometimes be performed.
</li></ul>
<p>If neither strategy is able to produce the appropriate type, an error occurs at compile time.
</p><p>Given certain meanings of names, the type of a <i>standalone expression</i> (an expression that is not a poly expression) can be determined entirely from the contents of the expression.  In contrast, the type of a poly expression may be influenced by the expression's target type.
</p><p>The following forms of expressions may be poly expressions:
</p>
<ul><li> Parenthesized expressions
</li><li> Class instance creation expressions
</li><li> Method invocation expressions
</li><li> Conditional operator expressions
</li><li> Lambda expressions
</li><li> Method references
</li></ul>
<p>To determine whether an expression of one of these forms is a poly expression, we may consider the kind of context in which the expression appears and the content of the expression.
</p><p>Generic method invocation expressions, along with class instance creation expressions that use a diamond <code style="background-color:inherit;font-size:medium">&lt;&gt;</code>, may be poly expressions when they appear in assignment or invocation contexts.  This allows type argument inference to depend on context.
</p><p>Lambda expressions and method references are always poly expressions; their typing rules are covered by <a href="#E" title="Lambda E" class="mw-redirect">Part E</a>.
</p><p>Conditional operator expressions may be poly expressions if they appear in assignment or invocation contexts, unless both operands produce primitives (or boxed primitives).  When they are poly expressions, the target type is "pushed down" to each operand.
</p><p>Similarly, parenthesized expressions that wrap poly subexpressions are poly expressions, passing the target type on to the subexpression.
</p><p>Casts can be used to explicitly "tag" a lambda expression or a method reference with a particular target type.  To provide an appropriate degree of flexibility, the target type may be a list of types denoting an intersection type (as long as the intersection is also a functional interface type, typically meaning one element is a functional interface and the others are marker interfaces).  Since the feature is generally useful, we also support casts of arbitrary expressions to intersection types.
</p>
<h4> <span class="mw-headline" id="Part_E"> <a href="#E" title="Lambda E" class="mw-redirect">Part E</a> </span></h4>
<p>Lambda expressions and method references are always poly expressions. It is a compile-time error if one of these occurs in a program in someplace other than an assignment context, an invocation context, or a casting context.
</p><p>The type of a lambda expression or method reference is a functional interface type, derived from its target type.  To be compatible with the target type, the expression must be <i>congruent</i> with the function type of this functional interface type.
</p><p>To test that a lambda expression is congruent, the function type's parameter and return types are compared to the expression.  The lambda parameter types (if given) must exactly match those of the function type, while the body must be assignment-compatible with the function type's return type.  The lambda's expression body (or each result expression of its block body) may be a poly expression.
</p><p>To test that a method reference is congruent, a <i>compile-time declaration</i> is determined following the process used for method <i>invocations</i>. The function type's parameter types are used as argument types in this search, where the first parameter type may sometimes act as the receiver for an instance method. The selected declaration's return type is then checked to be assignment-compatible with the function type's return type.
</p><p>For some method references, there is only one possible compile-time declaration with only one possible invocation type, regardless of the targeted function type. These are referred to as <i>exact method references</i>.
</p><p>In addition to the compatibility requirement, lambda bodies and referenced methods must not throw exceptions that are incompatible with the function type's <code style="background-color:inherit;font-size:medium">throws</code> clause.
</p><p>Evaluation of a lambda expression or method reference produces an instance of a functional interface.  Evaluation does not cause the execution of a lambda body or the invocation of a referenced method; instead, this may occur at a later time when an appropriate method of the interface is invoked.
</p><p>To evaluate the expression, either a new instance of an appropriate class is allocated and initialized, or an existing instance of an appropriate class is referenced.  The evaluation rules are minimally restrictive, thus allowing VMs freedom for optimization.  For example, a separate class need not be defined for each distinct expression, nor must a new object be allocated on every evaluation.
</p>
<h4> <span class="mw-headline" id="Part_F"> <a href="#F" title="Lambda F" class="mw-redirect">Part F</a> </span></h4>
<p>Method and constructor declarations can be overloaded, meaning multiple matching declarations with different parameter types can co-exist in a type.  In order to interpret a method invocation or a class instance creation expression, the compiler performs "overload resolution," inferring the declaration intended by the user at a particular invocation site.  This occurs in three steps: i) identifying <i>potentially applicable methods</i>, that is, methods of the appropriate shape; ii) performing type analysis to identify <i>applicable methods</i> for the given arguments; iii) among the applicable methods, choosing one that is <i>most specific</i>.
</p><p>To accomodate lambda expressions, the definition of potential applicability is expanded to take into account both the arity of the candidate methods and the presence and "shape" of functional interface target types.
</p><p>To check for applicability, the types of an invocation's arguments can no longer, in general, be inputs to the analysis.  This is because:
</p>
<ul><li> The arguments to a method invocation may be poly expressions
</li><li> Poly expressions cannot be typed in the absence of a target type
</li><li> Overload resolution has to be completed before the arguments' target types will be known
</li></ul>
<p>Instead, the input to the applicability check is a list of argument <i>expressions</i>, which <i>can</i> be checked for compatibility with potential target types, even if the ultimate types of the expressions are unknown.
</p><p>The meaning of an implicitly-typed lambda expression or an inexact method reference is sufficiently vague prior to resolving a target type that arguments containing these expressions are not considered <i>pertinent to applicability</i>; they are simply ignored (except for their expected arity) until overload resolution is finished.
</p><p>The Java 7 most-specific analysis was defined as a pairwise comparison of method declarations via subtyping.  Here, we augment the analysis so that, where the corresponding argument is an explicitly-typed lambda expression or an exact method reference, one functional interface type can be preferred over another if it has a "better" function type return type, by a variety of measures: subtyping, boxing, or <code style="background-color:inherit;font-size:medium">void</code> vs. non-<code style="background-color:inherit;font-size:medium">void</code>.
</p>
<h4> <span class="mw-headline" id="Part_G"> <a href="#G" title="Lambda G" class="mw-redirect">Part G</a> </span></h4>
<p>A variety of compile-time analyses require reasoning about types that are not yet known.  Principal among these are generic method applicability testing and generic method invocation type inference.  In general, we refer to the process of reasoning about unknown types as <i>type inference</i>.
</p><p>At a high level, type inference consists of <i>reducing</i> compatibility assertions about expressions or types, called <i>constraint formulas</i>, to a set of <i>bounds</i> on <i>inference variables</i>.  For example, given inference variable <em>α</em>, it might be determined that the constraint formula <em>⟨<code style="background-color:inherit;font-size:medium">String[]</code> &lt;: α<code style="background-color:inherit;font-size:medium">[]</code>⟩</em> reduces to the lower bound <em><code style="background-color:inherit;font-size:medium">String</code> &lt;: α</em>.  As bounds are inferred, they are <i>incorporated</i> into a <i>bound set</i>.  Ultimately, this bound set is <i>resolved</i> to produce an instantiation for each of the inference variables.
</p><p>To infer a generic method's applicability, we assert that the arguments to the method are compatible with their corresponding formal parameter types, and reduce these constraints to a bound set.  We then check that there exists a resolution of the resulting bounds.
</p><p>To infer the type of a generic method invocation, we re-use the inferred bound set from method applicability testing, augmenting it with the results of asserting the compatibility of the method's return type with its target type.  If any invocation arguments are implicitly-typed lambda expressions or inexact method references, we resolve their targeted parameter types as necessary in order to allow their compatibility constraints to be safely reduced.  We also assert that any exceptions thrown by lambda expression bodies are contained by the <code style="background-color:inherit;font-size:medium">throws</code> clauses of their target function types.  After reduction, we resolve the inference variables and use them as type arguments to determine the invocation type of the method.
</p><p>Type inference is also used to determine: i) a target functional interface type for a lambda expression that is assigned to a wildcard-parameterized functional interface; and ii) whether an applicable method is more specific than another applicable, generic method.
</p><p>The following details of reduction are especially noteworthy:
</p><p>When a generic method invocation or diamond constructor invocation appears as the argument to another invocation, the target type of the nested invocation is the targeted formal parameter type.  If the target type contains inference variables, the inference variables and bounds from the nested invocation are "lifted" into the outer inference analysis, and dependencies between the outer and inner inference variables are inferred.  Ultimately, information from an outermost invocation can be "pushed down" to nested invocations via these dependencies.
</p><p>When a lambda expression appears as the argument to a generic invocation, and its target type includes inference variables, we proceed by:
</p>
<ul><li> Checking that the target type is a functional interface type and deriving a target function type.
</li><li> If the lambda parameters' types are implicit, ensuring that the target function type has proper types as its parameter types (allowing the lambda body to be type-checked).
</li><li> If the lambda parameters' types are explicit, asserting that these types match the target type's parameter types.
</li><li> Asserting that each result expression in the lambda body is compatible with the target type's return type.
</li></ul>
<p>Thus, lambda bodies can influence the instantiation of inference variables appearing in the targeted function type's return type, and lambda parameter types, if explicit, can influence the instantiation of inference variables appearing in the targeted function type's parameter types.
</p><p>A method reference appearing as the argument to a generic invocation is handled in much the same way.
</p>
<h4> <span class="mw-headline" id="Part_H"> <a href="#H" title="Lambda H" class="mw-redirect">Part H</a> </span></h4>
<p>A <i>default method</i> is a method that is declared in an interface with the modifier <code style="background-color:inherit;font-size:medium">default</code>.  Its body provides a default implementation for any class that implements the interface without overriding the method.  This allows new functionality to be added to existing (and perhaps already widely-distributed) interfaces.  More generally, it provides a mechanism for multiple inheritance of behavior.
</p><p>An interface may also declare <code style="background-color:inherit;font-size:medium">static</code> methods, which work in much the same way as <code style="background-color:inherit;font-size:medium">static</code> methods in classes, except that they are not inherited.  Often, an interface is the most appropriate place to declare methods that produce or manipulate objects of the interface type.
</p><p>An interface method that is neither <code style="background-color:inherit;font-size:medium">default</code> nor <code style="background-color:inherit;font-size:medium">static</code> is implicitly <code style="background-color:inherit;font-size:medium">abstract</code>.
</p><p>An interface <em>I</em> inherits from its direct superinterfaces all <code style="background-color:inherit;font-size:medium">abstract</code> and default methods that are members of a superinterface, not overridden by a declaration in <em>I</em>, and not already overridden by another method in a superinterface of <em>I</em>.
</p><p>Similarly, a class <em>C</em> inherits from its direct superclass and direct superinterfaces all <code style="background-color:inherit;font-size:medium">abstract</code> and default methods that are members of a supertype, not overridden by a declaration in <em>C</em> <i>nor</i> a concrete method inherited from the superclass of <em>C</em>, and not already overridden by another method in a supertype of <em>C</em>.
</p><p>Notably, this implies that a method inherited from a superclass of <em>C</em> can override a default or <code style="background-color:inherit;font-size:medium">abstract</code> method in a superinterface of <em>C</em>.  We say the superclass method overrides the superinterface method <i>from <em>C</em></i>.  In contrast, an inherited interface method never overrides any methods other than those already overridden at its declaration site.
</p><p>It is a compile-time error if <em>I</em> or <em>C</em> inherits a default method whose signature is override-equivalent with another method inherited by <em>I</em>. This is the case whether the other method is <code style="background-color:inherit;font-size:medium">abstract</code> or not.
</p><p>This error condition can be avoided by declaring a new method that overrides, and thus prevents the inheritance of, all conflicting methods.
</p><p>An overridden default method can be accessed by using a method invocation expression of the form <code style="background-color:inherit;font-size:medium"><em>InterfaceName</em>.super.<em>m</em>()</code>.  The named interface must be a direct superinterface of the type declaration immediately enclosing the expression.
</p><p>A <code style="background-color:inherit;font-size:medium">this</code> expression may appear in a default method body; its type is the type of the enclosing interface.  Similarly, an anonymous or local class may be declared in a default method body, so the enclosing instance of an inner class may have an interface type.
</p><p>To avoid confusion with the <code style="background-color:inherit;font-size:medium">default</code> modifier, the access level given implicitly to unmodified declarations in classes is now referred to as <i>package</i> access rather than <i>default</i> access.
</p>
<h4> <span class="mw-headline" id="Part_J"> <a href="#J" title="Lambda J" class="mw-redirect">Part J</a> </span></h4>
<p>Changes to the Java Virtual Machine are necessary to support the implementation of default methods.  Methods declared in interface class files need not be declared <code style="background-color:inherit;font-size:medium">abstract</code>, and thus can carry a <code style="background-color:inherit;font-size:medium">Code</code> attribute.  Methods declared in interface class files may also be <code style="background-color:inherit;font-size:medium">private</code> or <code style="background-color:inherit;font-size:medium">static</code>.  The <code style="background-color:inherit;font-size:medium">invokespecial</code> and <code style="background-color:inherit;font-size:medium">invokestatic</code> instructions may refer to interface methods.  The rules for method resolution and invocation (via <code style="background-color:inherit;font-size:medium">invokeinterface</code>, <code style="background-color:inherit;font-size:medium">invokespecial</code>, <code style="background-color:inherit;font-size:medium">invokestatic</code>, and <code style="background-color:inherit;font-size:medium">invokevirtual</code>) are enhanced to support execution of code in interfaces.
</p>
<h2> <span class="mw-headline" id="Change_Log"> Change Log </span></h2>
<h4> <span class="mw-headline" id="0.9.3"> 0.9.3 </span></h4>
<p>Method References: Renumbered the Method Reference Expressions section 15.13 (to make room, the JLS 7 15.13 will be merged with a previous section).
</p><p>Typing and Evaluation: Added changes to 6.6.2 to clarify accessibility of references to <code style="background-color:inherit;font-size:medium">protected</code> methods.
</p><p>Type Inference: Bug fix for subtyping constraints involving the null type.  Added rule to invocation typing for lifting constraints on nested invocation arguments that are lambdas/method references into the enclosing inference context.
</p>
<h4> <span class="mw-headline" id="0.9.2"> 0.9.2 </span></h4>
<p>Overload Resolution: Used a simpler, equivalent definition of "reference expression" for the purpose of more-specific method testing.
</p><p>Type Inference: Cleaned up handling of intersection types in 18.2.4 and 18.5.4.  Simplified discussion in 18.2.1.1.
</p>
<h4> <span class="mw-headline" id="0.9.1"> 0.9.1 </span></h4>
<p>Introduction: Added brief discussions about exception transparency and speculative checking during overload resolution.
</p><p>Method References: Removed the <code style="background-color:inherit;font-size:medium">TypeName::m</code> form of unbound method reference, which turned out to be unnecessary and introduced many complications.
</p><p>Poly Expressions: Added a note clarifying that poly conditionals do not have to contain poly expressions.
</p><p>Typing and Evaluation: Removed mentions of the <code style="background-color:inherit;font-size:medium">TypeName::m</code> method reference form.  Allowed raw inner class types to be used in exact constructor references (because diamond inference cannot occur).
</p><p>Overload Resolution: Eliminated unnecessary uses of the qualifier "poly" in discussions of conditional expressions.
</p><p>Type Inference: Modified exception checking constraints so that they only exist for <em>LambdaExpressions</em> and <em>MethodReferences</em> (these constraints were previously generated for all other forms of expressions, and then trivially reduced to <em>true</em>).
</p><p>Default Methods: Tweaked inheritance rule for interfaces so that a static/non-static clash would be properly detected.
</p><p>Java Virtual Machine: Clarified that only 52.0 class files can allow <code style="background-color:inherit;font-size:medium">InterfaceMethodrefs</code> in method references of the kind <code style="background-color:inherit;font-size:medium">invokeStatic</code> and <code style="background-color:inherit;font-size:medium">invokeSpecial</code>.
</p>
<h4> <span class="mw-headline" id="0.9.0"> 0.9.0 </span></h4>
<p>Functional Interfaces: Introduced the term <i>non-wildcard parameterization</i> as an intermediate step when deriving a function type.  Clarified when intersection types are used.  Cleanup of some old discussion.
</p><p>Lambda Expressions: Cleanup of some old discussion.
</p><p>Method References: Prohibited use of constructor type arguments with diamond inference.  Separated <code style="background-color:inherit;font-size:medium">TypeName::m</code> and <code style="background-color:inherit;font-size:medium">ReferenceType::m</code> as two distinct grammatical forms.
</p><p>Poly Expressions: Grammatical changes so that a <em>LambdaExpression</em> is no longer a <em>Primary</em>, in order to address ambiguities.
</p><p>Typing and Evaluation: Introduced the <i>ground target type</i> as an intermediate step towards deriving a function type.  Checked that there are no overriding errors when the lambda or method reference overrides the methods of this type.  Described exactly which methods are overridden, and which (erasure-based) casts occur at runtime.  Accommodated the additional <code style="background-color:inherit;font-size:medium">TypeName::m</code> syntactic form of a method reference.  Described how references to signature-polymorphic methods are handled.  Added new changes to 13.1 to account for method references.
</p><p>Overload Resolution: Asserted that, for a more-specific test of two functional interfaces targeted by an exact method references, the parameter types are the same.  Cleaned up the rules for deriving the actual target types of invocation arguments when unchecked conversion was necessary.
</p><p>Type Inference: Mirrored the changes in Parts E and F.  Clarified how inference variables in a wildcard-parameterized target type of an explicitly-typed lambda expression are handled, and cleaned up the section describing functional interface parameterization inference.  Clarified how subtyping and equality constraints handle non-parameterized inner classes of parameterized types.  Added an incorporation rule to check consistency of parameterized upper bounds.  Cleaned up the treatment of <code style="background-color:inherit;font-size:medium">? extends Object</code>, which should be equivalent to <code style="background-color:inherit;font-size:medium">?</code>.  Added some overlooked resolution dependencies on capture inference variables.  Added rules to invocation type inference to special-case when the return type is an inference variable, and may end up either being wildcard-parameterized or requiring unchecked conversion.  Explicitly moved the definition of <em>lub</em> to 4.10.4.
</p><p>Default Methods: Prohibited invoking a static interface method with an expression qualifier.
</p>
<h4> <span class="mw-headline" id="0.8.0"> 0.8.0 </span></h4>
<p>Poly Expressions: Prohibited arrays in intersection casts.
</p><p>Typing and Evaluation: Made lambdas incompatible with generic targeted function types.  Performed capture before the method reference method search.  Avoided diamond inference for inner classes of raw types.  Defined method references requiring inference as inexact.  Specified unchecked warnings for method reference assignment.  Added lambdas and method references to 15.7.5.
</p><p>Overload Resolution: Clarified the invocation type of the <code style="background-color:inherit;font-size:medium">getClass</code> method.  Clarified that unchecked invocation does not cause target parameter types to be erased.
</p><p>Type Inference: No longer require a bound set as input to reduction.  Allowed narrowing of primitive constants in lambda bodies.  Clarified when unchecked conversion occurs during inference.  Cleaned up reduction of containment/equality constraints involving wildcards.  Fixed minor notational problems.
</p><p>Default Methods: Added the runtime behavior of default method invocation (15.12.4.4).  Defined <i>concrete</i> methods.  Updated the definition of hiding (by static methods), consistent with previous changes to overriding.  Clarified that <code style="background-color:inherit;font-size:medium">TypeName.super</code> cannot be used to refer to a type variable.  Clarified that the type to search, for <code style="background-color:inherit;font-size:medium">InterfaceName.super</code>, is provided by the <code style="background-color:inherit;font-size:medium">implements</code> clause.
</p><p>Java Virtual Machine: Allowed <code style="background-color:inherit;font-size:medium">invokeStatic</code> and <code style="background-color:inherit;font-size:medium">invokeSpecial</code> MethodHandles to use <code style="background-color:inherit;font-size:medium">InterfaceMethodrefs</code>.  Prohibited <code style="background-color:inherit;font-size:medium">static</code> and non-<code style="background-color:inherit;font-size:medium">public</code> methods of class <code style="background-color:inherit;font-size:medium">Object</code> from being the resolution of an <code style="background-color:inherit;font-size:medium">InterfaceMethodref</code>.
</p>
<h4> <span class="mw-headline" id="0.7.0"> 0.7.0 </span></h4>
<p>Typing and Evaluation: Added a paragraph for the Java Object Serialization Specification.  Cleaned up presentation of method reference resolution logic.
</p><p>Overload Resolution: Ensured that, in most-specific testing, all varargs parameter types are considered, even when there are 0 varargs arguments.
</p><p>Type Inference: Provided full rules for "more specific method" inference.  Backed off of approach to unchecked conversion inference, and specified when unchecked conversions are allowed by reduction.  In resolution, adjusted to perform lub only on proper types.
</p><p>Default Methods: Added a discussion about binary compatibility to Chapter 13.
</p><p>Java Virtual Machine: Fixed text in method resolution to properly ignore <code style="background-color:inherit;font-size:medium">static</code> and <code style="background-color:inherit;font-size:medium">private</code> methods in superinterfaces.
</p>
<h4> <span class="mw-headline" id="0.6.3"> 0.6.3 </span></h4>
<p>Functional Interfaces: Renamed the term <i>function descriptor</i> to <i>function type</i> (undoing the previous renaming of <i>functional interface type</i> to <i>function type</i>).  Cleaned up the conditions under which an intersection type can be considered a functional interface type.  Addressed a negative interaction of wildcards with derivation of a function type.
</p><p>Lambda Expressions: Introduced the terms <i>explicitly-typed lambda</i> and <i>implicitly-typed lambda</i>.  Changed treatment of "_" to allow it as a name in non-lambda contexts (noting the possibility of future deprecation).
</p><p>Typing and Evaluation: Introduced the terms <i>exact method reference</i> and <i>inexact method reference</i>.  Removed the compatibility condition for lambda expressions that their body not contain errors.  Introduced a section detailing the process of identifying a compile-time declaration for a method reference (distinct from testing for compatibility).  Adjusted resolution of an unbound/static method reference to be less brittle.
</p><p>Overload Resolution: Asserted that arguments involving implicitly-typed lambdas and inexact method references are not <i>pertinent to applicability</i>; they are only checked for arity during overload resolution.  (This replaces the approach of considering some methods to be only <i>provisionally applicable</i>.)  Minimized the changes to most-specific analysis, so that extra (non-subtyping) work is only done when two functional interfaces are compared and correspond to an explicitly-typed lambda or an exact method reference.  Adjusted potential applicability of an unbound/static method reference to be less brittle.  Made the accessibility of a varargs type a post-resolution check.
</p><p>Type Inference: Added new bounds to represent capture variables and variables that appear in <code style="background-color:inherit;font-size:medium">throws</code> clauses, and described their impact on incorporation and resolution.  Eliminated the notion of "delayed constraints".  Defined special reduction rules for exact method references.  Described reduction of <code style="background-color:inherit;font-size:medium">throws</code> constraints.  Described how invocation type inference handles sequencing of reduction for constraints on arguments that are not pertinent to applicability, as well as <code style="background-color:inherit;font-size:medium">throws</code> constraints (interleaved with resolution of variables, as needed).  Made use of capture bounds during invocation type inference.
</p><p>Default Methods: Prohibited static and default methods from the body of annotation type declarations (<code style="background-color:inherit;font-size:medium">@interface</code>s).
</p><p>Java Virtual Machine: Introduced the term <i>maximally-specific superinterface methods</i> for use in resolution and selection.  Adjusted resolution to be more flexible and to ignore <code style="background-color:inherit;font-size:medium">static</code> and <code style="background-color:inherit;font-size:medium">private</code> methods in superinterfaces.  Prohibited <code style="background-color:inherit;font-size:medium">invokespecial</code> from referring to indirect superinterfaces.  Cleaned up the selection logic of <code style="background-color:inherit;font-size:medium">invokespecial</code>.  Clarified how the changes affect older class files.  Adjusted definition of overriding to be consistent with actual behavior in VMs.
</p>
<h4> <span class="mw-headline" id="0.6.2"> 0.6.2 </span></h4>
<p>Functional Interfaces: Renamed the term <i>functional interface type</i> to just <i>function type</i>, to avoid the assumption that intersection types are excluded from this set.  Defined the descriptor of a raw functional interface type.  Minor fixes in examples to reflect actual compiler behavior.  Adjusted the definition of return-type substitutability to reflect actual compiler behavior.
</p><p>Lambda Expressions: Small change to the scoping rules of local classes to avoid confusion.
</p><p>Method References: Added a number of well-formedness checks for method references (some new, some previously covered by the compatibility definition).  Adjusted terminology so that "method references" refers generally to both "constructor references" and "array creation references".
</p><p>Poly Expressions: Incorporated above terminology changes.  Added section 15.29, which is just a renumbering of 15.28.
</p><p>Typing and Evaluation: Added a lambda compatibility rule that errors do not occur in the lambda body.  Made the check for static-ness of a referenced method a post-compatibility error.  Removed mention of "synthetic" classes and methods, to clarify that the ACC_SYNTHETIC flag is not mandated.  Unified the presentation of "compile-time declarations"/runtime behavior for standard method references, constructor references, and array creation references—the latter two are based on "notional methods" that represent class instance creation or array creation.  Moved the error check for exceptions in lambda bodies to 11.2.3.
</p><p>Overload Resolution: Changed definition of "potentially compatible" for method references to exclude cases in which there are no method declarations of the desired arity.  Defined provisionally-applicable methods to <i>never</i> be more specific rather than <i>always</i> more specific (the outcome should be the same, though).  Unified the presentation of "more specific" for fixed-arity and variable-arity methods.
</p><p>Type Inference: Specified reduction for subtyping and equality constraints.  Specified incorporation.  Specified resolution.  Updated reduction rules for lambdas and method references to track changes in "Typing and Evaluation."  Adjusted terminology so that "bound" refers to all of "proper bounds", "dependencies", and "delayed constraint formulas".  Made tweaks to the notation for constraint formulas and bounds.
</p><p>Default Methods: Removed support for an explicit <code style="background-color:inherit;font-size:medium">package</code> access modifier.  Refined the definition of overriding to more accurately represent the intended behavior when the overriding method is inherited (mostly to account for package-access methods).
</p><p>Java Virtual Machine: Changed the representation of methods declared in interfaces and passed to invokespecial/invokestatic from a Methodref to an InterfaceMethodref.  Rolled back changes that were intended to support Methodref structures that point to methods declared in interfaces.
</p>
<h4> <span class="mw-headline" id="0.6.1"> 0.6.1 </span></h4>
<p>Functional Interfaces: Renamed the <code style="background-color:inherit;font-size:medium">@Functional</code> annotation to <code style="background-color:inherit;font-size:medium">@FunctionalInterface</code>.
</p><p>Typing and Evaluation: Clarified the unpredictable semantics of operators like <code style="background-color:inherit;font-size:medium">==</code> when applied to the value produced by a lambda expression or method reference.
</p><p>Type Inference: Described enhanced analysis for nested generic method invocations, which involves additional forms of dependencies.  Described <i>delayed constraints</i> and defined the conditions under which they are produced by lambda expressions and method references.  As a simplification, eliminated context type from the compatibility constraint formulas.  Defined reduction for poly conditional expressions.  Revised inference process for instantiating wildcard-parameterized functional interface targets.
</p><p>Default Methods: Eliminated support for <code style="background-color:inherit;font-size:medium">synchronized</code> methods in interfaces.
</p><p>Java Virtual Machine: Adjusted the definition of Methodref_info to allow for methods in interfaces.  Adjusted restrictions on modifiers for interface methods.  Revised resolution rules and specification for <code style="background-color:inherit;font-size:medium">invokevirtual</code>.  Introduced adjustments to <code style="background-color:inherit;font-size:medium">invokespecial</code> and <code style="background-color:inherit;font-size:medium">invokestatic</code> to support interface methods.
</p>
<h4> <span class="mw-headline" id="0.6.0"> 0.6.0 </span></h4>
<p>Overall: Split Part F into Part F, Overload Resolution and Part G, Type Inference.  Split the old Part G into Part H, Default Methods and Part J, Java Virtual Machine.
</p><p>Functional Interfaces: Defined intersections as a kind of functional interface type.  Defined the descriptor of wildcard-parameterized types.  Added the <code style="background-color:inherit;font-size:medium">@Functional</code> annotation.
</p><p>Lambda Expressions: Added the <code style="background-color:inherit;font-size:medium">_</code> keyword and the <code style="background-color:inherit;font-size:medium">-&gt;</code> operator to the grammar.
</p><p>Method References: Added qualified <code style="background-color:inherit;font-size:medium">super</code> references.  Added array constructor references.  Added the <code style="background-color:inherit;font-size:medium">::</code> separator to the grammar.
</p><p>Poly Expressions: Allowed casts to intersection types.  Refined the conditions under which a method invocation is considered a poly expression.  Introduced rules for classifying and typing conditional expressions.
</p><p>Typing and Evaluation: Refined the presentation of inference of wildcard-parameterized type instantiations.  Allowed arbitrary statement expressions in lambda bodies targeting a <code style="background-color:inherit;font-size:medium">void</code> return.  Always interpret lambda returns in an assignment context.  Defined runtime behavior when targeting an intersection functional interface type.  Eliminated support for unbound inner class constructor references.  Added support for qualified <code style="background-color:inherit;font-size:medium">super</code> references and array constructor references.  Restricted supported forms of static method references.
</p><p>Overload Resolution: Defined <i>potentially applicable</i> for methods with functional interface parameter types targeted by lambda expressions.  Revised <i>most specific method</i> analysis to consider the invocation argument expressions, compare descriptors of functional interface types, and minimize boxing/unboxing.
</p><p>Type Inference: Added a stub for <i>most specific method inference</i>.
</p><p>Default Methods: Modified syntax, treating <code style="background-color:inherit;font-size:medium">default</code> as a method modifier.  Added support for static interface methods.  Refined the inheritance rules for default and abstract methods.  Enclosing instances of inner classes can be interfaces.  Added support for the <code style="background-color:inherit;font-size:medium">package</code> access modifier.
</p>
<h4> <span class="mw-headline" id="0.5.1"> 0.5.1 </span></h4>
<p>Introduction: Revised and added to the discussion of future enhancements.
</p><p>Lambda Expressions: To allow void method invocations as expression lambda bodies, restricted the void-/value-compatible distinction to block bodies.  Refined the definition of <i>effectively final</i> to conform with the JLS 7 bug fixes to the rules for <code style="background-color:inherit;font-size:medium">final</code> variables.  Added a note in the section on <code style="background-color:inherit;font-size:medium">this</code> that lambda expressions do not introduce a new <code style="background-color:inherit;font-size:medium">this</code> scope.
</p><p>Method and Constructor References: Added <code style="background-color:inherit;font-size:medium">super</code> method references.
</p><p>Typing and Evaluation: Adjusted lambda compatibility rules to support <code style="background-color:inherit;font-size:medium">void</code> method invocations as lambda expression bodies.  Adjusted method reference compatibility rules to support <code style="background-color:inherit;font-size:medium">super</code> method references.  Clarified that class type arguments in a constructor reference can be inferred.  Described the details of method and constructor reference evaluation, in particular how the reference is interpreted as an invocation.
</p><p>Type Inference: Updated lambda compatibility inference rules consistent with the changes to support <code style="background-color:inherit;font-size:medium">void</code> method invocations.  Added examples and discussion.
</p><p>Default Methods: Allowed <code style="background-color:inherit;font-size:medium">this</code> to appear in the body of a default method.  Added discussion on <code style="background-color:inherit;font-size:medium">super</code> method invocations.
</p>
<h4> <span class="mw-headline" id="0.5.0"> 0.5.0 </span></h4>
<p>Overall: Introduced the above "Summary" section, providing a digestible review of the contents of each part.  Formatted to support each part as a separate HTML document.  Added the above "Unfinished Items" section, and removed most other design discussions that speculated on future changes.  These enhancement ideas are recorded and discussed elsewhere, leaving the spec document to act as a more stable baseline.  Minor rephrasing and presentation cleanup throughout.
</p><p>Functional Interfaces: Backed out of a flawed attempt to rewrite 8.4.6 in a way that minimized the use of erasure.
</p><p>Lambda Expressions: Eliminated syntax supporting generic lambda expressions, which was intrusive.  Settled on a strategy in which generic functional interfaces are supported, but cannot be instantiated by lambda expressions; they can still be instantiated by method references.  Removed support for recursive lambdas and associated changes to the definite assignment rules.  Removed orphaned discussion of <code style="background-color:inherit;font-size:medium">Void</code> as a return type (the related feature was already removed in 0.4.2).  Updated rules about lambda parameters to mimic 8.4.1 in JLS 7.  Updated rules about scope and shadowing to match changes in JLS 7, which handles all these rules in 6.3 and 6.4.  Added lambda parameters to 4.12.3.
</p><p>Poly Expressions: Merged the previous "Conversions and Contexts" part with the first half of the previous "Poly Expressions".  This part now includes all discussion about contexts and poly expressions, except for the compatibility and typing rules for lambdas and method references.  Updated 5.4 to match changes in JLS 7.  Eliminated special grammar rules for handling generic lambda expressions.
</p><p>Typing and Evaluation: Merged the second half of the previous "Poly Expressions" part with new material on lambda expression and method reference evaluation.  Improved the compatibility definitions and clarified their interface with type inference in the case in which the target type has wildcards.
</p><p>Type Inference: Added this part.
</p><p>Default Methods: Added this part.
</p>
<h4> <span class="mw-headline" id="0.4.2"> 0.4.2 </span></h4>
<p>Lambda Expressions: Removed rules that support treatment of <code style="background-color:inherit;font-size:medium">void</code> lambda bodies as implementations of methods that return <code style="background-color:inherit;font-size:medium">Void</code>; expanded the accompanying discussion about the possible approaches.
</p><p>Poly Expressions: Removed compatibility rules allowing <code style="background-color:inherit;font-size:medium">void</code> lambda bodies or method references in contexts that require a <code style="background-color:inherit;font-size:medium">Void</code> return type.
</p>
<h4> <span class="mw-headline" id="0.4.1"> 0.4.1 </span></h4>
<p>Functional Interfaces: Allowed generic methods, and added corresponding examples.  Revised "return type substitutable" and related tests to take into account alpha-equivalent type parameters.
</p><p>Lambda Expressions: Updated the syntax to the C#/Scala style.  Added syntax for and a section addressing lambda type parameters.  Further discussion about parsing.  Renumbered to section 15.27.  Prohibited shadowing with lambda parameters.  Allowed local classes to capture effectively-final variables.
</p><p>Method and Constructor References: Updated the syntax (noting that it is still subject to change).  Added discussion about parsing.  Renumbered to section 15.28.
</p><p>Conversions and Contexts: Swapped the order with "Poly Expressions" (making this Part D) and moved the material about expression compatibility rules into the Poly Expressions part (now Part E).  Revised introductory discussion to explicitly define "target type" and clarify that poly expressions and implicit conversions are different, complementary features.  De-emphasized the "compatibility" terminology, eliminating the need for many of the modifications in previous versions.  Reverted section numbers to those in the JLS.
</p><p>Poly Expressions: Eliminated the <i>PolyExpression</i> grammar production; lambda expressions and method references as syntactically primaries, and appropriate context is checked as a semantic rather than syntactic restriction.  Added grammar rules to prevent generic lambdas after casts.  Revised some section numbering, introducing a general discussion of expressions and poly expressions in 15.2.  Eliminated the <i>poly context</i> terminology, relying instead on the existing context concepts from Chapter 5.  Stopped designating constant expressions as poly expressions, instead relying on the old conversion semantics for implicit constant narrowing.  Revised method reference search to allow instance method references to get the receiver's type parameters from the target type.
</p><p>Appendix: Eliminated the need for changes to the grammar throughout the JLS that made up the bulk of the former appendix.
</p>
<h4> <span class="mw-headline" id="0.4.0"> 0.4.0 </span></h4>
<p>Overall: Reformatted as HTML with extensive links.
</p><p>Functional Interfaces: Renamed "SAM types"; redefined this property in terms of declarations rather than type instantiations.  Eliminated a dependency on the particulars of return-type-substitutability.  Ensured that the interface can be generically overridden, but avoided attempts to make guarantees about type instantiations.
</p><p>Lambda Expressions: Updated discussion on syntax.
</p><p>Conversions and Contexts: Added note about making method reference parameter type compatibility more strict in strict invocation contexts.
</p>
<h4> <span class="mw-headline" id="0.3.5"> 0.3.5 </span></h4>
<p>Overall: Promoted the "to discuss" section to a summary of unresolved questions in the document.  Added Part C, Method References (subsequent parts were renamed).  Added an appendix, Part Z, to hold negligible changes that are distracting in the main body of the text.  Added discussion of potential future enhancements at the end of the document.
</p><p>SAM Types: Adjusted the definition of "SAM type" for wildcard-parameterized types to use capture; made the corresponding descriptor undefined.  Adjusted the criteria under which an Object method is disregarded.  Added a check that some abstract method of a SAM type is return-type-substitutable for all others (not guaranteed when type arguments are applied).  Added more examples involving generic SAM types.  Altered the return-type-substitutable definition to more closely match implementations' behavior.
</p><p>Lambda Expressions: Added more discussion about syntax alternatives.  Moved <code style="background-color:inherit;font-size:medium">Void</code> return description in 14.2 to Part F.  Extended discussion about the possibility of return type boxing via overriding and bridge methods.  Noted that the handling of shadowing rules is incomplete.
</p><p>Poly Expressions: Added method references as an additional kind of poly expression.  Added discussion about chained inference.  Moved many grammar production renamings into the appendix.
</p><p>Conversions and Contexts: Moved some of the adjustments to the casting conversion text into the appendix.  Revised compatibility rules for lambda expressions.  Introduced compatibility rules for method references.
</p>
<h4> <span class="mw-headline" id="0.3.4"> 0.3.4 </span></h4>
<p>Introduction: Added a reference list of optional non-lambda changes that should be discussed.  Added Part E, Lambda Expression Evaluation.
</p><p>SAM Types: Added examples and discussion involving generic interfaces.  Added more examples of SAM descriptor thrown types.
</p><p>Lambda Expressions: Made effectively final references from inner classes an optional revision (moving it into discussion).  Also made implicit returns to Void in method bodies optional, and specified handling of returns to Void when the body completes normally.  Moved the <i>effectively final</i> definition into 4.12.4.  Adjusted the restriction on <code style="background-color:inherit;font-size:medium">break</code> and <code style="background-color:inherit;font-size:medium">continue</code> labels to better integrate with existing text.
</p>
<h4> <span class="mw-headline" id="0.3.3"> 0.3.3 </span></h4>
<p>SAM Types: Removed support for SAM class types.  Moved the specification to Chapter 9 (Interfaces).  Clarified the definition of SAM type.  Restricted the set of abstract methods that "don't count" in interfaces to the methods of Object that are defined to be implicit members (9.2).  Improved SAM type examples.  Simplified SAM descriptor definition and eliminated any use of order of methods (see discussion).  Added discussion about accessibility.  Added discussion about additional considerations if abstract classes were allowed.
</p><p>Lambda Expressions: Made "final" and "effectively final" mutually exclusive.  Clarified the discussion about meaning of names and dependencies on type checking.  Prohibited mixing value and void returns in a method.  Added new changes for sections 9.3.1 and 12.5.  Deferred treatment of the interaction between SAM types and lambdas to later sections.
</p>
<h4> <span class="mw-headline" id="0.3.2"> 0.3.2 </span></h4>
<p>SAM Types: Added discussion about method order and about generic methods.  Added SAM descriptor examples.  Small additional comments and cleanup.
</p>
<div id="future"></div>
<h2> <span class="mw-headline" id="Potential_Future_Enhancements"> Potential Future Enhancements </span></h2>
<p>The following have been determined to be outside the scope of JSR 335.  While there are no concrete plans to do so, it is possible that they might be considered as enhancements to the JSR 335 features in a future iteration of the Java Programming Language.
</p>
<h3> <span class="mw-headline" id="Functional_Classes"> Functional Classes </span></h3>
<p>It would be possible to treat certain abstract classes that have a single abstract method as lambda expression targets, like functional interfaces.  Good examples from the Java SE API are <code style="background-color:inherit;font-size:medium">java.util.TimerTask</code>, <code style="background-color:inherit;font-size:medium">javax.swing.InputVerifier</code>, <code style="background-color:inherit;font-size:medium">javax.swing.SwingWorker</code>, and <code style="background-color:inherit;font-size:medium">javax.swing.AbstractAction</code>.
</p><p>This is best handled in the current framework by creating a subclass with a constructor that takes a functional interface—the <code style="background-color:inherit;font-size:medium">Thread(Runnable)</code> constructor essentially does this, although it is not designed very cleanly.  Arguably, the strategy of delegating to a functional-interface-typed field rather than an abstract method ought to be the preferred approach when new APIs are developed, and so there would be much less need to declare functional classes.  (On the other hand, anonymous inner classes that implement abstract methods have more convenient access to the members of the superclass.)
</p><p>The biggest reason that functional classes have been avoided is that defining a synthetic class that extends an arbitrary class is much more difficult and constraining than defining a synthetic class that implements an arbitrary interface: the superclass may have an enclosing instance; the superclass constructor may have parameters; the superclass may have inaccessible abstract methods or constructors.  Most significantly, the superclass constructor can execute arbitrary code and throw arbitrary (possibly even checked) exceptions.  This conflicts with our design goal of allowing implementations freedom regarding when and how often instances of these synthetic classes are created.
</p>
<h3> <span class="mw-headline" id="Standalone_Lambda_Expressions_.26_Structural_Function_Types"> Standalone Lambda Expressions &amp; Structural Function Types </span></h3>
<p>In contexts that do not provide a target type, it would be possible to treat the value of a lambda expression as a special object with a <i>structural function type</i>.  Such values could later be applied directly, converted to functional interface instances, or, if structural function types are denotable, assigned to a variable.
</p><p>Structural function types are difficult for users because they introduce a new category of structural type syntax that everyone has to understand.  If the types are erased, their usefulness is limited by clashes that arise when declaring overloaded methods.  Structural function types are difficult for the specification and implementation because the entire type system has to be adjusted to take into account the existence of a new kind of type.
</p>
<h3> <span class="mw-headline" id="Nonlocal_Control_Flow"> Nonlocal Control Flow </span></h3>
<p>The body of a lambda expressions is evaluated as an <i>expression</i> (as a method invocation, to be precise), meaning that ultimately the evaluation either completes—possibly producing a value—or throws an exception.
</p><p>There are many interesting applications that involve evaluating a lambda-like abstraction as a <i>statement</i>.  This would allow evaluation of the body to have other effects, such as returning (rather than <i>producing</i>) a value or breaking out of a loop.  See <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.1" class="external text" rel="nofollow">14.1</a> for the comprehensive list of possible effects of statement execution.  These effects, when triggered by evaluation of a lambda-like abstraction, can be termed "nonlocal," because the code that describes them appears in a different location than the code that triggers them.  As an example, a <code style="background-color:inherit;font-size:medium">for</code> loop could be re-expressed as a call to a library method that takes as input a lambda-like abstraction; the body of the library method invokes its input as a statement, and the effects of doing so may cause the library method to terminate.
</p><p>This is a more ambitious and less well-understood problem domain than the approach we take of evaluating lambda bodies as method invocations.  It is a less-natural fit for the existing language.
</p>
<h3> <span class="mw-headline" id="Capture_of_Mutable_Variables"> Capture of Mutable Variables </span></h3>
<p>Lambda expressions can only refer to local variables and parameters from the surrounding scope if those variables are <i>effectively final,</i> meaning that their values never change.  This allows the variable to be "captured" for later use as a value rather than a variable.
</p><p>It might seem awkward to be unable to, say, keep a tally of the number of times a lambda body is invoked by incrementing a local variable.  However, if different threads invoke the body at the same time, it is very easy for concurrency bugs to manifest themselves.  To responsibly facilitate that kind of behavior in the language, we would prefer to provide some sort of static analysis that helps to prevent concurrency bugs.
</p><p>On the other hand, a safer and cleaner approach to solving problems like this is to avoid mutation of shared variables.  The current language restrictions encourage those kinds of solutions.
</p>
<h3> <span class="mw-headline" id="Special_Exception_Checking_for_Lambda_Body_Invocations"> Special Exception Checking for Lambda Body Invocations </span></h3>
<p>A checked exception thrown by a lambda body should be identified by the type system wherever the corresponding method is invoked.  This is supported in a limited way by allowing functional interface methods to have <code style="background-color:inherit;font-size:medium">throws</code> clauses—then, naturally, the method invocation knows what exceptions may be thrown.  It is also possible to use a type parameter of a functional interface in the <code style="background-color:inherit;font-size:medium">throws</code> clause, thus allowing a thrown exception type to be inferred (by, say, the invocation of a library method that accepts a lambda argument).
</p><p>However, generics are not well-suited to the problem of representing the exceptions thrown by a block of code.  In the common case (zero checked exceptions), an extra type parameter is a painful clerical burden (for example, <code style="background-color:inherit;font-size:medium">Function&lt;String, Number&gt;</code> becomes <code style="background-color:inherit;font-size:medium">Function&lt;String, Number, RuntimeException&gt;</code>).  And in cases in which multiple exceptions are thrown, there is no way to provide a list of types as a type argument.  Even with workarounds for these problems, it is difficult to write lambda-friendly library code that properly accounts for all the exception types thrown by the provided lambda bodies.
</p><p>A more ambitious solution would be to special-case the treatment of lambdas in the compiler's exception checking logic, detecting the locations in which the checked exceptions of a lambda body may manifest themselves <i>without</i> relying on the <code style="background-color:inherit;font-size:medium">throws</code> clause of the functional interface.  This would eliminate any clerical burden on programmers, while still providing strong exception checking; but it would require the compiler to perform advanced analysis techniques.
</p>
<h3> <span class="mw-headline" id="Speculative_Type_Checking_During_Overload_Resolution"> Speculative Type Checking During Overload Resolution </span></h3>
<p>Implicitly-typed lambda expressions (that is, lambdas with parameters that do not declare their types) and inexact method references (that is, references to overloaded or generic methods) cannot be type-checked before their parameter types are known.  These types are derived from the targeted functional interface type.  In the case of a method invocation argument (e.g., <code style="background-color:inherit;font-size:medium">m(x -&gt; x.foo())</code>), if the method being invoked is overloaded, there may be multiple possible target types, one for each overloaded method declaration.
</p><p>The approach developed here is to ignore the lambda expression or method reference until after overload resolution decides on the method to be invoked—the lambda argument is not <i>pertinent to applicability</i>.  Once overload resolution completes, the lambda body can be type-checked.
</p><p>Another possible approach is to type-check the lambda body or method reference <i>speculatively</i>, once for each possible target type.  This provides a more powerful disambiguation mechanism for overload resolution—the use of lambda parameters in the lambda body may clarify which parameter type was expected.  However, there are a number of challenges: users must consider multiple possible typings when reading a block of code; program behavior depends on subtle type errors; worst-case computational complexity is exponential.  And in some cases, it is still necessary to ignore lambda expressions during overload resolution, because the parameter types are inferred from the method invocation's own target type.
</p>
<h2> <span class="mw-headline" id="Legal_Notice"> Legal Notice </span></h2>
<p>Copyright © 2014 Oracle America, Inc.<br />
4150 Network Circle, Santa Clara, California 95054, U.S.A. All rights reserved.<br />
</p><p>NOTICE
</p><p>The Specification is protected by copyright and the information described therein may be protected by one or more U.S. patents, foreign patents, or pending applications. Except as provided under the following license, no part of the Specification may be reproduced in any form by any means without the prior written authorization of Oracle USA, Inc. ("Oracle") and its licensors, if any. Any use of the Specification and the information described therein will be governed by the terms and conditions of this Agreement.
</p><p>Subject to the terms and conditions of this license, including your compliance with Paragraphs 1 and 2 below, Oracle hereby grants you a fully-paid, non-exclusive, non- transferable, limited license (without the right to sublicense) under Oracle's intellectual property rights to:
</p><p>1. Review the Specification for the purposes of evaluation. This includes: (i) developing implementations of the Specification for your internal, non-commercial use; (ii) discussing the Specification with any third party; and (iii) excerpting brief portions of the Specification in oral or written communications which discuss the Specification provided that such excerpts do not in the aggregate constitute a significant portion of the Technology.
</p><p>2. Distribute implementations of the Specification to third parties for their testing and evaluation use, provided that any such implementation:
</p><p>(i) does not modify, subset, superset or otherwise extend the Licensor Name Space, or include any public or protected packages, classes, Java interfaces, fields or methods within the Licensor Name Space other than those required/authorized by the Specification or Specifications being implemented;
</p><p>(ii) is clearly and prominently marked with the word "UNTESTED" or "EARLY ACCESS" or "INCOMPATIBLE" or "UNSTABLE" or "BETA" in any list of available builds and in proximity to every link initiating its download, where the list or link is under Licensee's control; and
</p><p>(iii) includes the following notice: "This is an implementation of an early-draft specification developed under the Java Community Process (JCP) and is made available for testing and evaluation purposes only. The code is not compatible with any specification of the JCP."
</p><p>The grant set forth above concerning your distribution of implementations of the specification is contingent upon your agreement to terminate development and distribution of your "early draft" implementation as soon as feasible following final completion of the specification. If you fail to do so, the foregoing grant shall be considered null and void.
</p><p>No provision of this Agreement shall be understood to restrict your ability to make and distribute to third parties applications written to the Specification.
</p><p>Other than this limited license, you acquire no right, title or interest in or to the Specification or any other Oracle intellectual property, and the Specification may only be used in accordance with the license terms set forth herein. This license will expire on the earlier of: (a) two (2) years from the date of Release listed above; (b) the date on which the final version of the Specification is publicly released; or (c) the date on which the Java Specification Request (JSR) to which the Specification corresponds is withdrawn. In addition, this license will terminate immediately without notice from Oracle if you fail to comply with any provision of this license. Upon termination, you must cease use of or destroy the Specification.
</p><p>"Licensor Name Space" means the public class or interface declarations whose names begin with "java", "javax", "com.oracle" or their equivalents in any subsequent naming convention adopted by Oracle through the Java Community Process, or any recognized successors or replacements thereof.
</p><p>TRADEMARKS
</p><p>No right, title, or interest in or to any trademarks, service marks, or trade names of Oracle or Oracle's licensors is granted hereunder. Oracle, the Oracle logo, Java are trademarks or registered trademarks of Oracle USA, Inc. in the U.S. and other countries.
</p><p>DISCLAIMER OF WARRANTIES
</p><p>THE SPECIFICATION IS PROVIDED "AS IS" AND IS EXPERIMENTAL AND MAY CONTAIN DEFECTS OR DEFICIENCIES WHICH CANNOT OR WILL NOT BE CORRECTED BY ORACLE. ORACLE MAKES NO REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT THAT THE CONTENTS OF THE SPECIFICATION ARE SUITABLE FOR ANY PURPOSE OR THAT ANY PRACTICE OR IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADE SECRETS OR OTHER RIGHTS. This document does not represent any commitment to release or implement any portion of the Specification in any product.
</p><p>THE SPECIFICATION COULD INCLUDE TECHNICAL INACCURACIES OR TYPOGRAPHICAL ERRORS. CHANGES ARE PERIODICALLY ADDED TO THE INFORMATION THEREIN; THESE CHANGES WILL BE INCORPORATED INTO NEW VERSIONS OF THE SPECIFICATION, IF ANY. ORACLE MAY MAKE IMPROVEMENTS AND/OR CHANGES TO THE PRODUCT(S) AND/OR THE PROGRAM(S) DESCRIBED IN THE SPECIFICATION AT ANY TIME.  Any use of such changes in the Specification will be governed by the then-current license for the applicable version of the Specification.
</p><p>LIMITATION OF LIABILITY
</p><p>TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL ORACLE OR ITS LICENSORS BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION, LOST REVENUE, PROFITS OR DATA, OR FOR SPECIAL, INDIRECT, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF OR RELATED TO ANY FURNISHING, PRACTICING, MODIFYING OR ANY USE OF THE SPECIFICATION, EVEN IF ORACLE AND/OR ITS LICENSORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
</p><p>You will hold Oracle (and its licensors) harmless from any claims based on your use of the Specification for any purposes other than the limited right of evaluation as described above, and from any claims that later versions or releases of any Specification furnished to you are incompatible with the Specification provided to you under this license.
</p><p>RESTRICTED RIGHTS LEGEND
</p><p>If this Software is being acquired by or on behalf of the U.S. Government or by a U.S. Government prime contractor or subcontractor (at any tier), then the Government's rights in the Software and accompanying documentation shall be only as set forth in this license; this is in accordance with 48 C.F.R. 227.7201 through 227.7202-4 (for Department of Defense (DoD) acquisitions) and with 48 C.F.R. 2.101 and 12.212 (for non-DoD acquisitions).
</p><p>REPORT
</p><p>You may wish to report any ambiguities, inconsistencies or inaccuracies you may find in connection with your evaluation of the Specification ("Feedback"). To the extent that you provide Oracle with any Feedback, you hereby: (i) agree that such Feedback is provided on a non-proprietary and non-confidential basis, and (ii) grant Oracle a perpetual, non-exclusive, worldwide, fully paid-up, irrevocable license, with the right to sublicense through multiple levels of sublicensees, to incorporate, disclose, and use without limitation the Feedback for any purpose related to the Specification and future versions, implementations, and test suites thereof.
</p><p>GENERAL TERMS
</p><p>Any action related to this Agreement will be governed by California law and controlling U.S. federal law. The U.N. Convention for the International Sale of Goods and the choice of law rules of any jurisdiction will not apply.
</p><p>The Specification is subject to U.S. export control laws and may be subject to export or import regulations in other countries. Licensee agrees to comply strictly with all such laws and regulations and acknowledges that it has the responsibility to obtain such licenses to export, re-export or import as may be required after delivery to Licensee.
</p><p>This Agreement is the parties' entire agreement relating to its subject matter. It supersedes all prior or contemporaneous oral or written communications, proposals, conditions, representations and warranties and prevails over any conflicting or additional terms of any quote, order, acknowledgment, or other communication between the parties relating to its subject matter during the term of this Agreement. No modification to this Agreement will be binding, unless in writing and signed by an authorized representative of each party.
</p>



<a id="top"></a>
	
	<a id="A"/><h1 id="firstHeading" class="firstHeading">Lambda Specification, Part A: Functional Interfaces</h1>
									<p><small>
Navigation: <a href="#overview" title="Lambda Specification" class="mw-redirect">Overview</a>&nbsp;- <a href="#A" title="Lambda A" class="mw-redirect">Part A</a>&nbsp;- <a href="#B" title="Lambda B" class="mw-redirect">Part B</a>&nbsp;- <a href="#C" title="Lambda C" class="mw-redirect">Part C</a>&nbsp;- <a href="#D" title="Lambda D" class="mw-redirect">Part D</a>&nbsp;- <a href="#E" title="Lambda E" class="mw-redirect">Part E</a>&nbsp;- <a href="#F" title="Lambda F" class="mw-redirect">Part F</a>&nbsp;- <a href="#G" title="Lambda G" class="mw-redirect">Part G</a>&nbsp;- <a href="#H" title="Lambda H" class="mw-redirect">Part H</a>&nbsp;- <a href="#J" title="Lambda J" class="mw-redirect">Part J</a>
<br />
Sections: <a href="#A9.8">9.8</a>&nbsp;- <a href="#A4.9">4.9</a>&nbsp;- <a href="#A8.2">8.2</a>&nbsp;- <a href="#A8.4.2">8.4.2</a>&nbsp;- <a href="#A8.4.4">8.4.4</a>&nbsp;- <a href="#A8.4.5">8.4.5</a>&nbsp;- <a href="#A8.4.6">8.4.6</a>&nbsp;- <a href="#A9.6.3.8">9.6.3.8</a>
<br />
Version 0.9.3.  Copyright © 2014 Oracle America, Inc.  <a href="#Legal_Notice" title="Lambda Specification" class="mw-redirect">Legal Notice</a>.
</small>
</p>
<h3> <span class="mw-headline" id="Summary"> Summary </span></h3>
<p>A <i>functional interface</i> is an interface that has just one abstract method (aside from the methods of <code style="background-color:inherit;font-size:medium">Object</code>), and thus represents a single function contract.  (In some cases, this "single" method may take the form of multiple abstract methods with override-equivalent signatures inherited from superinterfaces; in this case, the inherited methods logically represent a single method.)
</p><p>In addition to the usual process of creating an interface instance by declaring and instantiating a class, instances of functional interfaces can be created with <i>lambda expressions</i> or <i>method references</i>.
</p><p>The <i>function type</i> of a functional interface <em>I</em> is a method type—type parameters, formal parameter types, return types, and thrown types—that can be used to legally override the abstract method(s) of <em>I</em>.
</p><p>The term <i>functional interface type</i> refers to a non-generic functional interface, a parameterization of a functional interface, a raw functional interface, or an intersection type inducing a functional interface.
</p>
<div id="A9.8"></div>
<h3> <span class="mw-headline" id="9.8_Functional_Interfaces_.5BNew.5D"> 9.8 Functional Interfaces [New] </span></h3>
<p>A <i>functional interface</i> is an interface that has just one abstract method (aside from the methods of <code style="background-color:inherit;font-size:medium">Object</code>), and thus represents a single function contract.  (In some cases, this "single" method may take the form of multiple abstract methods with override-equivalent signatures (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.2" class="external text" rel="nofollow">8.4.2</a>) inherited from superinterfaces; in this case, the inherited methods logically represent a single method.)
</p><p><span class="norm-static">More precisely, for interface <em>I</em>, let <em>M</em> be the set of abstract methods that are members of <em>I</em> but that do not have the same signature as any public instance method of the class <code style="background-color:inherit;font-size:medium">Object</code>.  Then <em>I</em> is a functional interface if there exists a method <em>m</em> in <em>M</em> for which the following conditions hold:<span class="assertion-id"> [jsr335-9.8-10]</span></span>
</p>
<ul><li> <span class="norm-static">The signature of <em>m</em> is a subsignature (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.2" class="external text" rel="nofollow">8.4.2</a>) of every method's signature in <em>M</em>.<span class="assertion-id"> [jsr335-9.8-10-A]</span></span>
</li><li> <span class="norm-static"><em>m</em> is return-type-substitutable (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.5" class="external text" rel="nofollow">8.4.5</a>) for every method in <em>M</em>.<span class="assertion-id"> [jsr335-9.8-10-B]</span></span>
</li></ul>
<p>In addition to the usual process of creating an interface instance by declaring (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1" class="external text" rel="nofollow">8.1</a>) and instantiating (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9" class="external text" rel="nofollow">15.9</a>) a class, instances of functional interfaces can be created with lambda expressions (<a href="#B15.27" title="Lambda B" class="mw-redirect">15.27</a>) or method reference expressions (<a href="#C15.13" title="Lambda C" class="mw-redirect">15.13</a>).
</p><p>The <i>function type</i> of a functional interface <em>I</em> is a method type (<a href="#A8.2" title="Lambda A" class="mw-redirect">8.2</a>) that can be used to legally override (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.8" class="external text" rel="nofollow">8.4.8</a>) the abstract method(s) of <em>I</em>.
</p><p><span class="norm-static">Let <em>M</em> be the set of abstract methods defined above for <em>I</em>.  The function type of <em>I</em> consists of the following:<span class="assertion-id"> [jsr335-9.8-20]</span></span>
</p>
<ul><li> <span class="norm-static">Type parameters, formal parameters, and return type: Let <em>m</em> be a method in <em>M</em> with i) a signature that is a subsignature of every method's signature in <em>M</em> and ii) a return type that is a subtype of every method's return type in <em>M</em> (after adapting for any type parameters (<a href="#A8.4.4" title="Lambda A" class="mw-redirect">8.4.4</a>)); if no such method exists, then let <em>m</em> be a method in <em>M</em> that i) has a signature that is a subsignature of every method's signature in <em>M</em> and ii) is return-type-substitutable for every method in <em>M</em>.  Then the function type's type parameters, formal parameter types, and return type are as given by <em>m</em>.<span class="assertion-id"> [jsr335-9.8-20-A]</span></span>
</li></ul>
<ul><li> <span class="norm-static">Throws clause: The function type's <code style="background-color:inherit;font-size:medium">throws</code> clause is derived from the <code style="background-color:inherit;font-size:medium">throws</code> clauses of the methods in <em>M</em>.  If the function type is generic, these clauses are first adapted to the type parameters of the function type (<a href="#A8.4.4" title="Lambda A" class="mw-redirect">8.4.4</a>); if the function type is not generic but at least one method in <em>M</em> <i>is</i>, these clauses are first erased.  Then the function type's <code style="background-color:inherit;font-size:medium">throws</code> clause includes every type, <em>E</em>, satisfying the following constraints:<span class="assertion-id"> [jsr335-9.8-20-B]</span></span>
<ul><li> <span class="norm-static"><em>E</em> is mentioned in one of the <code style="background-color:inherit;font-size:medium">throws</code> clauses.<span class="assertion-id"> [jsr335-9.8-20-B1]</span></span>
</li><li> <span class="norm-static">For each <code style="background-color:inherit;font-size:medium">throws</code> clause, <em>E</em> is a subtype of some type named in that clause.<span class="assertion-id"> [jsr335-9.8-20-B2]</span></span>
</li></ul>
</li></ul>
<p><span class="norm-static">
The term <i>functional interface type</i> refers to one of the following:<span class="assertion-id"> [jsr335-9.8-30]</span></span>
</p>
<ul><li> <span class="norm-static"> A non-generic functional interface<span class="assertion-id"> [jsr335-9.8-30-A]</span></span>
</li><li> <span class="norm-static"> A parameterization (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.5" class="external text" rel="nofollow">4.5</a>) of a functional interface<span class="assertion-id"> [jsr335-9.8-30-B]</span></span>
</li><li> <span class="norm-static"> A raw functional interface (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.8" class="external text" rel="nofollow">4.8</a>)<span class="assertion-id"> [jsr335-9.8-30-D]</span></span>
</li><li> <span class="norm-static"> An intersection type that induces a notional functional interface (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.9" class="external text" rel="nofollow">4.9</a>)<span class="assertion-id"> [jsr335-9.8-30-C]</span></span>
</li></ul>
<p><span class="norm-static">
The function type of a parameterized functional interface, <em>F<code style="background-color:inherit;font-size:medium">&lt;</code>T<sub>1</sub>...T<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em>, where <em>T<sub>1</sub>...T<sub>n</sub></em> are types and the corresponding type parameters of <em>F</em> are <em>P<sub>1</sub>, ..., P<sub>n</sub></em>, is derived by applying the substitution <em>[P<sub>1</sub>:=T<sub>1</sub>, ..., P<sub>n</sub>:=T<sub>n</sub>]</em> to the function type of interface <em>F</em>.<span class="assertion-id"> [jsr335-9.8-38]</span></span>
</p><p><span class="norm-static">
The function type of a parameterized functional interface, <em>F<code style="background-color:inherit;font-size:medium">&lt;</code>A<sub>1</sub>...A<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em>, where one or more of <em>A<sub>1</sub>...A<sub>n</sub></em> is a wildcard, is the function type of the <i>non-wildcard parameterization</i> of <em>F</em>, <em>F<code style="background-color:inherit;font-size:medium">&lt;</code>T<sub>1</sub>...T<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em> determined as follows.  Let <em>P<sub>1</sub>, ..., P<sub>n</sub></em> be the type parameters of <em>F</em> and <em>B<sub>1</sub>, ..., B<sub>n</sub></em> be the corresponding bounds.  For all <em>i</em>, <em>1 ≤ i ≤ n</em>, <em>T<sub>i</sub></em> is derived according to the form of <em>A<sub>i</sub></em>:<span class="assertion-id"> [jsr335-9.8-40]</span></span>
</p>
<ul><li> <span class="norm-static"> If <em>A<sub>i</sub></em> is a type, then <em>T<sub>i</sub> = A<sub>i</sub></em>.<span class="assertion-id"> [jsr335-9.8-40-A]</span></span>
</li><li> <span class="norm-static"> If <em>A<sub>i</sub></em> is a wildcard, and the corresponding type parameter bound, <em>B<sub>i</sub></em>, mentions one of <em>P<sub>1</sub>...P<sub>n</sub></em>, then <em>T<sub>i</sub></em> is undefined and there is no function type.<span class="assertion-id"> [jsr335-9.8-39]</span></span>
</li><li> <span class="norm-static"> Otherwise:<span class="assertion-id"> [jsr335-9.8-40-E]</span></span>
<ul><li> <span class="norm-static"> If <em>A<sub>i</sub></em> is an unbound wildcard <em><code style="background-color:inherit;font-size:medium">?</code></em>, then <em>T<sub>i</sub> = B<sub>i</sub></em>.<span class="assertion-id"> [jsr335-9.8-40-D]</span></span>
</li><li> <span class="norm-static"> If <em>A<sub>i</sub></em> is a upper-bounded wildcard <em><code style="background-color:inherit;font-size:medium">? extends</code> U<sub>i</sub></em>, then <em>T<sub>i</sub> = glb(U<sub>i</sub>, B<sub>i</sub>)</em>.<span class="assertion-id"> [jsr335-9.8-40-B]</span></span>
</li><li> <span class="norm-static"> If <em>A<sub>i</sub></em> is a lower-bounded wildcard <em><code style="background-color:inherit;font-size:medium">? super</code> L<sub>i</sub></em>, then <em>T<sub>i</sub> = L<sub>i</sub></em>.<span class="assertion-id"> [jsr335-9.8-40-C]</span></span>
</li></ul>
</li></ul>
<p><span class="norm-static">
The function type of a raw functional interface is the erasure of the functional interface's function type.<span class="assertion-id"> [jsr335-9.8-45]</span></span>
</p><p><span class="norm-static">
The function type of an intersection type that induces a notional functional interface (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.9" class="external text" rel="nofollow">4.9</a>) is the function type of the notional interface.<span class="assertion-id"> [jsr335-9.8-50]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>"A closure is an object that supports exactly one method: <em>apply</em>." - Guy Steele
</p>
</div></blockquote>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Functional interface examples:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
interface Runnable { void run(); }
  // Functional

interface Foo { boolean equals(Object obj); }
 // Not functional; equals is already an implicit member

interface Bar extends Foo { int compare(String o1, String o2); }
 // Functional; Bar has one abstract non-Object method

interface Comparator&lt;T&gt; {
 boolean equals(Object obj);
 int compare(T o1, T o2);
}
 // Functional; Comparator has one abstract non-Object method

interface Foo {
  int m();
  Object clone();
}
  // Not functional; method Object.clone is not public

interface X { int m(Iterable&lt;String&gt; arg); }
interface Y { int m(Iterable&lt;String&gt; arg); }
interface Z extends X, Y {}
  // Functional: two methods, but they have the same signature

interface X { Iterable m(Iterable&lt;String&gt; arg); }
interface Y { Iterable&lt;String&gt; m(Iterable arg); }
interface Z extends X, Y {}
  // Functional: Y.m is a subsignature &amp; return-type-substitutable

interface X { int m(Iterable&lt;String&gt; arg); }
interface Y { int m(Iterable&lt;Integer&gt; arg); }
interface Z extends X, Y {}
  // Compiler error: No method has a subsignature of all abstract methods

interface X { int m(Iterable&lt;String&gt; arg, Class c); }
interface Y { int m(Iterable arg, Class&lt;?&gt; c); }
interface Z extends X, Y {}
  // Compiler error: No method has a subsignature of all abstract methods

interface X { long m(); }
interface Y { int m(); }
interface Z extends X, Y {}
  // Compiler error: no method is return type substitutable

interface Foo&lt;T&gt; { void m(T arg); }
interface Bar&lt;T&gt; { void m(T arg); }
interface FooBar&lt;X, Y&gt; extends Foo&lt;X&gt;, Bar&lt;Y&gt; {}
  // Compiler error: different signatures, same erasure

interface Foo&lt;T, N extends Number&gt; {
  void m(T arg);
  void m(N arg);
}
interface Bar extends Foo&lt;String, Integer&gt; {}
interface Baz extends Foo&lt;Integer, Integer&gt; {}
  // Foo is _not_ functional: different signatures for m
  // Bar is _not_ functional: different signatures for m
  // Baz is functional: same signature for m

interface Executor { &lt;T&gt; T execute(Action&lt;T&gt; a); }
  // Functional

interface X { &lt;T&gt; T execute(Action&lt;T&gt; a); }
interface Y { &lt;S&gt; S execute(Action&lt;S&gt; a); }
interface Exec extends X, Y {}
  // Functional: signatures are &quot;the same&quot;

interface X { &lt;T&gt; T execute(Action&lt;T&gt; a); }
interface Y { &lt;S,T&gt; S execute(Action&lt;S&gt; a); }
interface Exec extends X, Y {}
  // Compiler error: different signatures, same erasure
</pre></div></blockquote>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Function type examples:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
interface X { void m() throws IOException; }
interface Y { void m() throws EOFException; }
interface Z { void m() throws ClassNotFoundException; }
interface XY extends X, Y {}
interface XYZ extends X, Y, Z {}

// XY has function type ()-&gt;void throws EOFException
// XYZ has function type ()-&gt;void (throws nothing)

interface A {
  List&lt;String&gt; foo(List&lt;String&gt; arg) throws IOException, SQLTransientException;
}
interface B {
  List foo(List&lt;String&gt; arg) throws EOFException, SQLException, TimeoutException;
}
interface C {
  List foo(List arg) throws Exception;
}
interface D extends A, B {}
interface E extends A, B, C {}

// D has function type (List&lt;String&gt;)-&gt;List&lt;String&gt; throws EOFException, SQLTransientException
// E has function type (List)-&gt;List throws EOFException, SQLTransientException

interface G1 {
  &lt;E extends Exception&gt; Object m() throws E;
}
interface G2 {
  &lt;F extends Exception&gt; String m() throws Exception;
}
interface G extends G1, G2 {}

// G has function type &lt;F extends Exception&gt; ()-&gt;String throws F
</pre></div></blockquote>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div>The definition of <i>functional interface</i> excludes methods in an interface that are also public methods in <code style="background-color:inherit;font-size:medium">Object</code>.  This is to allow functional treatment of an interface like <code style="background-color:inherit;font-size:medium">Comparator</code> that declares multiple abstract methods of which only one is really "new"; the other method is an explicit declaration of an abstract method that would otherwise be implicitly declared, and will be automatically implemented by any subclass.
<p>Note that if non-public methods of <code style="background-color:inherit;font-size:medium">Object</code>—like <code style="background-color:inherit;font-size:medium">clone()</code>—are declared in an interface, they are not automatically implemented by every subclass of the interface, because the inherited implementation is protected, while the interface method must be public.  The only way to implement such an interface would be to override the non-public Object method, making it public.
</p>
</div></li>
<li style="margin-bottom:12px;"><div>Functional interfaces can be generic: <code style="background-color:inherit;font-size:medium">Predicate&lt;T&gt;</code>, for example.
<p>A previous, more general approach made the "functional" property one of types (specific parameterizations) rather than interfaces.  Each distinct parameterization was examined to determine if it had a single abstract method; parameterizations were allowed to "merge" otherwise-distinct methods.  The extra complexity introduced by this strategy, however, was not deemed worthwhile.  If an interface could only qualify as functional under a certain parameterization, a corresponding functional interface can be declared by extending the interface, using that particular parameterization as the supertype.
</p><p>Under the current definition, a functional interface may be parameterized in a way that produces distinct abstract methods—that is, multiple methods that cannot be legally overridden with a single declaration.  For example:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
interface I { Object m(Class c); }
interface J&lt;S&gt; { S m(Class&lt;?&gt; c); }
interface K&lt;T&gt; { T m(Class&lt;?&gt; c); }
interface Functional&lt;S,T&gt; extends I, J&lt;S&gt;, K&lt;T&gt; {}
</pre>
<p>Interface <code style="background-color:inherit;font-size:medium">Functional</code> is functional—<code style="background-color:inherit;font-size:medium">I.m</code> is return-type-substitutable for the other two—but <code style="background-color:inherit;font-size:medium">Functional&lt;String,Integer&gt;</code> clearly cannot be implemented with a single method.  However, other parameterizations of <code style="background-color:inherit;font-size:medium">Functional</code> <i>can</i> be implemented with a single method.
</p>
</div></li>
<li style="margin-bottom:12px;"><div>A design goal for functional interfaces is to interact cleanly with raw types in abstract method declarations without unnecessarily encouraging or introducing their use.
<p>The <i>subsignature</i> definition in the JLS allows an erased signature to override an unerased version (note that the "signature" consists of a name, type parameters, and parameter types, but not <code style="background-color:inherit;font-size:medium">return</code> or <code style="background-color:inherit;font-size:medium">throws</code> types).  It does not allow piecemeal erasure—either the entire signature must be erased, or the two signatures must be the same.  Thus, if the set <em>M</em> used in the functional interface definition contains one method that has a subsignature of all the others, then the set contains at most two unique signatures: an erased version, and a non-erased version.  If there is an erased version, that is the signature we use.  Then, for simplicity, the set of candidate return types is restricted to those that appear on an erased-signature method.
</p><p>When there are multiple methods with <i>different</i> unerased signatures, the interface is not functional.  We do not attempt to unify them via erasure.  For example, it would be possible to treat the following as a functional interface, but we prefer not to, since there's a clear problem with the interface's design, and we don't want to <i>introduce</i> raw types into a program.
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
 interface A { void f(List&lt;String&gt; ls); }
 interface B { void f(List&lt;Integer&gt; li); }
 interface C extends A,B {}
 C c1 = (List l) -&gt; ...;
 C c2 = l -&gt; ...;
</pre>
<p>When some return types are erased and others are not, we try to choose the non-erased type, if possible:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
LinkedList foo()
List&lt;?&gt; foo()
LinkedList&lt;String&gt; foo()
LinkedList&lt;?&gt; foo()
</pre>
</div></li>
<li style="margin-bottom:12px;"><div> While the name may suggest otherwise, a "function type" is <i>not</i> a type in the sense of <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.1" class="external text" rel="nofollow">4.1</a>.  It is a collection of types that form a method signature, return type, and <code style="background-color:inherit;font-size:medium">throws</code> clause.  This abuse of the "type" terminology is consistent with precedent—see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.2" class="external text" rel="nofollow">8.2</a>.
</div></li>
<li style="margin-bottom:12px;"><div> The function type of a functional interface is defined nondeterministically: while the signatures in <em>M</em> are "the same", they may be syntactically different (<code style="background-color:inherit;font-size:medium">HashMap.Entry</code> and <code style="background-color:inherit;font-size:medium">Map.Entry</code>, for example); the return type may be a subtype of every other return type, but there may be other return types that are <i>also</i> subtypes (<code style="background-color:inherit;font-size:medium">List&lt;?&gt;</code> and <code style="background-color:inherit;font-size:medium">List&lt;? extends Object&gt;</code>, for example); and the order of thrown types is unspecified.
<p>These distinctions are subtle, but they can sometimes be important.  However, function types will not be used in a way in which the nondeterminism matters.  It may affect generated code, but that is mostly implementation-dependent anyway.
</p><p>Note that the current JLS similarly defines the return type and throws clause of a "most specific method" nondeterministically when there are multiple abstract methods (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.5" class="external text" rel="nofollow">15.12.2.5</a>).
</p>
</div></li>
<li style="margin-bottom:12px;"><div>
<p>Function types are allowed to be generic.  There is no syntax in this specification for generic lambda expressions (<a href="#B15.27" title="Lambda B" class="mw-redirect">see 15.27</a>).  However, generic methods and constructors can instantiate such functional interfaces (<a href="#E15.13.2" title="Lambda E" class="mw-redirect">see 15.13.2</a>).
</p>
</div></li>
<li style="margin-bottom:12px;"><div> The goal driving the definition of a function type's thrown exception types is to support the invariant that a method with the resulting <code style="background-color:inherit;font-size:medium">throws</code> clause could override each abstract method of the functional interface.  Per <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.6" class="external text" rel="nofollow">8.4.6</a>, this means the function type cannot throw "more" exceptions than any single method in the set <em>M</em>.  So we look for as many exception types as possible that are "covered" by every method's <code style="background-color:inherit;font-size:medium">throws</code> clause.
</div></li>
<li style="margin-bottom:12px;"><div> When a functional interface is wildcard-parameterized, there are many different instantiations that could satisfy the wildcard and produce different function types: e.g., each of <code style="background-color:inherit;font-size:medium">Predicate&lt;Integer&gt;</code> (function type <code style="background-color:inherit;font-size:medium">Integer -&gt; boolean</code>), <code style="background-color:inherit;font-size:medium">Predicate&lt;Number&gt;</code> (function type <code style="background-color:inherit;font-size:medium">Number -&gt; boolean</code>), and <code style="background-color:inherit;font-size:medium">Predicate&lt;Object&gt;</code> (function type <code style="background-color:inherit;font-size:medium">Object -&gt; boolean</code>) is a <code style="background-color:inherit;font-size:medium">Predicate&lt;? super Integer&gt;</code>.  Sometimes, we can tell from context (e.g., the parameter types of a lambda expression) which is intended (<a href="#E15.27.3" title="Lambda E" class="mw-redirect">see 15.27.3</a>).  Other times, we're left to arbitrarily pick one; in these circumstances, we just choose the bounds.  (Since this simple strategy can't guarantee that the resulting type will satisfy certain complex bounds, we give up in complex cases.)
</div></li>
<li style="margin-bottom:12px;"><div> In special circumstances, it is useful to treat an intersection type as a functional interface type, so this is supported.  Typically, this will look like an intersection of one functional interface and one or more marker interfaces: <code style="background-color:inherit;font-size:medium">Runnable &amp; Serializable</code>.
<p>In practice, such types can be used in casts (<a href="#D15.16" title="Lambda D" class="mw-redirect">15.16</a>) that force a lambda expression to conform to a certain type.  As a special case, when one of the interfaces in the intersection is <code style="background-color:inherit;font-size:medium">Serializable</code>, special runtime support for serialization will be triggered (<a href="#E15.27.4" title="Lambda E" class="mw-redirect">see 15.27.4</a>).
</p>
</div></li></ol></div></blockquote>
<div id="A4.9"></div>
<h3> <span class="mw-headline" id="4.9_Intersection_Type_.5BModified.5D"> 4.9 Intersection Type [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.9" class="external text" rel="nofollow">JLS 4.9</a></small>
</p><p><span class="norm-static">
An intersection type takes the form <em>T<sub>1</sub> &amp; ... &amp; T<sub>n</sub></em> (<em>n &gt; 0</em>), where <em>T<sub>i</sub></em> (<em>1 ≤ i ≤ n</em>) are <del>type expressions</del> <u>types</u>.<span class="assertion-id"> [jls-4.9-100]</span></span>
</p><p>Intersection types <u>can be derived from type parameter bounds (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.4" class="external text" rel="nofollow">4.4</a>) and cast expressions (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.16" class="external text" rel="nofollow">15.16</a>); they also</u> arise in the processes of capture conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.10" class="external text" rel="nofollow">5.1.10</a>) and <del>type inference (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.7" class="external text" rel="nofollow">15.12.2.7</a>)</del> <u>least upper bound computation (<a href="#G4.10.4" title="Lambda G" class="mw-redirect">4.10.4</a>)</u>.  It is not possible to write an intersection type directly <del>as part of a program</del> <u>in a place where a <em>Type</em> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.1" class="external text" rel="nofollow">4.1</a>) is expected</u>; no syntax supports this.
</p><p>The values of an intersection type are those objects that are values of all of the types <em>T<sub>i</sub></em> for <em>1 ≤ i ≤ n</em>.
</p><p><span class="norm-static">
<u>Every intersection type <i>induces</i> a notional class or interface for the purpose of identifying the members of the intersection,</u> as follows:<span class="assertion-id"> [jsr335-4.9-301]</span></span>
</p>
<ul><li> <span class="norm-static"> For each <em>T<sub>i</sub></em> (<em>1 ≤ i ≤ n</em>), let <em>C<sub>i</sub></em> be the most specific class or array type such that <em>T<sub>i</sub> &lt;: C<sub>i</sub></em>.  Then there must be some <del><em>T<sub>k</sub> &lt;:</em></del> <em>C<sub>k</sub></em> such that <em>C<sub>k</sub> &lt;: C<sub>i</sub></em> for any <em>i</em> (<em>1 ≤ i ≤ n</em>), or a compile-time error occurs.<span class="assertion-id"> [jls-4.9-300-A]</span></span>
</li><li> <span class="norm-static"> For <em>1 ≤ j ≤ n</em>, if <em>T<sub>j</sub></em> is a type variable, then let <em>T'<sub>j</sub></em> be an interface whose members are the same as the public members of <em>T<sub>j</sub></em>; otherwise, if <em>T<sub>j</sub></em> is an interface, then let <em>T'<sub>j</sub></em> be <em>T<sub>j</sub></em>.<span class="assertion-id"> [jls-4.9-300-B]</span></span>
</li><li> <span class="norm-static"> Then <u>if <em>C<sub>k</sub></em> is <code style="background-color:inherit;font-size:medium">Object</code>, a notional interface is induced; otherwise, a notional class is induced with direct superclass <em>C<sub>k</sub></em>.  This class or interface has</u> direct superinterfaces <em>T'<sub>1</sub>, ..., T'<sub>n</sub></em>, <u>and is</u> declared in the same package in which the intersection type appears.<span class="assertion-id"> [jls-4.9-300-C]</span></span>
</li></ul>
<p><span class="norm-static">
The members of an intersection type <u>are the members of the class or interface it induces</u>.<span class="assertion-id"> [jls-4.9-300]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
There are a number of problems with this definition of the members of an intersection (including no allowance for wildcards, extending an array type, and lack of explicit well-formedness rules), but those problems are set aside for now.  Our only goal is to adjust the existing rules so that an intersection may be treated as a functional interface in certain circumstances.</div></blockquote>
<div id="A8.2"></div>
<h3> <span class="mw-headline" id="8.2_Class_Members_.5BModified.5D"> 8.2 Class Members [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.2" class="external text" rel="nofollow">JLS 8.2</a></small>
</p><p>...
</p><p><span class="norm-static">
We use the phrase <i>the type of a member</i> to denote:<span class="assertion-id"> [jls-8.2-200]</span></span>
</p>
<ul><li> <span class="norm-static"> For a field, its type.<span class="assertion-id"> [jls-8.2-200-A]</span></span>
</li><li> <span class="norm-static"> For a method, an ordered <del>3-tuple</del> <u>4-tuple</u> consisting of:<span class="assertion-id"> [jls-8.2-200-B]</span></span>
<ul><li> <span class="norm-static"> <u>type parameters: the declarations of any type parameters of the method member.</u><span class="assertion-id"> [jls-8.2-200-B-D]</span></span>
</li><li> <span class="norm-static"> arguments types: a list of the types of the arguments to the method member.<span class="assertion-id"> [jls-8.2-200-B-A]</span></span>
</li><li> <span class="norm-static"> return type: the return type of the method member.<span class="assertion-id"> [jls-8.2-200-B-B]</span></span>
</li><li> <span class="norm-static"> throws clause: exception types declared in the throws clause of the method member.<span class="assertion-id"> [jls-8.2-200-B-C]</span></span>
</li></ul>
</li></ul>
<p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
This is a bug fix, necessary to clarify what constitutes a <i>function type</i>.</div></blockquote>
<div id="A8.4.2"></div>
<h3> <span class="mw-headline" id="8.4.2_Method_Signature_.5BModified.5D"> 8.4.2 Method Signature [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.2" class="external text" rel="nofollow">JLS 8.4.2</a></small>
</p><p><span class="norm-static">Two methods <u>or constructors, <em>M</em> and <em>N</em>,</u> have the <i>same signature</i> if they have the same name, <u>the same type parameters (if any) (<a href="#A8.4.4" title="Lambda A" class="mw-redirect">8.4.4</a>), and, after adapting the formal parameter types of <em>N</em> to the the type parameters of <em>M</em>, the same formal parameter types</u>.<span class="assertion-id"> [jls-8.4.2-100]</span></span>
</p><p><del><span class="norm-static"> Two method or constructor declarations <em>M</em> and <em>N</em> have the <i>same argument types</i> if all of the following conditions hold:<span class="assertion-id"> [jls-8.4.2-110]</span></span></del>
</p>
<ul><li> <del><span class="norm-static"> They have the same number of formal parameters (possibly zero)<span class="assertion-id"> [jls-8.4.2-110-A]</span></span></del>
</li><li> <del><span class="norm-static"> They have the same number of type parameters (possibly zero)<span class="assertion-id"> [jls-8.4.2-110-B]</span></span></del>
</li><li> <del><span class="norm-static"> Let <em>A<sub>1</sub>, ..., A<sub>n</sub></em> be the type parameters of <em>M</em> and let <em>B<sub>1</sub>, ..., B<sub>n</sub></em> be the type parameters of <em>N</em>.  After renaming each occurrence of a <em>B<sub>i</sub></em> in <em>N</em>'s type to <em>A<sub>i</sub></em>, the bounds of corresponding type variables are the same, and the formal parameter types of <em>M</em> and <em>N</em> are the same.<span class="assertion-id"> [jls-8.4.2-110-C]</span></span></del>
</li></ul>
<p>...
</p>
<div id="A8.4.4"></div>
<h3> <span class="mw-headline" id="8.4.4_Generic_Methods_.5BAddendum.5D"> 8.4.4 Generic Methods [Addendum] </span></h3>
<p><small>See <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.4" class="external text" rel="nofollow">JLS 8.4.4</a></small>
</p><p><span class="norm-static">Two methods or constructors <em>M</em> and <em>N</em> have the <i>same type parameters</i> if both of the following are true:<span class="assertion-id"> [jsr335-8.4.4-10]</span></span>
</p>
<ul><li> <span class="norm-static"><em>M</em> and <em>N</em> have same number of type parameters (possibly zero).<span class="assertion-id"> [jsr335-8.4.4-10-A]</span></span>
</li><li> <span class="norm-static">Where <em>A<sub>1</sub>, ... , A<sub>n</sub></em> are the type parameters of <em>M</em> and <em>B<sub>1</sub>, ..., B<sub>n</sub></em> are the type parameters of <em>N</em>, let <em>θ=[B<sub>1</sub>:=A<sub>1</sub>, ..., B<sub>n</sub>:=A<sub>n</sub>]</em>.  Then, for all <em>i</em>, <em>1≤i≤n</em>, the bound of <em>A<sub>i</sub></em> is the same type as <em>θ</em> applied to the bound of <em>B<sub>i</sub></em>.<span class="assertion-id"> [jsr335-8.4.4-10-B]</span></span>
</li></ul>
<p><span class="norm-static">Where two methods or constructors <em>M</em> and <em>N</em> have the same type parameters, a type mentioned in <em>N</em> can be <i>adapted to the type parameters</i> of <em>M</em> by applying <em>θ</em>, as defined above, to the type.<span class="assertion-id"> [jsr335-8.4.4-20]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
This concept of type parameter adaptation is implicit in JLS 7 but never expressed outright.  Being explicit about it allows us to more precisely and correctly identify the return type and <code style="background-color:inherit;font-size:medium">throws</code> clause of a function type.</div></blockquote>
<div id="A8.4.5"></div>
<h3> <span class="mw-headline" id="8.4.5_Method_Return_Type_.5BModified.5D"> 8.4.5 Method Return Type [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.5" class="external text" rel="nofollow">JLS 8.4.5</a></small>
</p><p><span class="norm-static">A method declaration <em>d<sub>1</sub></em> with return type <em>R<sub>1</sub></em> is <i>return-type-substitutable</i> for another method <em>d<sub>2</sub></em> with return type <em>R<sub>2</sub></em>, if and only if the following conditions hold:<span class="assertion-id"> [jls-8.4.5-210]</span></span>
</p>
<ul><li> <span class="norm-static">If <em>R<sub>1</sub></em> is <code style="background-color:inherit;font-size:medium">void</code> then <em>R<sub>2</sub></em> is <code style="background-color:inherit;font-size:medium">void</code>.<span class="assertion-id"> [jls-8.4.5-210-A]</span></span>
</li><li> <span class="norm-static">If <em>R<sub>1</sub></em> is a primitive type, then <em>R<sub>2</sub></em> is identical to <em>R<sub>1</sub></em>.<span class="assertion-id"> [jls-8.4.5-210-B]</span></span>
</li><li> <span class="norm-static">If <em>R<sub>1</sub></em> is a reference type then <u>one of the following is true</u>:<span class="assertion-id"> [jls-8.4.5-210-C]</span></span>
<ul><li> <span class="norm-static"><em>R<sub>1</sub></em>, <u>adapted to the type parameters of <em>d<sub>2</sub></em> (<a href="#A8.4.4" title="Lambda A" class="mw-redirect">8.4.4</a>)</u>, is <del>either</del> a subtype of <em>R<sub>2</sub></em>.<span class="assertion-id"> [jls-8.4.5-210-C-1]</span></span> <del>or</del>
</li><li> <span class="norm-static"><em>R<sub>1</sub></em> can be converted to a subtype of <em>R<sub>2</sub></em> by unchecked conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.9" class="external text" rel="nofollow">5.1.9</a>).<span class="assertion-id"> [jls-8.4.5-210-C-1']</span></span> <del>or</del>
</li><li> <span class="norm-static"><u><em>d<sub>1</sub></em> does not have the same signature as <em>d<sub>2</sub></em> (<a href="#A8.4.2" title="Lambda A" class="mw-redirect">8.4.2</a>)</u>, and <em>R1 = |R2|</em><span class="assertion-id"> [jls-8.4.5-210-C-2]</span></span>
</li></ul>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
This is a bug fix for the specification.  First, it adjusts the <em>R1 = |R2|</em> rule to more accurately describe longstanding behavior.  Second, it takes advantage of the definition of type parameter adaptation (<a href="#A8.4.4" title="Lambda A" class="mw-redirect">8.4.4</a>).</div></blockquote>
<div id="A8.4.6"></div>
<h3> <span class="mw-headline" id="8.4.6_Method_Throws_.5BModified.5D"> 8.4.6 Method Throws [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.6" class="external text" rel="nofollow">JLS 8.4.6</a></small>
</p><p>...
</p><p><span class="norm-error"> If the unerased <code style="background-color:inherit;font-size:medium">throws</code> clause of <em>m</em> does not contain a supertype of each exception type in the <code style="background-color:inherit;font-size:medium">throws</code> clause of <em>n</em> <u>(adapted, if necessary, to the type parameters of <em>m</em>)</u>, a compile-time unchecked warning occurs.<span class="assertion-id"> [jls-8.4.8.3-210-C]</span></span>
</p><p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
This takes advantage of the definition of type parameter adaptation, above, and can be viewed as a bug fix for the specification.</div></blockquote>
<div id="A9.6.3.8"></div>
<h3> <span class="mw-headline" id="9.6.3.8_FunctionalInterface_.5BNew.5D"> 9.6.3.8 FunctionalInterface [New] </span></h3>
<p>The annotation type <code style="background-color:inherit;font-size:medium">FunctionalInterface</code> is used to indicate that an interface is meant to be a functional interface (<a href="#A9.8" title="Lambda A" class="mw-redirect">9.8</a>).
</p><p><span class="norm-error">
If an interface is annotated with the annotation <code style="background-color:inherit;font-size:medium">@FunctionalInterface</code> but is not, in fact, a functional interface, a compile-time error occurs.<span class="assertion-id"> [jsr335-9.6.3.8-10]</span></span>
</p><p>This facilitates early detection of inappropriate method declarations appearing in or inherited by an interface that is meant to be functional.
</p><p>Because some interfaces are functional incidentally, it is not necessary or desirable that all functional interfaces be annotated with the <code style="background-color:inherit;font-size:medium">@FunctionalInterface</code> annotation.
</p>


<a id="top"></a>
	
	<a id="B"/><h1 id="firstHeading" class="firstHeading">Lambda Specification, Part B: Lambda Expressions</h1>
									<p><small>
Navigation: <a href="#overview" title="Lambda Specification" class="mw-redirect">Overview</a>&nbsp;- <a href="#A" title="Lambda A" class="mw-redirect">Part A</a>&nbsp;- <a href="#B" title="Lambda B" class="mw-redirect">Part B</a>&nbsp;- <a href="#C" title="Lambda C" class="mw-redirect">Part C</a>&nbsp;- <a href="#D" title="Lambda D" class="mw-redirect">Part D</a>&nbsp;- <a href="#E" title="Lambda E" class="mw-redirect">Part E</a>&nbsp;- <a href="#F" title="Lambda F" class="mw-redirect">Part F</a>&nbsp;- <a href="#G" title="Lambda G" class="mw-redirect">Part G</a>&nbsp;- <a href="#H" title="Lambda H" class="mw-redirect">Part H</a>&nbsp;- <a href="#J" title="Lambda J" class="mw-redirect">Part J</a>
<br />
Sections: <a href="#B15.27">15.27</a>&nbsp;- <a href="#B15.27.1">15.27.1</a>&nbsp;- <a href="#B15.27.2">15.27.2</a>&nbsp;- <a href="#B3.9">3.9</a>&nbsp;- <a href="#B3.12">3.12</a>&nbsp;- <a href="#B4.12.3">4.12.3</a>&nbsp;- <a href="#B4.12.4">4.12.4</a>&nbsp;- <a href="#B6.3">6.3</a>&nbsp;- <a href="#B6.4">6.4</a>&nbsp;- <a href="#B8.1.3">8.1.3</a>&nbsp;- <a href="#B14.15">14.15</a>&nbsp;- <a href="#B14.16">14.16</a>&nbsp;- <a href="#B14.17">14.17</a>&nbsp;- <a href="#B14.18">14.18</a>&nbsp;- <a href="#B14.20">14.20</a>&nbsp;- <a href="#B15.8.3">15.8.3</a>&nbsp;- <a href="#B16">16</a>
<br />
Version 0.9.3.  Copyright © 2014 Oracle America, Inc.  <a href="#Legal_Notice" title="Lambda Specification" class="mw-redirect">Legal Notice</a>.
</small>
</p>
<h3> <span class="mw-headline" id="Summary"> Summary </span></h3>
<p>A lambda expression is like a method: it provides a list of formal parameters and a body—an expression or block—expressed in terms of those parameters.
</p><p>Examples of lambda expressions:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
s -&gt; s.length()

(int x, int y) -&gt; x+y

() -&gt; 42

(x, y, z) -&gt; {
  if (true) return x;
  else {
    int result = y;
    for (int i = 1; i &lt; z; i++)
      result *= i;
    return result;
  }
}
</pre>
<p>This particular syntax was chosen principally because something similar has been generally well-received in other Java-like languages (C# and Scala), and a clearly "better" alternative did not present itself. It has the advantage over alternate proposals of minimizing bracketing noise around simple lambda expressions.  When some extra bracketing is needed to visually distinguish either the full lambda expression or its body expression, parentheses are naturally supported (just as in other cases in which operator precedence is unclear).
</p><p>The formal parameters of a lambda expression may have either declared types or inferred types. We refer to a lambda expression whose formal parameters have declared types as <i>explicitly-typed</i>, and a lambda expression whose formal parameters have inferred types as <i>implicitly-typed</i>.  The parameter types of an implicitly-typed lambda are derived from the functional interface type targeted by the expression.
</p><p>A lambda body is either a single expression or a block. Like a method body, a lambda body describes code that will be executed whenever an invocation occurs.
</p><p>Unlike code appearing in anonymous class declarations, the meaning of names and the <code style="background-color:inherit;font-size:medium">this</code> and <code style="background-color:inherit;font-size:medium">super</code> keywords appearing in a lambda body are the same as in the surrounding context (except that lambda parameters introduce new names).
</p><p>For both lambda bodies and inner classes, local variables in the enclosing context can only be referenced if they are <code style="background-color:inherit;font-size:medium">final</code> or <i>effectively final</i>. A variable is <i>effectively final</i> if it is never assigned to after its initialization.
</p><p>Block lambda bodies that don't return anything are considered <i>void-compatible</i>; block lambda bodies that return a value from every execution path are considered <i>value-compatible</i>. In a value-compatible lambda body, the <i>result expressions</i> are any expressions that may produce an invocation's value.
</p>
<div id="B15.27"></div>
<h3> <span class="mw-headline" id="15.27_Lambda_Expressions_.5BNew.5D"> 15.27 Lambda Expressions [New] </span></h3>
<p>A lambda expression is like a method: it provides a list of formal parameters and a body—an expression or block—expressed in terms of those parameters.
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
LambdaExpression:
  LambdaParameters '-&gt;' LambdaBody

LambdaParameters:
  Identifier
  '(' FormalParameterList<sub>opt</sub> ')'
  '(' InferredFormalParameterList ')'

InferredFormalParameterList:
  Identifier
  InferredFormalParameterList ',' Identifier

LambdaBody:
  Expression
  Block
</pre>
<p>The following definitions from <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1" class="external text" rel="nofollow">8.4.1</a> are repeated here for convenience:
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
FormalParameterList:
  LastFormalParameter
  FormalParameters ',' LastFormalParameter

FormalParameters:
  FormalParameter
  FormalParameters, FormalParameter

FormalParameter:
  VariableModifiers<sub>opt</sub> Type VariableDeclaratorId

LastFormalParameter:
  VariableModifiers<sub>opt</sub> Type '...' VariableDeclaratorId
  FormalParameter
</pre>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Examples of lambda expressions:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
() -&gt; {}                     // No parameters; result is void

() -&gt; 42                     // No parameters, expression body
() -&gt; null                   // No parameters, expression body
() -&gt; { return 42; }         // No parameters, block body with return
() -&gt; { System.gc(); }       // No parameters, void block body

() -&gt; {
  if (true) return 12;
  else {
    int result = 15;
    for (int i = 1; i &lt; 10; i++)
      result *= i;
    return result;
  }
}                          // Complex block body with returns

(int x) -&gt; x+1             // Single declared-type parameter
(int x) -&gt; { return x+1; } // Single declared-type parameter
(x) -&gt; x+1                 // Single inferred-type parameter
x -&gt; x+1                   // Parens optional for single inferred-type case

(String s) -&gt; s.length()   // Single declared-type parameter
(Thread t) -&gt; { t.start(); } // Single declared-type parameter
s -&gt; s.length()              // Single inferred-type parameter
t -&gt; { t.start(); }          // Single inferred-type parameter

(int x, int y) -&gt; x+y      // Multiple declared-type parameters
(x,y) -&gt; x+y               // Multiple inferred-type parameters
(final int x) -&gt; x+1       // Modified declared-type parameter
(x, final y) -&gt; x+y        // Illegal: can't modify inferred-type parameters
(x, int y) -&gt; x+y          // Illegal: can't mix inferred and declared types
</pre>
</div></blockquote>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> This particular syntax was chosen principally because something similar has been generally well-received in other Java-like languages (C# and Scala), and a clearly "better" alternative did not present itself.  It has the advantage over alternate proposals of minimizing bracketing noise around simple lambda expressions; this is especially noticeable when a lambda expression is an argument to a method, or when the body is another lambda expression.  It also clearly distinguishes between its expression and statement forms, which avoids ambiguities or over-reliance on '<code style="background-color:inherit;font-size:medium">;</code>' tokens.
<p>When some extra bracketing is needed to visually distinguish either the full lambda expression or its body expression, parentheses are naturally supported (just as in other cases in which operator precedence is unclear).
</p><p>There is no special nullary form: a lambda expression with 0 arguments is expressed as <code style="background-color:inherit;font-size:medium">() -&gt; ...</code>.  The obvious special-case syntax, <code style="background-color:inherit;font-size:medium">-&gt; ...</code>, does not work because it introduces an ambiguity between argument lists and casts: <code style="background-color:inherit;font-size:medium">(x) -&gt; ...</code>.
</p><p>A nice property of this syntax for block bodies is that established conventions for indenting and line-breaking other block-like syntax extend quite naturally to lambda expressions.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> This syntax introduces some new parsing challenges, although they are similar in scope to what is already handled by the Java grammar.
<p>Java has always had an ambiguity between types and expressions after a '<code style="background-color:inherit;font-size:medium">(</code>' token (what follows may be a cast or a parenthesized expression).  This was made worse in Java 5, which reused the binary operators '<code style="background-color:inherit;font-size:medium">&lt;</code>' and '<code style="background-color:inherit;font-size:medium">&gt;</code>' in types.
</p><p>Lambda expressions introduce a new possibility: the tokens following '<code style="background-color:inherit;font-size:medium">(</code>' may describe a type, an expression, or a lambda parameter list.  Some tokens (annotations, <code style="background-color:inherit;font-size:medium">final</code>) are unique to parameter lists, while in other cases there are certain patterns that must be interpreted as parameter lists (two names in a row, a '<code style="background-color:inherit;font-size:medium">,</code>' not nested inside of '<code style="background-color:inherit;font-size:medium">&lt;</code>' and '<code style="background-color:inherit;font-size:medium">&gt;</code>').  And sometimes the ambiguity cannot be resolved until a '<code style="background-color:inherit;font-size:medium">-&gt;</code>' is encountered, after a '<code style="background-color:inherit;font-size:medium">)</code>'.  The simplest way to think of how this might be efficiently parsed is with a state machine: each state represents a subset of possible interpretations (type, expression, or parameters), and when the machine transitions to a state in which the set is a singleton, the parser knows which case it is.  This does not map very elegantly to a fixed-lookahead grammar, however.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> Lambda expressions cannot introduce type parameters.  While it would make sense semantically to do so, the natural syntax (preceding the parameter list with a type parameter list) introduces messy ambiguities.  For example:
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">foo( (x) &lt; y , z &gt; (w) -&gt; v )</pre>
<p>This could be an invocation of <code style="background-color:inherit;font-size:medium">foo</code> with one argument (a generic lambda cast to type <code style="background-color:inherit;font-size:medium">x</code>), or it could be an invocation of <code style="background-color:inherit;font-size:medium">foo</code> with two arguments, both the results of comparisons, the second comparing <code style="background-color:inherit;font-size:medium">z</code> with a lambda expression.  (Strictly speaking, a lambda expression is meaningless as an operand to a binary '<code style="background-color:inherit;font-size:medium">&gt;</code>', but that is a tenuous assumption on which to build the grammar.)
</p><p>There is a precedent for ambiguity resolution involving casts, which essentially prohibits the use of <code style="background-color:inherit;font-size:medium">-</code> and <code style="background-color:inherit;font-size:medium">+</code> following a non-primitive cast, but to extend that principle to generic lambdas involves invasive, messy changes to the grammar.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> Section <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.27" class="external text" rel="nofollow">15.27</a> currently defines the <i>Expression</i> grammar production.  To reasonably accommodate the chapter structure without drastically changing section numbers, this grammar production has been moved to <a href="#D15.2" title="Lambda D" class="mw-redirect">15.2</a> and 15.27 has been repurposed to address lambda expressions.
</div></li></ol></div></blockquote>
<div id="B15.27.1"></div>
<h3> <span class="mw-headline" id="15.27.1_Lambda_Parameters_.5BNew.5D"> 15.27.1 Lambda Parameters [New] </span></h3>
<p><span class="norm-static">
The formal parameters of a lambda expression may have either declared types or inferred types.  These styles cannot be mixed: it is not possible for a lambda expression to declare the types of some of its parameters but leave others to be inferred.  Only parameters with declared types can have modifiers.<span class="assertion-id"> [jsr335-15.27.1-10]</span></span>
</p><p><span class="norm-static">
We refer to a lambda expression whose formal parameters have declared types as <i>explicitly-typed</i>, and a lambda expression whose formal parameters have inferred types as <i>implicitly-typed</i>.  Lambda expressions with 0 parameters are explicitly-typed.<span class="assertion-id"> [jsr335-15.27.1-12]</span></span>
</p><p><span class="norm-static">
The syntax for formal parameters with declared types is the same as the syntax for the parameters of a method declaration (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1" class="external text" rel="nofollow">8.4.1</a>).<span class="assertion-id"> [jsr335-15.27.1-20]</span></span>
</p><p><span class="norm-static">
The declared type of a formal parameter is denoted by the <em>Type</em> that appears in its parameter specifier, followed by any bracket pairs that follow the <em>Identifier</em> in the declarator, except for a variable arity parameter, whose declared type is an array type whose component type is the <em>Type</em> that appears in its parameter specifier.<span class="assertion-id"> [jsr335-15.27.1-21]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The previous paragraph comes from <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1" class="external text" rel="nofollow">8.4.1</a> "Formal Parameters."</div></blockquote>
<p>If the formal parameters have inferred types, then these types are derived (<a href="#E15.27.3" title="Lambda E" class="mw-redirect">15.27.3</a>) from the functional interface type targeted by the lambda expression.
</p><p><span class="norm-error">
It is a compile-time error if a lambda parameter has the name <code style="background-color:inherit;font-size:medium">_</code> (that is, a single underscore character).<span class="assertion-id"> [jsr335-15.27.1-23]</span></span>
</p><p>The use of the variable name <code style="background-color:inherit;font-size:medium">_</code> in any context is discouraged; future versions of the Java Programming Language may reserve this name as a keyword and/or give it special semantics.
</p><p><span class="norm-error">
If an annotation <em>a</em> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.7" class="external text" rel="nofollow">9.7</a>) on a formal parameter corresponds to an annotation type <em>T</em> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.6" class="external text" rel="nofollow">9.6</a>), and <em>T</em> has a (meta-)annotation <em>m</em> that corresponds to <code style="background-color:inherit;font-size:medium">java.lang.annotation.Target</code>, then <em>m</em> must have an element whose value is <code style="background-color:inherit;font-size:medium">java.lang.annotation.ElementType.PARAMETER</code>, or a compile-time error occurs.<span class="assertion-id"> [jsr335-15.27.1-22]</span></span>
</p><p><span class="norm-static">
The scope and shadowing of a formal parameter is specified in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.3" class="external text" rel="nofollow">6.3</a> and <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.4" class="external text" rel="nofollow">6.4</a>.<span class="assertion-id"> [jsr335-15.27.1-30]</span></span>
</p><p><span class="norm-error">
It is a compile-time error for a lambda expression to declare two formal parameters with the same name. (That is, their declarations mention the same <em>Identifier</em>.)<span class="assertion-id"> [jsr335-15.27.1-40]</span></span>
</p><p><span class="norm-error">
It is a compile-time error if a formal parameter that is declared final is assigned to within the body of the lambda expression.<span class="assertion-id"> [jsr335-15.27.1-50]</span></span>
</p><p><span class="norm-error">
It is a compile-time error to use mixed array notation (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-10.html#jls-10.2" class="external text" rel="nofollow">10.2</a>) for a variable arity parameter.<span class="assertion-id"> [jsr335-15.27.1-60]</span></span>
</p><p><span class="norm-dynamic">
When the lambda expression is invoked (via a method invocation expression (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">15.12</a>)), the values of the actual argument expressions initialize newly created parameter variables, each of the declared or inferred type, before execution of the lambda body. The <em>Identifier</em> that appears in the <em>VariableDeclaratorId</em> or the <em>InferredFormalParameterList</em> may be used as a simple name in the lambda body to refer to the formal parameter.<span class="assertion-id"> [jsr335-15.27.1-70]</span></span>
</p><p><span class="norm-dynamic">
A lambda parameter of type <code style="background-color:inherit;font-size:medium">float</code> always contains an element of the float value set (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2.3" class="external text" rel="nofollow">4.2.3</a>); similarly, a lambda parameter of type <code style="background-color:inherit;font-size:medium">double</code> always contains an element of the double value set. It is not permitted for a lambda parameter of type <code style="background-color:inherit;font-size:medium">float</code> to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a lambda parameter of type <code style="background-color:inherit;font-size:medium">double</code> to contain an element of the double-extended-exponent value set that is not also an element of the double value set.<span class="assertion-id"> [jsr335-15.27.1-80]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The previous seven paragraphs are derived from <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1" class="external text" rel="nofollow">8.4.1</a> "Formal Parameters."</div></blockquote>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> When the lambda parameters' types are inferred, the same lambda expression body can be interpreted in many different ways, depending on the context in which it appears.  Specifically, the types of expressions in the body (including return statement values), the checked exceptions thrown, and the type-correctness of the code all depend on the formal parameters' inferred types.
<p>This implies that inference of parameter types must occur <i>before</i> attempting to type-check the body of the lambda expression.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> There is no distinction made between the following lambda parameter lists:
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
(int... x) -&gt; ..
(int[] x) -&gt; ..
</pre>
<p>Consistent with the rules for overriding, either can be used, whether the functional interface's abstract method is varargs or not.  Since lambda expressions are never directly invoked, introducing <code style="background-color:inherit;font-size:medium">int...</code> where the functional interface uses <code style="background-color:inherit;font-size:medium">int[]</code> can have no impact on the surrounding program.  And, of course, in the lambda body, a varargs parameter is treated just like an array parameter.
</p>
</div></li>
<li style="margin-bottom:12px;"><div>
<p>The <code style="background-color:inherit;font-size:medium">_</code> character has special meaning in other languages with lambda expressions; to avoid confusion, we reserve it here.  Future versions of Java may give the <code style="background-color:inherit;font-size:medium">_</code> name special semantics—for example, to indicate an unnamed parameter.
</p>
</div></li></ol></div></blockquote>
<div id="B15.27.2"></div>
<h3> <span class="mw-headline" id="15.27.2_Lambda_Body_.5BNew.5D"> 15.27.2 Lambda Body [New] </span></h3>
<p><span class="norm-static">
A lambda body is either a single expression or a block (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.2" class="external text" rel="nofollow">14.2</a>).<span class="assertion-id"> [jsr335-15.27.2-10]</span></span>
</p><p>Like a method body, a lambda body describes code that will be executed whenever an invocation occurs.
</p><p><span class="norm-static">
Unlike code appearing in anonymous class declarations, the meaning of names and the <code style="background-color:inherit;font-size:medium">this</code> and <code style="background-color:inherit;font-size:medium">super</code> keywords appearing in a lambda body, along with the accessibility of referenced declarations, are the same as in the surrounding context (except that lambda parameters introduce new names).<span class="assertion-id"> [jsr335-15.27.2-20]</span></span>
</p><p><span class="norm-static">
A block lambda body is <i>void-compatible</i> if every return statement in the block has the form <code style="background-color:inherit;font-size:medium">return;</code>.<span class="assertion-id"> [jsr335-15.27.2-30]</span></span>
</p><p><span class="norm-static">
A block lambda body is <i>value-compatible</i> if it cannot complete normally (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.21" class="external text" rel="nofollow">14.21</a>) and every return statement in the block has the form <code style="background-color:inherit;font-size:medium">return <em>Expression</em>;</code>.<span class="assertion-id"> [jsr335-15.27.2-31]</span></span>
</p><p><span class="norm-error">
It is a compile-time error if a block lambda body is neither void-compatible nor value-compatible.<span class="assertion-id"> [jsr335-15.27.2-40]</span></span>
</p><p>Note that some block lambda bodies, such as <code style="background-color:inherit;font-size:medium">{ throw new RuntimeException(); }</code> are <i>both</i> void-compatible and value-compatible.
</p><p><span class="norm-static">
In a value-compatible block lambda body, the <i>result expressions</i> are any expressions that may produce an invocation's value.  Specifically, for each <code style="background-color:inherit;font-size:medium">return</code> statement (<a href="#B14.17" title="Lambda B" class="mw-redirect">14.17</a>) of the form <em><code style="background-color:inherit;font-size:medium">return</code> Expression <code style="background-color:inherit;font-size:medium">;</code></em> contained by the body, the <em>Expression</em> is a result expression.<span class="assertion-id"> [jsr335-15.27.2-50]</span></span>
</p><p><span class="norm-error">
Any local variable, formal parameter, or exception handler parameter used but not declared in a lambda expression must be either declared <code style="background-color:inherit;font-size:medium">final</code> or effectively final (<a href="#B4.12.4" title="Lambda B" class="mw-redirect">4.12.4</a>).<span class="assertion-id"> [jsr335-15.27.2-60]</span></span>
</p><p><span class="norm-error">
Any local variable used but not declared in a lambda body must be definitely assigned (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-16.html#jls-16" class="external text" rel="nofollow">16</a>) before the lambda body.<span class="assertion-id"> [jsr335-15.27.2-70]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The previous two paragraphs mimic <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.3" class="external text" rel="nofollow">8.1.3</a>, Inner Classes and Enclosing Instances.</div></blockquote>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Examples of void- and value-compatible:<br />
</p><p>These are value-compatible:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
() -&gt; { return &quot;done&quot;; }
() -&gt; { if (cond) return 1; else return 0; }
</pre>
<p>These are void-compatible:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
() -&gt; {}
() -&gt; { System.out.println(&quot;done&quot;); }
</pre>
<p>These are both:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
() -&gt; { throw new RuntimeException(); }
() -&gt; { while (true); }
</pre>
<p>This is neither:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
() -&gt; { if (cond) return &quot;done&quot;; System.out.println(&quot;done&quot;); }
</pre></div></blockquote>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> <div id="B15.27.2-.231"></div>
<p>The transparency of <code style="background-color:inherit;font-size:medium">this</code> (both explicit and implicit) in the body of a lambda expression—that is, treating it the same as in the surrounding context—allows more flexibility for VM optimizations, and prevents the meaning of unqualified names in the body from being dependent on overload resolution.
</p><p>Practically speaking, it is unusual for a lambda to need to talk about itself (either to call itself recursively or to invoke its other methods), while it is more common to want to use names to refer to things in the enclosing class that would otherwise be shadowed (<code style="background-color:inherit;font-size:medium">this</code>, <code style="background-color:inherit;font-size:medium">toString()</code>).  (This assertion is based on some analysis of existing code with anonymous inner classes.)
</p><p>If it is necessary for a lambda expression to refer to itself (as if via <code style="background-color:inherit;font-size:medium">this</code>), a method reference or an anonymous inner class should be used instead.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> The handling of void/value compatible and the meaning of names serve to minimize the dependency on a particular target type in the given context, which is useful both for implementations and for user understanding.  While expressions can be assigned different types during overload resolution depending on the target type, the meaning of unqualified names and basic structure of the lambda body do not change.
<p>It's worth noting that the void/value compatible definition is not a strictly structural property: "can complete normally" depends on the values of constant expressions, and these may include names that reference constant variables.
</p>
</div></li></ol></div></blockquote>
<div id="B3.12"></div>
<h3> <span class="mw-headline" id="3.12_Operators_.5BModified.5D"> 3.12 Operators [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.12" class="external text" rel="nofollow">JLS 3.12</a></small>
</p><p><span class="norm-static">
<del>37</del> <u>38</u> tokens are the <i>operators</i>, formed from ASCII characters.<span class="assertion-id"> [jls-3.12-100]</span></span>
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
Operator: one of
  ...
  '&gt;&gt;='
  '&gt;&gt;&gt;='
  <u>'-&gt;'</u>
</pre>
<div id="B4.12.3"></div>
<h3> <span class="mw-headline" id="4.12.3_Kinds_of_Variables_.5BModified.5D"> 4.12.3 Kinds of Variables [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.12.3" class="external text" rel="nofollow">JLS 4.12.3</a></small>
</p><p>There are <del>seven</del> <u>eight</u> kinds of variables:
</p>
<ol><li> A <i>class variable</i> ...
</li><li> An <i>instance variable</i> ...
</li><li> <i>Array components</i> ...
</li><li> <i>Method parameters</i> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1" class="external text" rel="nofollow">8.4.1</a>) name argument values passed to a method.  For every parameter declared in a method declaration, a new parameter variable is created each time that method is invoked (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">15.12</a>).  The new variable is initialized with the corresponding argument value from the method invocation.  The method parameter effectively ceases to exist when the execution of the body of the method is complete.
</li><li> <i>Constructor parameters</i> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8.1" class="external text" rel="nofollow">8.8.1</a>) name argument values passed to a constructor.  For every parameter declared in a constructor declaration, a new parameter variable is created each time a class instance creation expression (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9" class="external text" rel="nofollow">15.9</a>) or explicit constructor invocation (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8.7" class="external text" rel="nofollow">8.8.7</a>) invokes that constructor.  The new variable is initialized with the corresponding argument value from the creation expression or constructor invocation.  The constructor parameter effectively ceases to exist when the execution of the body of the constructor is complete.
</li><li> <u><i>Lambda parameters</i> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.27.1" class="external text" rel="nofollow">15.27.1</a>) name argument values passed to a lambda expression body (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.27.2" class="external text" rel="nofollow">15.27.2</a>).  For every parameter declared in a lambda expression, a new parameter variable is created each time a method implemented by the lambda body is invoked (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">15.12</a>).  The new variable is initialized with the corresponding argument value from the method invocation.  The lambda parameter effectively ceases to exist when the execution of the lambda expression body is complete.</u>
</li><li> An <i>exception parameter</i> ...
</li><li> <i>Local variables</i> ...
</li></ol>
<p>...
</p>
<div id="B4.12.4"></div>
<h3> <span class="mw-headline" id="4.12.4_Final_Variables_.5BAddendum.5D"> 4.12.4 Final Variables [Addendum] </span></h3>
<p><small>See <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.12.4" class="external text" rel="nofollow">JLS 4.12.4</a></small>
</p><p>Certain variables that are not declared <code style="background-color:inherit;font-size:medium">final</code> may instead be considered <i>effectively final</i>.
</p><p><span class="norm-static">
A local variable or a method, constructor, lambda, or exception parameter is <i>effectively final</i> if it is not final but it never occurs as the left hand operand of an assignment operator (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.26" class="external text" rel="nofollow">15.26</a>) or as the operand of a prefix or postfix increment or decrement operator (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.14" class="external text" rel="nofollow">15.14</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.15" class="external text" rel="nofollow">15.15</a>).<span class="assertion-id"> [jsr335-4.12.4-10]</span></span>
</p><p><span class="norm-static">
In addition, a local variable whose declaration lacks an initializer is <i>effectively final</i> if all of the following are true:<span class="assertion-id"> [jsr335-4.12.4-20]</span></span>
</p>
<ul><li> <span class="norm-static"> It is not final.<span class="assertion-id"> [jsr335-4.12.4-20-A]</span></span>
</li><li> <span class="norm-static"> Whenever it occurs as the left-hand operand of an assignment operator, it is definitely unassigned and not definitely assigned before the assignment (that is, it is definitely unassigned and not definitely assigned after the right-hand operand of the assignment) (<a href="#B16" title="Lambda B" class="mw-redirect">16</a>).<span class="assertion-id"> [jsr335-4.12.4-20-B]</span></span>
</li><li> <span class="norm-static"> It never occurs as the operand of a prefix or postfix increment or decrement operator.<span class="assertion-id"> [jsr335-4.12.4-20-C]</span></span>
</li></ul>
<p>If a variable is effectively final, adding the <code style="background-color:inherit;font-size:medium">final</code> modifier to its declaration will not introduce any compile-time errors.  Conversely, a local variable or parameter that is declared <code style="background-color:inherit;font-size:medium">final</code> in a valid program becomes effectively final if the <code style="background-color:inherit;font-size:medium">final</code> modifier is removed.
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Examples of <i>effectively final</i>:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
void m1(int x) {
   int y = 1;
   foo(() -&gt; x+y);
   // Legal: x and y are both effectively final.
 }

 void m2(int x) {
   int y;
   y = 1;
   foo(() -&gt; x+y);
   // Legal: x and y are both effectively final.
 }

 void m3(int x) {
   int y;
   if (..) y = 1;
   foo(() -&gt; x+y);
   // Illegal: y is effectively final, but not definitely assigned.
 }

 void m4(int x) {
   int y;
   if (..) y = 1;
   else y = 2;
   foo(() -&gt; x+y);
   // Legal: x and y are both effectively final.
 }

 void m5(int x) {
   int y;
   if (..) y = 1;
   y = 2;
   foo(() -&gt; x+y);
   // Illegal: y is not effectively final.
 }

 void m6(int x) {
   foo(() -&gt; x+1);
   x++;
   // Illegal: x is not effectively final.
 }

 void m7(int x) {
   foo(() -&gt; x=1);
   // Illegal: x is not effectively final.
 }

 void m8() {
   int y;
   foo(() -&gt; y=1);
   // Illegal: y is not definitely assigned before the lambda (see 15.27.2)
 }

void m9(String[] arr) {
  for (String s : arr) {
    foo(() -&gt; s);
    // Legal: s is effectively final (it is a new variable on each iteration)
  }
}

void m10(String[] arr) {
  for (int i = 0; i &lt; arr.length; i++) {
    foo(() -&gt; arr[i]);
    // Illegal: i is not effectively final (it is incremented)
  }
}
</pre></div></blockquote>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> Mitigating the problem of inner classes (now lambda expressions) being unable to capture non-final local variables is one of the stated goals of this project (see <a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-4.html" class="external text" rel="nofollow">"State of the Lambda"</a>).
<p>"Effectively final" is a concept introduced with Java SE 7 for improved exception handling.  (<a href="http://jcip.net/" class="external text" rel="nofollow"><i>Java Concurrency in Practice</i></a> similarly discusses "effectively immutable" variables.)  We've broadened the definition here to include all non-field variables.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> The effectively-final restriction prohibits access to dynamically-changing local variables, as the final restriction did before it; it simply reduces the clerical burden on programmers.  Capture of mutable local variables introduces many concurrency-related problems.
<p>This restriction includes standard loop variables, but not for-each loop variables, which are treated as distinct for each iteration of the loop (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.14.2" class="external text" rel="nofollow">see 14.14.2</a>).  For background reading on how C# arrived at a similar interpretation of loop variables, see <a href="http://blogs.msdn.com/ericlippert/archive/2009/11/12/closing-over-the-loop-variable-considered-harmful.aspx" class="external text" rel="nofollow">Eric Lippert's blog posts</a> on the topic.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> <div id="B4.12.4-.233"></div>
<p>Guaranteeing that <i>effectively final</i> and "legally declarable as <code style="background-color:inherit;font-size:medium">final</code>" are equivalent is tricky.  The goal is that it should be possible to add or remove a <code style="background-color:inherit;font-size:medium">final</code> keyword to any variable that is initially either declared <code style="background-color:inherit;font-size:medium">final</code> or effectively final without impacting the validity of the program.  (As far as variable capture is concerned, anyway; there are other parts of the language that, for various reasons, depend on a variable being explicitly <code style="background-color:inherit;font-size:medium">final</code> and an effectively-final variable cannot act as a substitute.)
</p>
</div></li></ol></div></blockquote>
<div id="B6.3"></div>
<h3> <span class="mw-headline" id="6.3_Scope_of_a_Declaration_.5BModified.5D"> 6.3 Scope of a Declaration [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.3" class="external text" rel="nofollow">JLS 6.3</a></small>
</p><p>...
</p><p><span class="norm-static">
The scope of a formal parameter of a <u>method (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1" class="external text" rel="nofollow">8.4.1</a>), constructor (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8.1" class="external text" rel="nofollow">8.8.1</a>), or lambda expression (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.27" class="external text" rel="nofollow">15.27</a>)</u> is the entire body of the <u>method, constructor, or lambda expression</u>.<span class="assertion-id"> [jls-6.3-340]</span></span>
</p><p>...
</p>
<div id="B6.4"></div>
<h3> <span class="mw-headline" id="6.4_Shadowing_and_Obscuring_.5BModified.5D"> 6.4 Shadowing and Obscuring [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.4" class="external text" rel="nofollow">JLS 6.4</a></small>
</p><p><span class="norm-static">
A local variable (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.4" class="external text" rel="nofollow">14.4</a>), formal parameter (<u><a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1" class="external text" rel="nofollow">8.4.1</a>, <a href="#B15.27.1" title="Lambda B" class="mw-redirect">15.27.1</a></u>), exception parameter (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.20" class="external text" rel="nofollow">14.20</a>), and local class (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.3" class="external text" rel="nofollow">14.3</a>) can only be referred to using a simple name (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.2" class="external text" rel="nofollow">6.2</a>), not a qualified name (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6" class="external text" rel="nofollow">6.6</a>).<span class="assertion-id"> [jls-6.4-100]</span></span>
</p><p>Some declarations are not permitted within the scope of a local variable, formal parameter, exception parameter, or local class declaration because it would be impossible to distinguish between the declared entities using only simple names.
</p><p>For example, if the name of a formal parameter of a method could be redeclared as the name of a local variable in the method body, then the local variable would shadow the formal parameter and the formal parameter would no longer be visible—an undesirable outcome.
</p><p><span class="norm-error">
It is a compile-time error if the name of a formal parameter is <u>used to declare a new variable within the body of the method, constructor, or lambda expression, unless the new variable is declared within a class declaration contained by the method, constructor, or lambda expression.</u><span class="assertion-id"> [jls-6.4-200]</span></span>
</p><p><span class="norm-error">
It is a compile-time error if the name of a local variable <em>v</em> is <u>used to declare a new variable within the scope of <em>v</em>, unless the new variable is declared within a class whose declaration is within the scope of <em>v</em>.</u><span class="assertion-id"> [jls-6.4-210]</span></span>
</p><p><span class="norm-error">
It is a compile-time error if the name of an exception parameter is <u>used to declare a new variable within the <em>Block</em> of the <code style="background-color:inherit;font-size:medium">catch</code> clause, unless the new variable is declared within a class declaration contained by the <em>Block</em> of the <code style="background-color:inherit;font-size:medium">catch</code> clause.</u><span class="assertion-id"> [jls-6.4-230]</span></span>
</p><p><span class="norm-error">
It is a compile-time error if the name of a local class <em>C</em> is <u>used to declare a new local class within the scope of <em>C</em>, unless the new local class is declared within another class whose declaration is within the scope of <em>C</em>.</u><span class="assertion-id"> [jls-6.4-220]</span></span>
</p><p><del><span class="norm-error">
It is a compile-time error if the name of a variable declared in a <em>ResourceSpecification</em> of a <code style="background-color:inherit;font-size:medium">try</code>-with-resources statement (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.20.3" class="external text" rel="nofollow">14.20.3</a>) is redeclared within the <code style="background-color:inherit;font-size:medium">try</code> <em>Block</em> as a local variable of the directly enclosing method, constructor, or initializer block, or as an exception parameter of a <code style="background-color:inherit;font-size:medium">catch</code> clause in a <code style="background-color:inherit;font-size:medium">try</code> statement of the directly enclosing method or initializer block.<span class="assertion-id"> [jls-6.4-240]</span></span></del>
</p><p><del>The translation of a <code style="background-color:inherit;font-size:medium">try</code>-with-resources statement implies the rule above.</del>
</p><p><u>As an exception to the general restriction, these rules</u> allow redeclaration in certain nested class declarations (i.e. local classes (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.3" class="external text" rel="nofollow">14.3</a>) and anonymous classes (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9" class="external text" rel="nofollow">15.9</a>)) <u>that occur within the variable's or local class's scope.</u>
</p><p>[Example] ...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> There are two design alternatives for handling name clashes created by lambda parameters and other variables declared in lambda expressions.
<ul><li> Mimicking class declarations: like local classes, lambda expressions introduce a new "level" for names, and all variable names outside the expression can be redeclared.
</li><li> A "local" strategy: like catch clauses, for loops, and blocks, lambda expressions operate at the same "level" as the enclosing context, and local variables outside the expression cannot be shadowed.
</li></ul>
<p>The above rules use the local strategy: there is no special dispensation that allows a variable declared in a lambda expression to shadow a variable declared in an enclosing method.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> The approach to expressing these rules is somewhat different than JLS 7, because phrases like "local variable of the directly enclosing method" do not very accurately describe local variables declared in a lambda body (possibly within multiple levels of nesting).  The presentation above clearly distinguishes between declarations in nested class declarations (allowed) and declarations in nested lambda expressions (prohibited).
</div></li>
<li style="margin-bottom:12px;"><div> The rule for <em>ResourceSpecification</em> variables was removed for clarity.  Like the variable of an enhanced <code style="background-color:inherit;font-size:medium">for</code> loop, the resource variable is a local variable (i.e., it is not called out as a separate kind of variable in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.12.3" class="external text" rel="nofollow">4.12.3</a>) and is covered by the local variable rule; this interpretation is further reinforced by the fact that the translation of <code style="background-color:inherit;font-size:medium">try</code>-with-resources generates a local variable, as alluded to in the redacted text.
</div></li>
<li style="margin-bottom:12px;"><div> In principle, the revised rule for local classes is not general enough, as it does not make an exception for a class of the same name declared within the local class itself.  However, this case is already prohibited by a separate rule: a class can never have the same name as a class that encloses it (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1" class="external text" rel="nofollow">8.1</a>).
</div></li></ol></div></blockquote>
<div id="B8.1.3"></div>
<h3> <span class="mw-headline" id="8.1.3_Inner_Classes_and_Enclosing_Instances_.5BModified.5D"> 8.1.3 Inner Classes and Enclosing Instances [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.3" class="external text" rel="nofollow">JLS 8.1.3</a></small>
</p><p>...
</p><p><span class="norm-error">
Any local variable, formal parameter, or exception parameter used but not declared in an inner class must be <u>either declared <code style="background-color:inherit;font-size:medium">final</code> or effectively final (<a href="#B4.12.4" title="Lambda B" class="mw-redirect">4.12.4</a>)</u>.<span class="assertion-id"> [jls-8.1.3-510]</span></span>
</p><p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
This extends support for effectively final variable capture to local classes (including anonymous classes) in addition to lambda expressions.</div></blockquote>
<div id="B14.15"></div>
<h3> <span class="mw-headline" id="14.15_The_break_Statement_.5BModified.5D"> 14.15 The <code style="background-color:inherit;font-size:medium">break</code> Statement [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.15" class="external text" rel="nofollow">JLS 14.15</a></small>
</p><p>...
</p><p><span class="norm-error">
A <code style="background-color:inherit;font-size:medium">break</code> statement must refer to a label within the immediately enclosing method, constructor,<u>initializer, or lambda body</u>.  There are no non-local jumps.  If no labeled statement with <em>Identifier</em> as its label in the immediately enclosing method, constructor, <u>initializer, or lambda body</u> contains the <code style="background-color:inherit;font-size:medium">break</code> statement, a compile-time error occurs.<span class="assertion-id"> [jls-14.15-320]</span></span>
</p><p>...
</p>
<div id="B14.16"></div>
<h3> <span class="mw-headline" id="14.16_The_continue_Statement_.5BModified.5D"> 14.16 The <code style="background-color:inherit;font-size:medium">continue</code> Statement [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.16" class="external text" rel="nofollow">JLS 14.16</a></small>
</p><p>...
</p><p><span class="norm-error">
A <code style="background-color:inherit;font-size:medium">continue</code> statement must refer to a label within the immediately enclosing method, constructor,<u>initializer, or lambda body</u>.  There are no non-local jumps.  If no labeled statement with <em>Identifier</em> as its label in the immediately enclosing method, constructor, <u>initializer, or lambda body</u> contains the <code style="background-color:inherit;font-size:medium">continue</code> statement, a compile-time error occurs.<span class="assertion-id"> [jls-14.16-330]</span></span>
</p><p>...
</p>
<div id="B14.17"></div>
<h3> <span class="mw-headline" id="14.17_The_return_Statement_.5BModified.5D"> 14.17 The <code style="background-color:inherit;font-size:medium">return</code> Statement [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.17" class="external text" rel="nofollow">JLS 14.17</a></small>
</p><p><span class="norm-dynamic">
A <code style="background-color:inherit;font-size:medium">return</code> statement returns control to the invoker of a method (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4" class="external text" rel="nofollow">8.4</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">15.12</a>) or constructor (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8" class="external text" rel="nofollow">8.8</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9" class="external text" rel="nofollow">15.9</a>).<span class="assertion-id"> [jls-14.17.100]</span></span>
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
ReturnStatement:
  'return' Expression_opt ';'
</pre>
<p><span class="norm-static">
A <code style="background-color:inherit;font-size:medium">return</code> statement is <i>contained</i> in the innermost constructor, method, <u>initializer, or lambda expression</u> whose body encloses the <code style="background-color:inherit;font-size:medium">return</code> statement.<span class="assertion-id"> [jls-14.17-120]</span></span>
</p><p><span class="norm-error">
It is a compile-time error if a <code style="background-color:inherit;font-size:medium">return</code> statement is contained in an instance initializer or a static initializer (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.6" class="external text" rel="nofollow">8.6</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.7" class="external text" rel="nofollow">8.7</a>).<span class="assertion-id"> [jls-14.17.200]</span></span>
</p><p><span class="norm-error">
A <code style="background-color:inherit;font-size:medium">return</code> statement with no <i>Expression</i> must be contained in <u>one of the following, or a compile-time error occurs:</u><span class="assertion-id"> [jls-14.17-300]</span></span>
</p>
<ul><li> <span class="norm-error"> A method <u>(<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4" class="external text" rel="nofollow">8.4</a>)</u> that is declared, using the keyword <code style="background-color:inherit;font-size:medium">void</code>, not to return any value<span class="assertion-id"> [jls-14.17-300-A]</span></span>
</li><li> <span class="norm-error"> A constructor (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8" class="external text" rel="nofollow">8.8</a>)<span class="assertion-id"> [jls-14.17-300-B]</span></span>
</li><li> <span class="norm-error"> <u>A lambda expression (<a href="#B15.27" title="Lambda B" class="mw-redirect">15.27</a>)</u><span class="assertion-id"> [jls-14.17-300-C]</span></span>
</li></ul>
<p><span class="norm-dynamic">
A <code style="background-color:inherit;font-size:medium">return</code> statement with no <i>Expression</i> attempts to transfer control to the invoker of the <u>method, constructor, or lambda body</u> that contains it.  To be precise, a <code style="background-color:inherit;font-size:medium">return</code> statement with no <i>Expression</i> always completes abruptly, the reason being a return with no value.<span class="assertion-id"> [jls-14.17-310]</span></span>
</p><p><span class="norm-error">
A <code style="background-color:inherit;font-size:medium">return</code> statement with an <i>Expression</i> must be contained in <u>one of the following, or a compile-time error occurs:</u><span class="assertion-id"> [jls-14.17-400]</span></span>
</p>
<ul><li> <span class="norm-error"> A <u>method</u> that is declared to return a value<span class="assertion-id"> [jls-14.17-400-A]</span></span>
</li><li> <span class="norm-error"> <u>A lambda expression</u><span class="assertion-id"> [jls-14.17-400-B]</span></span>
</li></ul>
<p><span class="norm-error">
The <i>Expression</i> must denote a variable or a value <del>of some type <em>T</em></del>, or a compile-time error occurs.<span class="assertion-id"> [jls-14.17-410]</span></span>
</p><p><span class="norm-error">
<u>When a <code style="background-color:inherit;font-size:medium">return</code> statement with an <i>Expression</i> appears in a method declaration, the <i>Expression</i></u> must be assignable (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.2.4" class="external text" rel="nofollow">5.2.4</a>) to the declared result type of the method, or a compile-time error occurs.<span class="assertion-id"> [jls-14.17-420]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The equivalent assignable check for return statements in lambda expressions is covered in Part E (<a href="#E15.27.3" title="Lambda E" class="mw-redirect">15.27.3</a>).</div></blockquote>
<p><span class="norm-dynamic">
A <code style="background-color:inherit;font-size:medium">return</code> statement with an <i>Expression</i> attempts to transfer control to the invoker of the method <u>or lambda body</u> that contains it; the value of the <i>Expression</i> becomes the value of the method invocation.  More precisely, ...<span class="assertion-id"> [jls-14.17-430]</span></span>
</p><p>...
</p>
<div id="B14.18"></div>
<h3> <span class="mw-headline" id="14.18_The_throw_Statement_.5BModified.5D"> 14.18 The <code style="background-color:inherit;font-size:medium">throw</code> Statement [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.18" class="external text" rel="nofollow">JLS 14.18</a></small>
</p><p>...
</p><p><span class="norm-dynamic">
If a <code style="background-color:inherit;font-size:medium">throw</code> statement is contained in a method declaration <u>or a lambda expression</u>, but its value is not caught by some <code style="background-color:inherit;font-size:medium">try</code> statement that contains it, then the invocation of the method completes abruptly because of the <code style="background-color:inherit;font-size:medium">throw</code>.<span class="assertion-id"> [jls-14.18-510]</span></span>
</p><p>...
</p>
<div id="B14.20"></div>
<h3> <span class="mw-headline" id="14.20_The_try_Statement_.5BModified.5D"> 14.20 The <code style="background-color:inherit;font-size:medium">try</code> Statement [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.20" class="external text" rel="nofollow">JLS 14.20</a></small>
</p><p>...
</p><p><del><span class="norm-static"> In a uni-<code style="background-color:inherit;font-size:medium">catch</code> clause, an exception parameter that is not declared <code style="background-color:inherit;font-size:medium">final</code> (implicitly or explicitly) is considered <i>effectively final</i> if it never occurs within its scope as the left-hand operand of an assignment operator (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.26" class="external text" rel="nofollow">15.26</a>).<span class="assertion-id"> [jls-14.20-620]</span></span></del>
</p><p>An implicitly final exception parameter is <code style="background-color:inherit;font-size:medium">final</code> by virtue of its declaration, while an effectively final exception parameter is (as it were) <code style="background-color:inherit;font-size:medium">final</code> by virtue of how it is used.  An exception parameter of a multi-<code style="background-color:inherit;font-size:medium">catch</code> clause is implicitly final, so will never occur as the left-hand operand of an assignment operator, but is <i>not</i> considered effectively final.
</p><p><del>If an exception parameter is effectively final (in a uni-<code style="background-color:inherit;font-size:medium">catch</code> clause) or implicitly final (in a multi-<code style="background-color:inherit;font-size:medium">catch</code> clause), then adding an explicit <code style="background-color:inherit;font-size:medium">final</code> modifier to its declaration will not introduce any compile-time errors.  However, if the exception parameter <i>of a uni-<code style="background-color:inherit;font-size:medium">catch</code> clause</i> is explicitly declared <code style="background-color:inherit;font-size:medium">final</code>, then removing the <code style="background-color:inherit;font-size:medium">final</code> modifier may introduce compile-time errors.  This is because the exception parameter, while still effectively final, can no longer be referenced by, for example, local classes.  On the other hand, if there are no compile-time errors, it is possible to further change the program so that the exception parameter is re-assigned and no longer effectively final.</del>
</p><p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
The definition and discussion about <i>effectively final</i> is superseded by <a href="#B4.12.4" title="Lambda B" class="mw-redirect">4.12.4</a>, above.  The note about how the implicit finality of a multi-<code style="background-color:inherit;font-size:medium">catch</code> clause is different than effective finality is still useful, though.</div></blockquote>
<div id="B15.8.3"></div>
<h3> <span class="mw-headline" id="15.8.3_this_.5BModified.5D"> 15.8.3 <code style="background-color:inherit;font-size:medium">this</code> [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.8.3" class="external text" rel="nofollow">JLS 15.8.3</a></small>
</p><p><span class="norm-error">
The keyword <code style="background-color:inherit;font-size:medium">this</code> may be used only in the body of an instance method, instance initializer, or constructor, or in the initializer of an instance variable of a class.  If it appears anywhere else, a compile-time error occurs.<span class="assertion-id"> [jls-15.8.3-100]</span></span>
</p><p><span class="norm-dynamic">
When used as a primary expression, the keyword <code style="background-color:inherit;font-size:medium">this</code> denotes a value that is a reference to the object for which the instance method was invoked (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">15.12</a>), or to the object being constructed.<span class="assertion-id"> [jls-15.8.3-200]</span></span>
</p><p><u>Note that a lambda expression (<a href="#B15.27" title="Lambda B" class="mw-redirect">15.27</a>) is <i>not</i> a method declaration.  The keyword <code style="background-color:inherit;font-size:medium">this</code> is only allowed in a lambda expression if it is allowed in the context in which the lambda expression appears; the object denoted by <code style="background-color:inherit;font-size:medium">this</code> appearing in a lambda body is the same as the object denoted by <code style="background-color:inherit;font-size:medium">this</code> in the surrounding context.</u>
</p><p>...
</p>
<div id="B16"></div>
<h3> <span class="mw-headline" id="16_Definite_Assignment_.5BModified.5D"> 16 Definite Assignment [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-16.html#jls-16" class="external text" rel="nofollow">JLS 16</a></small>
</p><p>...
</p><p>Throughout the rest of this chapter, we will, unless explicitly stated otherwise, write <em>V</em> to represent an <u>in-scope (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.3" class="external text" rel="nofollow">6.3</a>)</u> local variable or <del>a</del> blank <code style="background-color:inherit;font-size:medium">final</code> field <del>(for rules of definite assignment) or a blank final variable (for rules of definite unassignment)</del>.
</p><p>...
</p>


<a id="top"></a>
	
	<a id="C"/><h1 id="firstHeading" class="firstHeading">Lambda Specification, Part C: Method References</h1>
									<p><small>
Navigation: <a href="#overview" title="Lambda Specification" class="mw-redirect">Overview</a>&nbsp;- <a href="#A" title="Lambda A" class="mw-redirect">Part A</a>&nbsp;- <a href="#B" title="Lambda B" class="mw-redirect">Part B</a>&nbsp;- <a href="#C" title="Lambda C" class="mw-redirect">Part C</a>&nbsp;- <a href="#D" title="Lambda D" class="mw-redirect">Part D</a>&nbsp;- <a href="#E" title="Lambda E" class="mw-redirect">Part E</a>&nbsp;- <a href="#F" title="Lambda F" class="mw-redirect">Part F</a>&nbsp;- <a href="#G" title="Lambda G" class="mw-redirect">Part G</a>&nbsp;- <a href="#H" title="Lambda H" class="mw-redirect">Part H</a>&nbsp;- <a href="#J" title="Lambda J" class="mw-redirect">Part J</a>
<br />
Sections: <a href="#C15.13">15.13</a>&nbsp;- <a href="#C3.11">3.11</a>
<br />
Version 0.9.3.  Copyright © 2014 Oracle America, Inc.  <a href="#Legal_Notice" title="Lambda Specification" class="mw-redirect">Legal Notice</a>.
</small>
</p>
<h3> <span class="mw-headline" id="Summary"> Summary </span></h3>
<p>A method reference is used to refer to the invocation of a method without actually performing the invocation.  Certain forms of method references also allow class instance creation or array creation to be treated as if it were a method invocation.
</p><p>Examples of method references:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
System::getProperty
&quot;abc&quot;::length
System.out::println
String::length
super::toString
ArrayList::new
int[]::new
</pre>
<p>The target reference (i.e., the "receiver") of an instance method may be provided by the method reference expression or it may be provided later when the method is invoked.  The immediately enclosing instance of a new inner class instance must be provided by a lexically enclosing instance of <code style="background-color:inherit;font-size:medium">this</code>.
</p><p>When more than one member method of a type has the same name, or when a class has more than one constructor, the appropriate method or constructor is selected based on the functional interface type targeted by the expression.
</p>
<div id="C15.13"></div>
<h3> <span class="mw-headline" id="15.13_Method_Reference_Expressions_.5BNew.5D"> 15.13 Method Reference Expressions [New] </span></h3>
<p>A method reference is used to refer to the invocation of a method without actually performing the invocation.  Certain forms of method references also allow class instance creation (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9" class="external text" rel="nofollow">15.9</a>) or array creation (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.10" class="external text" rel="nofollow">15.10</a>) to be treated as if it were a method invocation.
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
MethodReference:
 ExpressionName '::' NonWildTypeArguments<sub>opt</sub> Identifier
 Primary '::' NonWildTypeArguments<sub>opt</sub> Identifier
 'super' '::' NonWildTypeArguments<sub>opt</sub> Identifier
 TypeName '.' 'super' '::' NonWildTypeArguments<sub>opt</sub> Identifier
 ReferenceType '::' NonWildTypeArguments<sub>opt</sub> Identifier
 ClassType '::' NonWildTypeArguments<sub>opt</sub> 'new'
 ArrayType '::' 'new'
</pre>
<p>The following productions from <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8.7.1" class="external text" rel="nofollow">8.8.7.1</a> are repeated here for convenience:
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
NonWildTypeArguments:
 '&lt;' ReferenceTypeList '&gt;'

ReferenceTypeList:
 ReferenceType
 ReferenceTypeList ',' ReferenceType
</pre>
<p><span class="norm-error">
It is a compile-time error if a method reference has the form <em>ExpressionName <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em> or <em>Primary <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, and the type of the <em>ExpressionName</em> or <em>Primary</em> is not a reference type.<span class="assertion-id"> [jsr335-15.28-5]</span></span>
</p><p><span class="norm-error">
If a method reference has the form <em><code style="background-color:inherit;font-size:medium">super</code> <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, let <em>T</em> be the type declaration immediately enclosing the method reference. It is a compile-time error if <em>T</em> is the class <code style="background-color:inherit;font-size:medium">Object</code> or <em>T</em> is an interface.<span class="assertion-id"> [jsr335-15.28-21]</span></span>
</p><p><span class="norm-error">
If a method reference has the form <em>TypeName <code style="background-color:inherit;font-size:medium">.</code> <code style="background-color:inherit;font-size:medium">super</code> <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, then:<span class="assertion-id"> [jsr335-15.28-22]</span></span>
</p>
<ul><li> <span class="norm-error"> If <em>TypeName</em> denotes a class, <em>C</em>, it is a compile-time error if <em>C</em> is not a lexically enclosing class of the current class, or if <em>C</em> is the class <code style="background-color:inherit;font-size:medium">Object</code>.<span class="assertion-id"> [jsr335-15.28-22-A]</span></span>
</li><li> <span class="norm-error"> If <em>TypeName</em> denotes an interface, <em>I</em>, let <em>T</em> be the type declaration immediately enclosing the method reference.  It is a compile-time error if <em>I</em> is not a direct superinterface of <em>T</em>, or if there exists some other direct superclass or direct superinterface of <em>T</em>, <em>J</em>, such that <em>J</em> is a subtype of <em>I</em>.<span class="assertion-id"> [jsr335-15.28-22-B]</span></span>
</li><li> <span class="norm-error"> If <em>TypeName</em> denotes neither a class nor an interface, a compile-time error occurs.<span class="assertion-id"> [jsr335-15.28-22-C]</span></span>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The above restrictions mimic <a href="#H15.12.1" title="Lambda H" class="mw-redirect">15.12.1</a> (as modified by this specification).  (We could avoid stating them here, because <a href="#E15.13.1" title="Lambda E" class="mw-redirect">15.13.1</a> is defined in terms of <a href="#H15.12.1" title="Lambda H" class="mw-redirect">15.12.1</a>, but it's more straightforward to be explicit about it.)</div></blockquote>
<p><span class="norm-error">
It is a compile-time error if a method reference of the form <em><code style="background-color:inherit;font-size:medium">super</code> <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em> or of the form <em>TypeName <code style="background-color:inherit;font-size:medium">.</code> <code style="background-color:inherit;font-size:medium">super</code> <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em> occurs in a static context.<span class="assertion-id"> [jsr335-15.28-20]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The above restriction mimics <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.3" class="external text" rel="nofollow">15.12.3</a>.</div></blockquote>
<p><span class="norm-error">
If a method reference has the form <em>ClassType <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> <code style="background-color:inherit;font-size:medium">new</code></em>, the <em>ClassType</em> must denote a class that is accessible (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6" class="external text" rel="nofollow">6.6</a>) and is not an enum type and not <code style="background-color:inherit;font-size:medium">abstract</code>, or a compile-time error occurs.<span class="assertion-id"> [jsr335-15.28-10]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The above restriction mimics <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.1" class="external text" rel="nofollow">15.9.1</a>.</div></blockquote>
<p><span class="norm-error">
In addition, if a method reference has the form <em>ClassType <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> <code style="background-color:inherit;font-size:medium">new</code></em>, it is a compile-time error if any of the type arguments used in the <em>ClassType</em> are wildcard type arguments (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.5.1" class="external text" rel="nofollow">4.5.1</a>).<span class="assertion-id"> [jsr335-15.28-11]</span></span>
</p><p><span class="norm-error">
It is a compile-time error If a method reference has the form <em>ClassType <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments <code style="background-color:inherit;font-size:medium">new</code></em>, where a constructor type argument list is provided, but the <em>ClassType</em> is a raw type.<span class="assertion-id"> [jsr335-15.28-12]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The above restrictions mimic <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9" class="external text" rel="nofollow">15.9</a>.</div></blockquote>
<p><span class="norm-error">
If a method reference has the form <em>ArrayType <code style="background-color:inherit;font-size:medium">::</code> <code style="background-color:inherit;font-size:medium">new</code></em>, the <em>ArrayType</em> must denote a type that is reifiable (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.7" class="external text" rel="nofollow">4.7</a>), or a compile-time error occurs.<span class="assertion-id"> [jsr335-15.28.15]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The above restriction mimics <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.10" class="external text" rel="nofollow">15.10</a>.</div></blockquote>
<p>The target reference of an instance method (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4.1" class="external text" rel="nofollow">15.12.4.1</a>) may be provided by the method reference expression—using an <em>ExpressionName</em>, a <em>Primary</em>, or <code style="background-color:inherit;font-size:medium">super</code>—or it may be provided later when the method is invoked.  The immediately enclosing instance of a new inner class instance (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.2" class="external text" rel="nofollow">15.9.2</a>) must be provided by a lexically enclosing instance of <code style="background-color:inherit;font-size:medium">this</code> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.3" class="external text" rel="nofollow">8.1.3</a>).
</p><p>When more than one member method of a type has the same name, or when a class has more than one constructor, the appropriate method or constructor is selected based on the functional interface type targeted by the expression, as described in <a href="#E15.13.1" title="Lambda E" class="mw-redirect">15.13.1</a>.
</p><p>If a method or constructor is generic, the appropriate type arguments may either be inferred or provided explicitly.  Similarly, the type arguments of a generic type mentioned by the method reference may be provided explicitly or inferred.
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Examples of method reference expressions:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
System::getProperty
String::length
List&lt;String&gt;::size   // explicit class type args
List::size           // inferred class type args
int[]::clone
T::tvarMember

&quot;abc&quot;::length
System.out::println
foo[x]::bar
(test ? stream.map(String::trim) : stream)::toArray
super::toString

String::valueOf      // overload resolution needed     
Arrays::sort         // type args inferred from context
Arrays::&lt;String&gt;sort // explicit type args

ArrayList&lt;String&gt;::new    // constructor for parameterized type
ArrayList::new            // inferred class type args
Foo::&lt;Integer&gt;new         // explicit generic constructor type arguments
Bar&lt;String&gt;::&lt;Integer&gt;new // generic class, generic constructor
Outer.Inner::new          // inner class constructor
int[]::new                // array creation
</pre></div></blockquote>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> The term "method reference" is imprecise, but captures the typical usage of the feature.  In full generality, method references are shorthand to describe certain expressions that should not be evaluated until a future point.  Hence, the same method can be referenced via a standard invocation or a <code style="background-color:inherit;font-size:medium">super</code> invocation—properties of the implicit invocation expression, not the method itself.  Similarly, class instance creation and array creation can be referenced, even though there is no actual corresponding method that returns a class instance or an array.
</div></li>
<li style="margin-bottom:12px;"><div> There is no support for specifying a particular signature to be matched:
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">Arrays::sort(int[])</pre>
<p>Instead, the functional interface provides argument types that are used as input to the overload resolution algorithm (<a href="#F15.12.2" title="Lambda F" class="mw-redirect">15.12.2</a>).  This should satisfy the vast majority of use cases; when the rare need arises for more precise control, a lambda expression can be used.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> The method reference delimiter is infix; this seems useful because it clearly separates the "evaluated now" portion of the expression from the "evaluated on invocation" part.  It also conveys the useful model that a method reference is sort of like a new kind of member of an object or class.
<p>Other languages simply use a method name as a method reference—the delimiter would be '<code style="background-color:inherit;font-size:medium">.</code>'.  But this introduces ambiguities with field names, so it is useful to have a unique delimiter to differentiate.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> The use of type argument syntax in the class name before a delimiter (<code style="background-color:inherit;font-size:medium">List&lt;String&gt;::size</code>) raises the parsing problem of distinguishing between '<code style="background-color:inherit;font-size:medium">&lt;</code>' as a type argument bracket and '<code style="background-color:inherit;font-size:medium">&lt;</code>' as a less-than operator; this problem does not arise in a static method invocation.  In theory, this is no worse than allowing type arguments in cast expressions; however, the difference is that the cast case only comes up when a '<code style="background-color:inherit;font-size:medium">(</code>' token is encountered; with the addition of method references, the start of <i>every</i> expression is potentially a parameterized type.
</div></li>
<li style="margin-bottom:12px;"><div> Section <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.13" class="external text" rel="nofollow">15.13</a> currently addresses array access expressions.  To make room for method reference expressions, this section has been merged with <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.10" class="external text" rel="nofollow">15.10</a>.
</div></li></ol></div></blockquote>
<div id="C3.11"></div>
<h3> <span class="mw-headline" id="3.11_Separators_.5BModified.5D"> 3.11 Separators [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.11" class="external text" rel="nofollow">JLS 3.11</a></small>
</p><p><span class="norm-static">
<del>Nine</del> <u>Ten tokens, formed from</u> ASCII characters<u>,</u> are the <i>separators</i> (punctuators).<span class="assertion-id"> [jls-3.11-100]</span></span>
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
Separator: one of
  ...
  ','
  '.'
  <u>'::'</u>
</pre>



<a id="top"></a>
	
	<a id="D"/><h1 id="firstHeading" class="firstHeading">Lambda Specification, Part D: Poly Expressions</h1>
									<p><small>
Navigation: <a href="#overview" title="Lambda Specification" class="mw-redirect">Overview</a>&nbsp;- <a href="#A" title="Lambda A" class="mw-redirect">Part A</a>&nbsp;- <a href="#B" title="Lambda B" class="mw-redirect">Part B</a>&nbsp;- <a href="#C" title="Lambda C" class="mw-redirect">Part C</a>&nbsp;- <a href="#D" title="Lambda D" class="mw-redirect">Part D</a>&nbsp;- <a href="#E" title="Lambda E" class="mw-redirect">Part E</a>&nbsp;- <a href="#F" title="Lambda F" class="mw-redirect">Part F</a>&nbsp;- <a href="#G" title="Lambda G" class="mw-redirect">Part G</a>&nbsp;- <a href="#H" title="Lambda H" class="mw-redirect">Part H</a>&nbsp;- <a href="#J" title="Lambda J" class="mw-redirect">Part J</a>
<br />
Sections: <a href="#D5">5</a>&nbsp;- <a href="#D5.2">5.2</a>&nbsp;- <a href="#D5.3">5.3</a>&nbsp;- <a href="#D5.4">5.4</a>&nbsp;- <a href="#D5.5">5.5</a>&nbsp;- <a href="#D5.5.1">5.5.1</a>&nbsp;- <a href="#D5.5.2">5.5.2</a>&nbsp;- <a href="#D5.6">5.6</a>&nbsp;- <a href="#D15.1">15.1</a>&nbsp;- <a href="#D15.2">15.2</a>&nbsp;- <a href="#D15.3">15.3</a>&nbsp;- <a href="#D15.8">15.8</a>&nbsp;- <a href="#D15.8.5">15.8.5</a>&nbsp;- <a href="#D15.9">15.9</a>&nbsp;- <a href="#D15.12">15.12</a>&nbsp;- <a href="#D15.16">15.16</a>&nbsp;- <a href="#D15.25">15.25</a>&nbsp;- <a href="#D15.25.1">15.25.1</a>&nbsp;- <a href="#D15.25.2">15.25.2</a>&nbsp;- <a href="#D15.25.3">15.25.3</a>&nbsp;- <a href="#D15.26">15.26</a>
<br />
Version 0.9.3.  Copyright © 2014 Oracle America, Inc.  <a href="#Legal_Notice" title="Lambda Specification" class="mw-redirect">Legal Notice</a>.
</small>
</p>
<h3> <span class="mw-headline" id="Summary"> Summary </span></h3>
<p>Every expression written in the Java programming language either produces no result (<code style="background-color:inherit;font-size:medium">void</code>) or has a type that can be deduced at compile time.  When an expression appears in most contexts, it must be <i>compatible</i> with a type expected in that context; this type is called the <i>target type</i>.  For convenience, compatibility of an expression with its surrounding context is facilitated by the language in two ways:
</p>
<ul><li> First, for some expressions, termed <i>poly expressions</i>, the deduced type can be influenced by the target type.  The same expression can have different types in different contexts.
</li><li> Second, after the type of the expression has been deduced, an implicit <i>conversion</i> from the type of the expression to the target type can sometimes be performed.
</li></ul>
<p>If neither strategy is able to produce the appropriate type, an error occurs at compile time.
</p><p>Given certain meanings of names, the type of a <i>standalone expression</i> (an expression that is not a poly expression) can be determined entirely from the contents of the expression.  In contrast, the type of a poly expression may be influenced by the expression's target type.
</p><p>The following forms of expressions may be poly expressions:
</p>
<ul><li> Parenthesized expressions
</li><li> Class instance creation expressions
</li><li> Method invocation expressions
</li><li> Conditional operator expressions
</li><li> Lambda expressions
</li><li> Method references
</li></ul>
<p>To determine whether an expression of one of these forms is a poly expression, we may consider the kind of context in which the expression appears and the content of the expression.
</p><p>Generic method invocation expressions, along with class instance creation expressions that use a diamond <code style="background-color:inherit;font-size:medium">&lt;&gt;</code>, may be poly expressions when they appear in assignment or invocation contexts.  This allows type argument inference to depend on context.
</p><p>Lambda expressions and method references are always poly expressions; their typing rules are covered by <a href="#E" title="Lambda E" class="mw-redirect">Part E</a>.
</p><p>Conditional operator expressions may be poly expressions if they appear in assignment or invocation contexts, unless both operands produce primitives (or boxed primitives).  When they are poly expressions, the target type is "pushed down" to each operand.
</p><p>Similarly, parenthesized expressions that wrap poly subexpressions are poly expressions, passing the target type on to the subexpression.
</p><p>Casts can be used to explicitly "tag" a lambda expression or a method reference with a particular target type.  To provide an appropriate degree of flexibility, the target type may be a list of types denoting an intersection type (as long as the intersection is also a functional interface type, typically meaning one element is a functional interface and the others are marker interfaces).  Since the feature is generally useful, we also support casts of arbitrary expressions to intersection types.
</p>
<div id="D5"></div>
<h3> <span class="mw-headline" id="5_Conversions_and_Contexts_.5BModified.5D"> 5 Conversions and <u>Contexts</u> [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5" class="external text" rel="nofollow">JLS 5</a></small>
</p><p>Every expression written in the Java programming language <u>either produces no result (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.1" class="external text" rel="nofollow">15.1</a>) or</u> has a type that can be deduced <u>at compile time (<a href="#D15.3" title="Lambda D" class="mw-redirect">15.3</a>)</u>.  <u>When an expression appears in most contexts, it must be <i>compatible</i> with a type expected in that context; this type is called the <i>target type</i>.  For convenience, compatibility of an expression with its surrounding context is facilitated by the language in two ways:</u>
</p>
<ul><li> <u>First, for some expressions, termed <i>poly expressions</i> (<a href="#D15.2" title="Lambda D" class="mw-redirect">15.2</a>), the deduced type can be influenced by the target type.  The same expression can have different types in different contexts.</u>
</li><li> <u>Second, after the type of the expression has been deduced</u>, an implicit <i>conversion</i> from the type of the expression to <u>the target type can sometimes be performed</u>.
</li></ul>
<p><u>If neither strategy is able to produce the appropriate type</u>, an error <u>occurs</u> at compile time.
</p><p><u>The rules determining whether an expression is a poly expression, and if so, its type and compatibility in a particular context, vary depending on the kind of context and the form of the expression.  These rules are defined in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15" class="external text" rel="nofollow">Chapter 15</a>, "Expressions."  In addition to influencing the type of the expression, the target type may in some cases influence the run time behavior of the expression in order to produce a value of the appropriate type.</u>
</p><p><u>Similarly, the rules determining when a target type allows an implicit conversion vary depending on the kind of context, the type of the expression, and, in one special case, the value of a <i>constant expression</i> (<a href="#D15.29" title="Lambda D" class="mw-redirect">15.29</a>).</u>  A specific conversion from type <em>S</em> to type <em>T</em> allows an expression of type <em>S</em> to be treated at compile time as if it had type <em>T</em> instead.  In some cases this will require a corresponding action at <u>run time</u> to check the validity of the conversion or to translate the run-time value of the expression into a form appropriate for the new type <em>T</em>.
</p><p>[Example, list of conversion categories] ...
</p><p>There are <u>six kinds of</u> <i>conversion contexts</i> in which <u>poly expressions may be influenced by context or implicit conversions may occur.</u>  Each kind of context <u>has different rules for poly expression typing and</u> allows conversions in some of the categories above but not others.  <u>These contexts are:</u>
</p>
<ul><li> Assignment <u>contexts (<a href="#D5.2" title="Lambda D" class="mw-redirect">5.2</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.26" class="external text" rel="nofollow">15.26</a>), in which an expression's value is bound to a named variable.  Primitives and references are subject to widening, values may be boxed or unboxed, and some primitive constants may be subject to narrowing.  An unchecked conversion may also occur.</u>
</li><li> <u>Strict invocation contexts (<a href="#D5.3" title="Lambda D" class="mw-redirect">5.3</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9" class="external text" rel="nofollow">15.9</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">15.12</a>), in which an argument is bound to a formal parameter of a constructor or method.  Widening primitive, widening reference, and unchecked conversions may occur.</u>
</li><li> <u>Loose invocation contexts (<a href="#D5.3" title="Lambda D" class="mw-redirect">5.3</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9" class="external text" rel="nofollow">15.9</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">15.12</a>), in which, like strict invocation contexts, an argument is bound to a formal parameter.  Method or constructor invocations may provide this context if no applicable declaration can be found using only strict invocation contexts.  In addition to widening and unchecked conversions, this context allows boxing and unboxing to occur.</u>
</li><li> String <u>contexts (<a href="#D5.4" title="Lambda D" class="mw-redirect">5.4</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.18.1" class="external text" rel="nofollow">15.18.1</a>), in which a value of any type is converted to an object of</u> type <code style="background-color:inherit;font-size:medium">String</code>.
</li><li> Casting <u>contexts (<a href="#D5.5" title="Lambda D" class="mw-redirect">5.5</a>), in which an expression's value is converted</u> to a type explicitly specified by a cast operator (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.16" class="external text" rel="nofollow">15.16</a>).  <u>Casting contexts</u> are more inclusive than assignment or <u>loose invocation contexts</u>, allowing any specific conversion other than a string conversion, but certain casts to a reference type <u>are checked for correctness</u> at run time.
</li><li> Numeric <u>contexts (<a href="#D5.6" title="Lambda D" class="mw-redirect">5.6</a>), in which</u> the operands of a numeric operator <u>may be widened</u> to a common type so that an operation can be performed.
</li></ul>
<p>The term "conversion" is also used to describe, <u>without being specific, any conversions allowed in a particular context.</u>  For example, we say that an expression that is <u>the initializer of a local variable</u> is subject to "<u>assignment</u> conversion," meaning that a specific conversion will be implicitly chosen for that expression according to the rules for the <u>assignment context</u>.
</p><p>Here are some examples of <u>conversions occuring in</u> various contexts.
</p><p>[Example] ...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> Lambda expressions and method references may only appear in certain contexts, and their type and correctness are determined by this context.  Other kinds of expressions in the existing language have already introduced dependencies on context, and this is a trend that seems likely to continue.  Rather than treat each new feature in an ad-hoc manner, the introduction of <i>poly expression</i> and an explicit recognition that target types can influence expression types allows us to unify handling of context-dependent expressions under a single umbrella.
<p>Requiring an expression to denote the same thing in all contexts is useful, but limiting.  In the past, the approach to the class of expressions that don't behave in this way has generally been to ignore them, as in statements like the following from the JLS 7 <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5" class="external text" rel="nofollow">Chapter 5</a> introduction:
</p><p>"Every expression written in the Java programming language has a type that can be deduced from the structure of the expression and the types of the literals, variables, and methods mentioned in the expression."
</p>
</div></li>
<li style="margin-bottom:12px;"><div> Deciding what contexts are allowed to support poly expressions is driven in large part by the practical need for such features:
<ul><li> Assignment contexts (including return statements, etc.) are supported, because the target type is easy to determine.  In Java SE 7, this is the <i>only</i> context in which something like a poly expression got special treatment.
</li><li> Invocation contexts are supported, because lambda expressions are a lot less useful if they can't be method arguments.  This implies that overload resolution needs to be overhauled (see <a href="#F" title="Lambda F" class="mw-redirect">Part F</a>)—the targeted method must be determined <i>before</i> knowing the type of each method argument.  It would also be quite useful to allow nested polymorphic method invocations to be affected by the outer targeted method's signature.
</li><li> Casting contexts are supported, because we want programmers to be able to use them to explicitly provide a lambda expression's target type.  This is particularly useful when a class has overloaded methods with functional interface argument types that are similar but unrelated (<code style="background-color:inherit;font-size:medium">FileFilter</code> and <code style="background-color:inherit;font-size:medium">Predicate&lt;File&gt;</code>, say); it is also useful when a targeted type is not a functional interface, but it has a functional subinterface.  However, generic method invocations are not poly expressions in casting contexts: the cast provides little useful information about the method's return type.
</li><li> Numeric and boolean contexts (loop conditions, assert operands, binary expression operands) do <i>not</i> support poly expressions, because a lambda expression cannot target a primitive type, and working out proper inference for method invocations here would be quite complex without much payoff.
</li><li> String contexts (such as <code style="background-color:inherit;font-size:medium">"a" + exp</code>) do not provide any useful information, because every value can be converted to a String.
</li><li> The receiver in a method invocation, field access, etc. (<code style="background-color:inherit;font-size:medium">exp.foo()</code>) is <i>not</i> a poly expression because the target type is unknown—it would be impossible to enumerate every type that has a particular member (<code style="background-color:inherit;font-size:medium">foo</code>, in this case).  There has been some interest in allowing inference to "chain": in <code style="background-color:inherit;font-size:medium">a().b()</code>, passing type information from the invocation of <code style="background-color:inherit;font-size:medium">b</code> to the invocation of <code style="background-color:inherit;font-size:medium">a</code>.  This adds another dimension to the complexity of the inference algorithm, as partial information has to pass in both directions; it only works when the erasure of the return type of <code style="background-color:inherit;font-size:medium">a()</code> is fixed for all instantiations (e.g. <code style="background-color:inherit;font-size:medium">List&lt;T&gt;</code>).  This feature would not fit very well into the poly expression model, since the target type cannot be easily derived; but perhaps with additional enhancements it could be added in the future.
</li><li> The expression in an enhanced for loop is <i>not</i> in a poly context because, as the construct is currently defined, it is as if the expression were a receiver: <code style="background-color:inherit;font-size:medium">exp.iterator()</code> (or, in the array case, <code style="background-color:inherit;font-size:medium">exp[i]</code>).  It is plausible that an Iterator could be wrapped as an Iterable in a <code style="background-color:inherit;font-size:medium">for</code> loop via a lambda expression (<code style="background-color:inherit;font-size:medium">for (String s&nbsp;: () -&gt; stringIterator)</code>), but this doesn't mesh very well with the semantics of Iterable.
</li></ul>
</div></li>
<li style="margin-bottom:12px;"><div> A point of emphasis in this revision is to identify conversion contexts mainly as <i>contexts</i> rather than <i>conversions</i>, in order to generalize the way in which they are used <i>both</i> for typing of poly expressions and for generating implicit conversions.  ("Assignment conversion context" was existing terminology, but "assignment conversion" was almost always used as shorthand.)  <p>The "promotion" terminology (meaning the inference of certain conversions that happen in numeric contexts) seems relatively minor, so "Conversions and Contexts" is used as a revised chapter title.  "Conversions, Promotions, and Contexts" might also work.</p>
</div></li>
<li style="margin-bottom:12px;"><div> Many of the adjustments made to this section (for example, the distinction between strict and loose invocation contexts) are principally to provide a consistent framework for talking about type inference, covered in <a href="#G" title="Lambda G" class="mw-redirect">Part G</a>.
</div></li>
<li style="margin-bottom:12px;"><div> The old text outlined some (but not all) of the exceptions that could occur in particular contexts.  This seemed unnecessarily detailed for a chapter introduction, so has been dropped.  Similarly, the old text had a paragraph about numeric promotion that was unnecessarily detailed and no longer accurate.
</div></li></ol></div></blockquote>
<div id="D5.2"></div>
<h3> <span class="mw-headline" id="5.2_Assignment_Contexts_.5BModified.5D"> 5.2 Assignment <u>Contexts</u> [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.2" class="external text" rel="nofollow">JLS 5.2</a></small>
</p><p><span class="norm-static">
<u><i>Assignment contexts</i> allow</u> the value of an expression <u>to be</u> assigned (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.26" class="external text" rel="nofollow">15.26</a>) to a variable: the type of the expression must be converted to the type of the variable.<span class="assertion-id"> [jls-5.2-100]</span></span>
</p><p>...
</p><p><u>If an expression is assignment-compatible with the type of a variable, we sometimes</u> say the expression is <i>assignable to</i> the variable.
</p><p>...
</p>
<div id="D5.3"></div>
<h3> <span class="mw-headline" id="5.3_Method_Invocation_Contexts_.5BModified.5D"> 5.3 <del>Method</del> Invocation <u>Contexts</u> [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.3" class="external text" rel="nofollow">JLS 5.3</a></small>
</p><p><span class="norm-static">
<u>Both <i>strict invocation contexts</i> and <i>loose invocation contexts</i> allow an</u> argument value in a method or constructor invocation (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8.7.1" class="external text" rel="nofollow">8.8.7.1</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9" class="external text" rel="nofollow">15.9</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">15.12</a>) <u>to be assigned to a corresponding formal parameter.</u><span class="assertion-id"> [jls-5.3-100]</span></span>
</p><p><span class="norm-static">
<u>Loose invocation contexts allow a more permissive set of conversions; they are only used for a particular invocation if no applicable declaration can be found using strict invocation contexts.</u><span class="assertion-id"> [jsr335-5.3-101]</span></span>
</p><p><span class="norm-static">
<u>Both</u> invocation contexts allow the use of one of the following:<span class="assertion-id"> [jls-5.3-110]</span></span>
</p>
<ul><li> <span class="norm-static"> an identity conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.1" class="external text" rel="nofollow">5.1.1</a>)<span class="assertion-id"> [jls-5.3-110-A]</span></span>
</li><li> <span class="norm-static"> a widening primitive conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.2" class="external text" rel="nofollow">5.1.2</a>)<span class="assertion-id"> [jls-5.3-110-B]</span></span>
</li><li> <span class="norm-static"> a widening reference conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.5" class="external text" rel="nofollow">5.1.5</a>)<span class="assertion-id"> [jls-5.3-110-C]</span></span>
</li></ul>
<p><span class="norm-static">
If, after the conversions listed above have been applied, the resulting type is a raw type (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.8" class="external text" rel="nofollow">4.8</a>), an unchecked conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.9" class="external text" rel="nofollow">5.1.9</a>) may then be applied.<span class="assertion-id"> [jls-5.3-120]</span></span>
</p><p><span class="norm-error">
It is a compile-time error if the chain of conversions contains two parameterized types that are not in the subtype relation.<span class="assertion-id"> [jls-5.3-200]</span></span>
</p><p><span class="norm-static">
A value of the null type (the null reference is the only such value) may be converted to any reference type.<span class="assertion-id"> [jls-5.3-300]</span></span>
</p><p><span class="norm-static">
<u>In addition, a <i>loose</i> invocation context allows the use of one of the following:</u><span class="assertion-id"> [jls-5.3-110']</span></span>
</p>
<ul><li> <span class="norm-static"> a boxing conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.7" class="external text" rel="nofollow">5.1.7</a>) optionally followed by a widening reference conversion<span class="assertion-id"> [jls-5.3-110-D]</span></span>
</li><li> <span class="norm-static"> an unboxing conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.8" class="external text" rel="nofollow">5.1.8</a>) optionally followed by a widening primitive conversion<span class="assertion-id"> [jls-5.3-110-E]</span></span>
</li></ul>
<p><span class="norm-error">
If the type of the expression cannot be converted to the type of the parameter by a conversion permitted in <u>a loose</u> <del>method</del> invocation context, then a compile-time error occurs.<span class="assertion-id"> [jls-5.3-310]</span></span>
</p><p>...
</p><p><u>By design, neither strict nor loose invocation contexts</u> include the implicit narrowing of integer constants which is <u>allowed in assignment contexts (<a href="#D5.2" title="Lambda D" class="mw-redirect">5.2</a>)</u>.  The designers of the Java programming language felt that ...
</p><p>...
</p>
<div id="D5.4"></div>
<h3> <span class="mw-headline" id="5.4_String_Contexts_.5BModified.5D"> 5.4 String <u>Contexts</u> [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.4" class="external text" rel="nofollow">JLS 5.4</a></small>
</p><p><span class="norm-static">
<u><i>String contexts</i> apply</u> only to an operand of the binary <code style="background-color:inherit;font-size:medium">+</code> operator which is not a <code style="background-color:inherit;font-size:medium">String</code> when the other operand is a <code style="background-color:inherit;font-size:medium">String</code>.<span class="assertion-id"> [jls-5.4-100]</span></span>
</p><p><span class="norm-static">
<u>The target type in these contexts is always <code style="background-color:inherit;font-size:medium">String</code>, and a string conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.11" class="external text" rel="nofollow">5.1.11</a>) always occurs</u>; evaluation of the <code style="background-color:inherit;font-size:medium">+</code> operator <u>then</u> proceeds as specified in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.8.1" class="external text" rel="nofollow">15.8.1</a>.<span class="assertion-id"> [jls-5.4-110]</span></span>
</p>
<div id="D5.5"></div>
<h3> <span class="mw-headline" id="5.5_Casting_Contexts_.5BModified.5D"> 5.5 Casting <u>Contexts</u> [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.5" class="external text" rel="nofollow">JLS 5.5</a></small>
</p><p><span class="norm-static">
<u><i>Casting contexts</i> allow</u> the operand of a cast operator (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.16" class="external text" rel="nofollow">15.16</a>) <u>to be</u> converted to the type explicitly named by the cast operator.<span class="assertion-id"> [jls-5.5-100]</span></span>
</p><p>...
</p>
<div id="D5.5.1"></div>
<h3> <span class="mw-headline" id="5.5.1_Reference_Type_Casting_.5BModified.5D"> 5.5.1 Reference Type Casting [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.5.1" class="external text" rel="nofollow">JLS 5.5.1</a></small>
</p><p><span class="norm-static">
Given a compile-time reference type <em>S</em> (source) and a compile-time reference type <em>T</em> (target), a casting conversion exists from <em>S</em> to <em>T</em> if no compile-time errors occur due to the following rules.<span class="assertion-id"> [jls-5.5.1-100]</span></span>
</p><p><span class="norm-static">
If <em>S</em> is a class type:<span class="assertion-id"> [jls-5.5.1-200]</span></span>
</p>
<ul><li> <span class="norm-static"> If <em>T</em> is a class type, ...<span class="assertion-id"> [jls-5.5.1-200-A]</span></span>
</li><li> <span class="norm-static"> If <em>T</em> is an interface type: ...<span class="assertion-id"> [jls-5.5.1-200-B]</span></span>
</li><li> <span class="norm-static"> If <em>T</em> is a type variable, then this algorithm is applied recursively, using the upper bound of <em>T</em> in place of <em>T</em>.<span class="assertion-id"> [jls-5.5.1-200-C]</span></span>
</li><li> <span class="norm-static"> <u>If <em>T</em> is an intersection type, <em>T<sub>1</sub> &amp; ... &amp; T<sub>n</sub></em>, then it is a compile-time error if there exists a <em>T<sub>i</sub></em> (<em>1 ≤ i ≤ n</em>) such that <em>S</em> cannot be cast to <em>T<sub>i</sub></em> by this algorithm.  That is, the success of the cast is determined by the most restrictive component of the intersection type.</u><span class="assertion-id"> [jsr335-5.5.1-200-E]</span></span>
</li><li> <span class="norm-static"> If <em>T</em> is an array type, ...<span class="assertion-id"> [jls-5.5.1-200-D]</span></span>
</li></ul>
<p><span class="norm-static">
If <em>S</em> is an interface type:<span class="assertion-id"> [jls-5.5.1-300]</span></span>
</p>
<ul><li> <span class="norm-static"> If <em>T</em> is an array type, ...<span class="assertion-id"> [jls-5.5.1-300-A]</span></span>
</li><li> <span class="norm-static"> If <em>T</em> is a <u>class or interface</u> type that is not <code style="background-color:inherit;font-size:medium">final</code> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.1" class="external text" rel="nofollow">8.1.1</a>), ...<span class="assertion-id"> [jls-5.5.1-300-B]</span></span>
</li><li> <span class="norm-static"> If <em>T</em> is a <u>class</u> type that is <code style="background-color:inherit;font-size:medium">final</code>, ...<span class="assertion-id"> [jls-5.5.1-300-C]</span></span>
</li><li> <span class="norm-static"> <u>If <em>T</em> is a type variable, then this algorithm is applied recursively, using the upper bound of <em>T</em> in place of <em>T</em>.</u><span class="assertion-id"> [jsr335-5.5.1-300-D]</span></span>
</li><li> <span class="norm-static"> <u>If <em>T</em> is an intersection type, <em>T<sub>1</sub> &amp; ... &amp; T<sub>n</sub></em>, then it is a compile-time error if there exists a <em>T<sub>i</sub></em> (<em>1 ≤ i ≤ n</em>) such that <em>S</em> cannot be cast to <em>T<sub>i</sub></em> by this algorithm.</u><span class="assertion-id"> [jsr335-5.5.1-300-E]</span></span>
</li></ul>
<p><span class="norm-static">
If <em>S</em> is a type variable, then this algorithm is applied recursively, using the upper bound of <em>S</em> in place of <em>S</em>.<span class="assertion-id"> [jls-5.5.1-400]</span></span>
</p><p><span class="norm-static">
If <em>S</em> is an intersection type, <em>A<sub>1</sub> &amp; ... &amp; A<sub>n</sub></em>, then it is a compile-time error if there exists an <em>A<sub>i</sub></em> (<em>1 ≤ i ≤ n</em>) such that <del><em>S</em></del> <u><em>A<sub>i</sub></em></u> cannot be cast to <del><em>A<sub>i</sub></em></del> <u><em>T</em></u> by this algorithm.  That is, the success of the cast is determined by the most restrictive component of the intersection type.<span class="assertion-id"> [jls-5.5.1-500]</span></span>
</p><p><span class="norm-static">
If <em>S</em> is an array type <em>SC<code style="background-color:inherit;font-size:medium">[]</code></em>, that is, an array of components of type <em>SC</em>:<span class="assertion-id"> [jls-5.5.1-600]</span></span>
</p>
<ul><li> <span class="norm-static"> If <em>T</em> is a class type, ...<span class="assertion-id"> [jls-5.5.1-600-A]</span></span>
</li><li> <span class="norm-static"> If <em>T</em> is an interface type, ...<span class="assertion-id"> [jls-5.5.1-600-B]</span></span>
</li><li> <span class="norm-static"> If <em>T</em> is a type variable, then <u>this algorithm is applied recursively, using the upper bound of <em>T</em> in place of <em>T</em>.</u><span class="assertion-id"> [jls-5.5.1-600-C]</span></span>
</li><li> <span class="norm-static"> <u>If <em>T</em> is an intersection type, <em>T<sub>1</sub> &amp; ... &amp; T<sub>n</sub></em>, then it is a compile-time error if there exists a <em>T<sub>i</sub></em> (<em>1 ≤ i ≤ n</em>) such that <em>S</em> cannot be cast to <em>T<sub>i</sub></em> by this algorithm.</u><span class="assertion-id"> [jsr335-5.5.1-600-E]</span></span>
</li><li> <span class="norm-static"> If <em>T</em> is an array type ...<span class="assertion-id"> [jls-5.5.1-600-D]</span></span>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
Casts can be used to explicitly "tag" a lambda expression or a method reference with a particular target type.  To provide an appropriate degree of flexibility, the target type may be a list of types denoting an intersection type (as long as the intersection is also a functional interface type (<a href="#A9.8" title="Lambda A" class="mw-redirect">9.8</a>)).  Since the feature is generally useful, these rules also support casts of arbitrary expressions to intersection types.</div></blockquote>
<div id="D5.5.2"></div>
<h3> <span class="mw-headline" id="5.5.2_Checked_Casts_and_Unchecked_Casts_.5BModified.5D"> 5.5.2 Checked Casts and Unchecked Casts [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.5.2" class="external text" rel="nofollow">JLS 5.5.2</a></small>
</p><p><span class="norm-static">
A cast from a type <em>S</em> to a type <em>T</em> is <i>statically known to be correct</i> if and only if <em>S &lt;: T</em> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.10" class="external text" rel="nofollow">4.10</a>).<span class="assertion-id"> [jls-5.5.2-100]</span></span>
</p><p><span class="norm-static">
A cast from a type <em>S</em> to a parameterized type (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.5" class="external text" rel="nofollow">4.5</a>) is <i>unchecked</i> unless ...<span class="assertion-id"> [jls-5.5.2-200]</span></span>
</p><p><span class="norm-static">
A cast from a type <em>S</em> to a type variable <em>T</em> is unchecked unless <em>S &lt;: T</em>.<span class="assertion-id"> [jls-5.5.2-300]</span></span>
</p><p><span class="norm-static">
<u>A cast from a type <em>S</em> to an intersection type <em>T<sub>1</sub> &amp; ... &amp; T<sub>n</sub></em> is unchecked if there exists a <em>T<sub>i</sub></em> (<em>1 ≤ i ≤ n</em>) such that a cast from <em>S</em> to <em>T<sub>i</sub></em> is unchecked.</u><span class="assertion-id"> [jsr335-5.5.2-350]</span></span>
</p><p><span class="norm-static">
An unchecked cast from <em>S</em> to <u>a non-intersection type</u> <em>T</em> is <i>completely unchecked</i> if the cast from <em>|S|</em> to <em>|T|</em> is statically known to be correct.  Otherwise, it is <i>partially unchecked</i>.<span class="assertion-id"> [jls-5.5.2-400]</span></span>
</p><p><span class="norm-static">
<u>An unchecked cast from <em>S</em> to an intersection type <em>T<sub>1</sub> &amp; ... &amp; T<sub>n</sub></em> is <i>completely unchecked</i> if, for all <em>i</em>, <em>1 ≤ i ≤ n</em>, a cast from <em>S</em> to <em>T<sub>i</sub></em> is either statically known to be correct or completely unchecked.  Otherwise, it is <i>partially unchecked</i>.</u><span class="assertion-id"> [jsr335-5.5.2-410]</span></span>
</p><p><span class="norm-error">
An unchecked cast causes a compile-time unchecked warning, unless suppressed by the <code style="background-color:inherit;font-size:medium">SuppressWarnings</code> annotation (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.6.3.5" class="external text" rel="nofollow">9.6.3.5</a>).<span class="assertion-id"> [jls-5.5.2-500]</span></span>
</p><p><span class="norm-static">
A cast is <i>checked</i> if it is not statically known to be correct and it is not unchecked.<span class="assertion-id"> [jls-5.5.2-600]</span></span>
</p><p><span class="norm-static">
If a cast to a reference type is not a compile-time error, there are several cases:<span class="assertion-id"> [jls-5.5.2-700]</span></span>
</p>
<ul><li> <span class="norm-static"> The cast is statically known to be correct.<span class="assertion-id"> [jls-5.5.2-700-A]</span></span><p><span class="norm-static"> No run-time action is performed for such a cast.<span class="assertion-id"> [jls-5.5.2-700-A.1]</span></span></p>
</li><li> <span class="norm-static"> The cast is a completely unchecked cast.<span class="assertion-id"> [jls-5.5.2-700-B]</span></span><p><span class="norm-static"> No run-time action is performed for such a cast.<span class="assertion-id"> [jls-5.5.2-700-B.1]</span></span></p>
</li><li> <u><span class="norm-static"> The cast is a partially unchecked or checked cast to an intersection type.<span class="assertion-id"> [jsr335-5.5.2-700-E]</span></span></u><p><u><span class="norm-static"> Where the intersection type is <em>T<sub>1</sub> &amp; ... &amp; T<sub>n</sub></em>, then for all <em>i</em> (<em>1 ≤ i ≤ n</em>), any run-time check required for a cast from <em>S</em> to <em>T<sub>i</sub></em> is also required for the cast to the intersection type.<span class="assertion-id"> [jsr335-5.5.2-700-E.1]</span></span></u></p>
</li><li> <span class="norm-static"> The cast is a partially unchecked cast <u>to a non-intersection type</u>.<span class="assertion-id"> [jls-5.5.2-700-C]</span></span><p><span class="norm-static"> Such a cast requires a run-time validity check.  The check is performed as if the cast had been a checked cast between <em>|S|</em> and <em>|T|</em>, as described below.<span class="assertion-id"> [jls-5.5.2-700-C.1]</span></span></p>
</li><li> <span class="norm-static"> The cast is a checked cast <u>to a non-intersection type</u>.<span class="assertion-id"> [jls-5.5.2-700-D]</span></span><p><span class="norm-static"> Such a cast requires a run-time validity check.  If the value at run-time is <code style="background-color:inherit;font-size:medium">null</code>, then the cast is allowed.  Otherwise, let <em>R</em> be the class of the object referred to by the run-time reference value, and let <em>T</em> be the erasure of the type named in the cast operator.  A cast conversion must check, at run-time, that the class <em>R</em> is assignment compatible with the type <em>T</em>, via the algorithm in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.5.3" class="external text" rel="nofollow">5.5.3</a>.<span class="assertion-id"> [jls-5.5.2-700-D.1]</span></span></p><p>Note that <em>R</em> cannot be an interface when these rules are first applied for any given cast, but <em>R</em> may be an interface if the rules are applied recursively because the run-time reference value may refer to an array whose element type is an interface type.</p>
</li></ul>
<div id="D5.6"></div>
<h3> <span class="mw-headline" id="5.6_Numeric_Contexts_.5BModified.5D"> 5.6 Numeric <u>Contexts</u> [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.6" class="external text" rel="nofollow">JLS 5.6</a></small>
</p><p><span class="norm-static">
<u><i>Numeric contexts</i> apply</u> to the operands of an arithmetic operator.<span class="assertion-id"> [jls-5.6-100]</span></span>
</p><p><span class="norm-static">
Numeric <del>promotion</del> contexts allow the use of:<span class="assertion-id"> [jls-5.6-110]</span></span>
</p>
<ul><li> <span class="norm-static"> an identity conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.1" class="external text" rel="nofollow">5.1.1</a>)<span class="assertion-id"> [jls-5.6-110-A]</span></span>
</li><li> <span class="norm-static"> a widening primitive conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.2" class="external text" rel="nofollow">5.1.2</a>)<span class="assertion-id"> [jls-5.6-110-B]</span></span>
</li><li> <span class="norm-static"> an unboxing conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.8" class="external text" rel="nofollow">5.1.8</a>) <u>optionally followed by a widening primitive conversion</u><span class="assertion-id"> [jls-5.6-110-C]</span></span>
</li></ul>
<p><span class="norm-static">
<u>A <i>numeric promotion</i> is a process by which, given a numeric operator and its argument expressions, the arguments are converted to an inferred target type <em>T</em>.  <em>T</em> is chosen during promotion such that each argument expression can be converted to <em>T</em> and the operation is defined for values of type <em>T</em>.</u><span class="assertion-id"> [jls-5.6-200]</span></span>
</p><p>The two kinds of numeric promotion are unary numeric promotion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.6.1" class="external text" rel="nofollow">5.6.1</a>) and binary numeric promotion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.6.2" class="external text" rel="nofollow">5.6.2</a>).
</p>
<div id="D15.1"></div>
<h3> <span class="mw-headline" id="15.1_Evaluation.2C_Denotation.2C_and_Result_.5BAddendum.5D"> 15.1 Evaluation, Denotation, and Result [Addendum] </span></h3>
<p><small>See <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.1" class="external text" rel="nofollow">JLS 15.1</a></small>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The following from section 15.2 is merged into 15.1, in order to make room for a new section.</div></blockquote>
<p><span class="norm-static">
If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used.  In this context, if the expression denotes a variable or a value, we may speak simply of the <i>value</i> of the expression.<span class="assertion-id"> [jls-15.2-100]</span></span>
</p><p><span class="norm-dynamic">
If the value of a variable of type <code style="background-color:inherit;font-size:medium">float</code> or <code style="background-color:inherit;font-size:medium">double</code> is used in this manner, then value set conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.13" class="external text" rel="nofollow">5.1.13</a>) is applied to the value of the variable.<span class="assertion-id"> [jls-15.2-110]</span></span>
</p>
<div id="D15.2"></div>
<h3> <span class="mw-headline" id="15.2_Forms_of_Expressions_.5BNew.5D"> 15.2 Forms of Expressions [New] </span></h3>
<p>Expressions can be broadly categorized into one of the following syntactic forms:
</p>
<ul><li> Expression names (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.5.6" class="external text" rel="nofollow">6.5.6</a>)
</li><li> Primaries (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.8" class="external text" rel="nofollow">15.8-15.13</a>
</li><li> Unary operator expressions (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.14" class="external text" rel="nofollow">15.14-15.16</a>)
</li><li> Binary operator expressions (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.17" class="external text" rel="nofollow">15.17-15.24</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.26" class="external text" rel="nofollow">15.26</a>)
</li><li> Conditional operator expressions (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.25" class="external text" rel="nofollow">15.25</a>)
</li><li> Lambda expressions (<a href="#B15.27" title="Lambda B" class="mw-redirect">15.27</a>)
</li></ul>
<p>Precedence among operators is managed by a hierarchy of grammar productions.  The lowest-precedence operator is the arrow, <code style="background-color:inherit;font-size:medium">-&gt;</code>, of a lambda expression (<a href="#B15.27" title="Lambda B" class="mw-redirect">15.27</a>), followed by the assignment operators (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.26" class="external text" rel="nofollow">15.26</a>).  So all expressions are syntactically derived from one of these productions:
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
Expression:
  LambdaExpression
  AssignmentExpression
</pre>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>This production was moved from <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.27" class="external text" rel="nofollow">15.27</a>.</div></blockquote>
<p><span class="norm-static">
When some expressions appear in certain contexts (<a href="#D5" title="Lambda D" class="mw-redirect">5</a>), they are considered <i>poly expressions</i>.  Expressions that are not poly expressions are <i>standalone expressions.</i><span class="assertion-id"> [jsr335-15.2-10]</span></span>
</p><p><span class="norm-static">
The following forms of expressions may be poly expressions:<span class="assertion-id"> [jsr335-15.2-12]</span></span>
</p>
<ul><li> <span class="norm-static"> Parenthesized expressions (<a href="#D15.8.5" title="Lambda D" class="mw-redirect">15.8.5</a>)<span class="assertion-id"> [jsr335-15.2-12-A]</span></span>
</li><li> <span class="norm-static"> Class instance creation expressions (<a href="#D15.9" title="Lambda D" class="mw-redirect">15.9</a>)<span class="assertion-id"> [jsr335-15.2-12-B]</span></span>
</li><li> <span class="norm-static"> Method invocation expressions (<a href="#D15.12" title="Lambda D" class="mw-redirect">15.12</a>)<span class="assertion-id"> [jsr335-15.2-12-C]</span></span>
</li><li> <span class="norm-static"> Conditional operator expressions (<a href="#D15.25" title="Lambda D" class="mw-redirect">15.25</a>)<span class="assertion-id"> [jsr335-15.2-12-D]</span></span>
</li><li> <span class="norm-static"> Lambda expressions (<a href="#E15.27" title="Lambda E" class="mw-redirect">15.27</a>)<span class="assertion-id"> [jsr335-15.2-12-E]</span></span>
</li><li> <span class="norm-static"> Method reference expressions (<a href="#E15.13" title="Lambda E" class="mw-redirect">15.13</a>)<span class="assertion-id"> [jsr335-15.2-12-F]</span></span>
</li></ul>
<p><span class="norm-static">
The rules determining whether an expression of one of these forms is a poly expression are explained separately below for each form of expression.<span class="assertion-id"> [jsr335-15.2-11]</span></span>
</p><p><span class="norm-static">
All other forms of expressions are said to have a <i>standalone form</i>, and are always standalone expressions.<span class="assertion-id"> [jsr335-15.2-13]</span></span>
</p><p><span class="norm-static">
Some expressions have a value that can be determined at compile time.  These are <i>constant expressions</i> (<a href="#D15.29" title="Lambda D" class="mw-redirect">15.29</a>).<span class="assertion-id"> [jsr335-15.2-20]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> This new section is a preview of the rest of the chapter.  Its most important role is to describe the kinds of poly expressions, but more generally it's a convenient place to outline the different approaches to categorizing expressions.  It also gives an up front definition of the term <i>expression</i> (this previously was withheld until the very end of the chapter).
</div></li>
<li style="margin-bottom:12px;"><div> A lambda expression seems conceptually like a primary, but the fact that its body can be an arbitrary, undelimited expression means that, syntactically, it must be treated as the highest-precedence operator.  For example, the body of <code style="background-color:inherit;font-size:medium">() -&gt; x + 1</code> should be interpreted as <code style="background-color:inherit;font-size:medium">() -&gt; (x + 1)</code>.
</div></li>
<li style="margin-bottom:12px;"><div> Special collection literal syntax is an anticipated future Java feature.  These would fit in nicely as poly expressions (and perhaps as standalone expressions, too, like method invocations).
<p>Array initializers (<code style="background-color:inherit;font-size:medium">int[] x = {1,2,3}</code>; see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-10.html#jls-10.6" class="external text" rel="nofollow">10.6</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.4" class="external text" rel="nofollow">14.4</a>) are not expressions at all, as a sort of hack in the original language design to allow a very restricted context dependency.  (Despite this, the initializer of a variable is often refered to generically as an "expression.")  It would make sense to take advantage of poly expressions as a way to eliminate this special case, bring them under the same umbrella, and allow more flexibility in their use.  But this would best be addressed in conjunction with any new collection syntax.
</p>
</div></li></ol></div></blockquote>
<p><br />
</p>
<div id="D15.3"></div>
<h3> <span class="mw-headline" id="15.3_Type_of_an_Expression_.5BModified.5D"> 15.3 Type of an Expression [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.3" class="external text" rel="nofollow">JLS 15.3</a></small>
</p><p>If an expresion denotes a variable or a value, then the expression has a type known at compile time.
</p><p><u>Given certain meanings of names (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.5" class="external text" rel="nofollow">6.5</a>), the type of a standalone expression can be determined entirely from the contents of the expression.  In contrast, the type of a poly expression may be influenced by the expression's target type (<a href="#D5" title="Lambda D" class="mw-redirect">5</a>).</u>
</p><p>The rules for determining the type of an expression are explained separately below for each kind of expression.
</p><p>...
</p>
<div id="D15.8"></div>
<h3> <span class="mw-headline" id="15.8_Primary_Expressions_.5BModified.5D"> 15.8 Primary Expressions [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.8" class="external text" rel="nofollow">JLS 15.8</a></small>
</p><p>...
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
Primary:
  PrimaryNoNewArray
  ArrayCreationExpression

PrimaryNoNewArray:
  Literal
  Type '.' 'class'
  'void' '.' 'class'
  'this'
  ClassName '.' 'this'
  '(' Expression ')'
  ClassInstanceCreationExpression
  FieldAccess
  MethodInvocation
  ArrayAccess
  <u>MethodReference</u>
</pre>
<p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
Despite strict restrictions on where they can appear, method references are most naturally described as primaries.  The restrictions on context are therefore enforced outside the grammar.</div></blockquote>
<div id="D15.8.5"></div>
<h3> <span class="mw-headline" id="15.8.5_Parenthesized_Expressions_.5BAddendum.5D"> 15.8.5 Parenthesized Expressions [Addendum] </span></h3>
<p><small>See <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.8.5" class="external text" rel="nofollow">JLS 15.8.5</a></small>
</p><p><span class="norm-static">
If a parenthesized expression appears in a context of a particular kind with target type <em>T</em> (<a href="#D5" title="Lambda D" class="mw-redirect">5</a>), its contained expression similarly appears in a context of the same kind with target type <em>T</em>.<span class="assertion-id"> [jsr335-15.8.5-10]</span></span>
</p><p><span class="norm-static">
If the contained expression is a poly expression (<a href="#D15.2" title="Lambda D" class="mw-redirect">15.2</a>), the parenthesized expression is also a poly expression.  Otherwise, it is a standalone expression.<span class="assertion-id"> [jsr335-15.8.5-20]</span></span>
</p>
<div id="D15.9"></div>
<h3> <span class="mw-headline" id="15.9_Class_Instance_Creation_Expressions_.5BAddendum.5D"> 15.9 Class Instance Creation Expressions [Addendum] </span></h3>
<p><small>See <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9" class="external text" rel="nofollow">JLS 15.9</a></small>
</p><p><span class="norm-static">
A class instance creation expression is a poly expression (<a href="#D15.2" title="Lambda D" class="mw-redirect">15.2</a>) if i) it uses a diamond '<code style="background-color:inherit;font-size:medium">&lt;&gt;</code>' in place of type arguments, and ii) it appears in an assignment context (<a href="#D5.2" title="Lambda D" class="mw-redirect">5.2</a>) or an invocation context (<a href="#D5.3" title="Lambda D" class="mw-redirect">5.3</a>).  Otherwise, it is a standalone expression.<span class="assertion-id"> [jsr335-15.9-10]</span></span>
</p>
<div id="D15.12"></div>
<h3> <span class="mw-headline" id="15.12_Method_Invocation_Expressions_.5BAddendum.5D"> 15.12 Method Invocation Expressions [Addendum] </span></h3>
<p><small>See <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">JLS 15.12</a></small>
</p><p><span class="norm-static">
A method invocation expression is a poly expression if all of the following are true:<span class="assertion-id"> [jsr335-15.12-10]</span></span>
</p>
<ul><li> <span class="norm-static"> The invocation appears in an assignment context (<a href="#D5.2" title="Lambda D" class="mw-redirect">5.2</a>) or an invocation context (<a href="#D5.3" title="Lambda D" class="mw-redirect">5.3</a>).<span class="assertion-id"> [jsr335-15.12-10-A]</span></span>
</li><li> <span class="norm-static"> The invocation elides <em>NonWildTypeArguments</em>.<span class="assertion-id"> [jsr335-15.12-10-B]</span></span>
</li><li> <span class="norm-static"> The method to be invoked, as determined by the following subsections, is a generic method (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.4" class="external text" rel="nofollow">8.4.4</a>).<span class="assertion-id"> [jsr335-15.12-10-C]</span></span>
</li><li> <span class="norm-static"> The return type of the method to be invoked mentions at least one of the method's type parameters.<span class="assertion-id"> [jsr335-15.12-10-D]</span></span>
</li></ul>
<p><span class="norm-static">
Otherwise, the method invocation expression is a standalone expression.<span class="assertion-id"> [jsr335-15.12-11]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p><p>Class instance creations and method invocations may be poly expressions because type argument inference (including "diamond" inference) may depend on context.
</p>
Given that adjustments must be made to inference in order to support lambda expressions, this document also seeks to improve the algorithm's interaction with context in general, which is currently very ad hoc.  See <a href="#G" title="Lambda G" class="mw-redirect">Part G</a> for details.</div></blockquote>
<div id="D15.16"></div>
<h3> <span class="mw-headline" id="15.16_Cast_Expressions_.5BModified.5D"> 15.16 Cast Expressions [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.16" class="external text" rel="nofollow">JLS 15.16</a></small>
</p><p>A cast expression converts, at run-time, a value of one numeric type to a similar value of another numeric type; or confirms, at compile-time, that the type of an expression is <code style="background-color:inherit;font-size:medium">boolean</code>; or checks, at run-time, that a reference value refers to an object whose class is compatible with a specified reference type <u>or list of reference types</u>.
</p><p>The parentheses and the type <u>or list of types</u> they contain are sometimes called the <i>cast operator</i>.
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
CastExpression:
  '(' PrimitiveType ')' UnaryExpression
  '(' ReferenceType ')' <del>UnaryExpressionNotPlusMinus</del> <u>ReferenceCastOperand</u>
  <u>'(' ClassOrInterfaceType AdditionalBoundList ')' ReferenceCastOperand</u>

<u>ReferenceCastOperand:</u>
  <u>UnaryExpressionNotPlusMinus</u>
  <u>LambdaExpression</u>
</pre>
<p>See <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.15" class="external text" rel="nofollow">15.15</a> for a discussion of the distinction between <em>UnaryExpression</em> and <em>UnaryExpressionNotPlusMinus</em>.
</p><p><u>The following productions from <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.4" class="external text" rel="nofollow">4.4</a> are repeated here for convenience:</u>
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
<u>AdditionalBoundList:</u>
  <u>AdditionalBound AdditionalBoundList</u>
  <u>AdditionalBound</u>

<u>AdditionalBound:</u>
  <u>'&amp;' InterfaceType</u>
</pre>
<p><span class="norm-error">
<u>If the cast expression has an <em>AdditionalBoundList</em>, then the following conditions must hold for the listed types (including the <em>ClassOrInterfaceType</em> and each additional <em>InterfaceType</em>), or a compile-time error occurs:</u><span class="assertion-id"> [jsr335-15.16-5]</span></span>
</p>
<ul><li> <span class="norm-error"> <u>The erasures (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.6" class="external text" rel="nofollow">4.6</a>) of all the listed types are pairwise different.</u><span class="assertion-id"> [jsr335-15.16-5-A]</span></span>
</li><li> <span class="norm-error"> <u>No two listed types are subtypes of different parameterizations of the same generic interface.</u><span class="assertion-id"> [jsr335-15.16-5-B]</span></span>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>These conditions mimic those in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.4" class="external text" rel="nofollow">4.4</a>.</div></blockquote>
<p><span class="norm-static">
<u>The target type for the casting context (<a href="#D5.5" title="Lambda D" class="mw-redirect">5.5</a>) introduced by the cast expression is, when an <em>AdditionalBoundList</em> is absent, the type appearing within the parentheses; or, when an <em>AdditionalBoundList</em> is present, the intersection type expressed by <em>ClassOrInterfaceType AdditionalBoundList</em>.</u><span class="assertion-id"> [jsr335-15.16-10]</span></span>
</p><p><span class="norm-static">
The type of a cast expression is the result of applying capture conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.10" class="external text" rel="nofollow">5.1.10</a>) to <u>this target type</u>.<span class="assertion-id"> [jls-15.16-200]</span></span>
</p>
<div id="D15.25"></div>
<h3> <span class="mw-headline" id="15.25_Conditional_Operator_.3F_:_.5BModified.5D"> 15.25 Conditional Operator&nbsp;?&nbsp;: [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.25" class="external text" rel="nofollow">JLS 15.25</a></small>
</p><p>...
</p><p><span class="norm-static">
The conditional operator has three operand expressions.  <code style="background-color:inherit;font-size:medium">?</code> appears between the first and second expressions, and <code style="background-color:inherit;font-size:medium">:</code> appears between the second and third expressions.<span class="assertion-id"> [jls-15.25-200]</span></span>
</p><p><span class="norm-error">
The first expression must be of type <code style="background-color:inherit;font-size:medium">boolean</code> or <code style="background-color:inherit;font-size:medium">Boolean</code>, or a compile-time error occurs.<span class="assertion-id"> [jls-15.25-210]</span></span>
</p><p><span class="norm-error">
It is a compile-time error for either the second or the third operand expression to be an invocation of a <code style="background-color:inherit;font-size:medium">void</code> method.<span class="assertion-id"> [jls-15.25-220]</span></span>
</p><p><span class="norm-static">
<u>There are three kinds of conditional expressions, classified according to the second and third operand expressions: <i>boolean conditional expressions</i>, <i>numeric conditional expressions</i>, and <i>reference conditional expressions</i>.</u><span class="assertion-id"> [jsr335-15.25-10]</span></span>
</p>
<ul><li> <span class="norm-static"> <u>If both the second and the third operand expressions are <i>boolean expressions</i>, the conditional expression is a boolean conditional.  For the purpose of classifying a conditional, the following expressions are <i>boolean expressions</i>:</u><span class="assertion-id"> [jsr335-15.25-10-A]</span></span>
<ul><li> <span class="norm-static"> <u>An expression of a standalone form (<a href="#D15.2" title="Lambda D" class="mw-redirect">15.2</a>) that has type <code style="background-color:inherit;font-size:medium">boolean</code> or <code style="background-color:inherit;font-size:medium">Boolean</code>.</u><span class="assertion-id"> [jsr335-15.25-10-A1]</span></span>
</li><li> <span class="norm-static"> <u>A parenthesized (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.8.5" class="external text" rel="nofollow">15.8.5</a>) boolean expression.</u><span class="assertion-id"> [jsr335-15.25-10-A2]</span></span>
</li><li> <span class="norm-static"> <u>A class instance creation expression (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9" class="external text" rel="nofollow">15.9</a>) for class <code style="background-color:inherit;font-size:medium">Boolean</code>.</u><span class="assertion-id"> [jsr335-15.25-10-A3]</span></span>
</li><li> <span class="norm-static"> <u>A method invocation expression (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">15.12</a>) for which the chosen most-specific method (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.5" class="external text" rel="nofollow">15.12.2.5</a>) has return type <code style="background-color:inherit;font-size:medium">boolean</code> or <code style="background-color:inherit;font-size:medium">Boolean</code>.</u><span class="assertion-id"> [jsr335-15.25-10-A4]</span></span><p><u>Note that, for a generic method, this is the type <i>before</i> instantiating the method's type arguments.</u></p>
</li><li> <span class="norm-static"> <u>A boolean conditional expression.</u><span class="assertion-id"> [jsr335-15.25-10-A5]</span></span>
</li></ul>
</li><li> <span class="norm-static"> <u>Similarly, if both the second and the third operand expressions are <i>numeric expressions</i>, the conditional expression is a numeric conditional.  For the purpose of classifying a conditional, the following expressions are <i>numeric expressions</i>:</u><span class="assertion-id"> [jsr335-15.25-10-B]</span></span>
<ul><li> <span class="norm-static"> <u>An expression of a standalone form (<a href="#D15.2" title="Lambda D" class="mw-redirect">15.2</a>) with a type that is convertible to a numeric type (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2" class="external text" rel="nofollow">4.2</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.8" class="external text" rel="nofollow">5.1.8</a>).</u><span class="assertion-id"> [jsr335-15.25-10-B1]</span></span>
</li><li> <span class="norm-static"> <u>A parenthesized (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.8.5" class="external text" rel="nofollow">15.8.5</a>) numeric expression.</u><span class="assertion-id"> [jsr335-15.25-10-B2]</span></span>
</li><li> <span class="norm-static"> <u>A class instance creation expression (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9" class="external text" rel="nofollow">15.9</a>) for a class that is convertible to a numeric type.</u><span class="assertion-id"> [jsr335-15.25-10-B3]</span></span>
</li><li> <span class="norm-static"> <u>A method invocation expression (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">15.12</a>) for which the chosen most-specific method (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.5" class="external text" rel="nofollow">15.12.2.5</a>) has a return type that is convertible to a numeric type.</u><span class="assertion-id"> [jsr335-15.25-10-B4]</span></span><p><u>Note that, for a generic method, this is the type <i>before</i> instantiating the method's type arguments.</u></p>
</li><li> <span class="norm-static"> <u>A numeric conditional expression.</u><span class="assertion-id"> [jsr335-15.25-10-B5]</span></span>
</li></ul>
</li><li> <span class="norm-static"> <u>Otherwise, the conditional expression is a reference conditional.</u><span class="assertion-id"> [jsr335-15.25-10-C]</span></span>
</li></ul>
<p><span class="norm-static">
<u>The process for determining</u> the type of a conditional expression <u>depends on the kind of conditional, as outlined in the following sections.</u><span class="assertion-id"> [jls-15.25-300]</span></span>
</p><p><span class="norm-dynamic">
At run-time, the first operand expression of the conditional expression is evaluated first.  If necessary, unboxing conversion is performed on the result.<span class="assertion-id"> [jls-15.25-400]</span></span>
</p><p><span class="norm-dynamic">
The resulting <code style="background-color:inherit;font-size:medium">boolean</code> value is then used to choose either the second or the third operand expression:<span class="assertion-id"> [jls-15.25-410]</span></span>
</p>
<ul><li> <span class="norm-dynamic"> If the value of the first operand is <code style="background-color:inherit;font-size:medium">true</code>, then the second operand expression is chosen.<span class="assertion-id"> [jls-15.25-410-A]</span></span>
</li><li> <span class="norm-dynamic"> If the value of the first operand is <code style="background-color:inherit;font-size:medium">false</code>, then the third operand expression is chosen.<span class="assertion-id"> [jls-15.25-410-B]</span></span>
</li></ul>
<p><span class="norm-dynamic">
The chosen operand expression is then evaluated and the resulting value is converted to the type of the conditional expression as determined by the rules stated <del>above</del> <u>below</u>.<span class="assertion-id"> [jls-15.25-420]</span></span>
</p><p><span class="norm-dynamic">
This conversion may include boxing (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.7" class="external text" rel="nofollow">5.1.7</a>) or unboxing (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.8" class="external text" rel="nofollow">5.1.8</a>) conversion.<span class="assertion-id"> [jls-15.25-430]</span></span>
</p><p><span class="norm-dynamic">
The operand expression not chosen is not evaluated for that particular evaluation of the conditional expression.<span class="assertion-id"> [jls-15.25-440]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p><p>We classify conditional expressions here in order to enhance the typing rules of reference conditionals (<a href="#D15.25.3" title="Lambda D" class="mw-redirect">15.25.3</a>) while preserving existing behavior of boolean and numeric conditionals.  If we tried to treat all conditionals uniformly, there would be a variety of unwanted incompatible changes, including changes in overload resolution and boxing/unboxing behavior.
</p>
This also simplifies the presentation of the typing rules by separating the rules for handling primitives from the rules for handling references.</div></blockquote>
<div id="D15.25.1"></div>
<h3> <span class="mw-headline" id="15.25.1_Boolean_Conditional_Expressions_.5BNew.5D"> 15.25.1 Boolean Conditional Expressions [New] </span></h3>
<p><span class="norm-static">
Boolean conditional expressions are standalone expressions (<a href="#D15.2" title="Lambda D" class="mw-redirect">15.2</a>).<span class="assertion-id"> [jsr335-15.25.1-10]</span></span>
</p><p><span class="norm-static">
The type of a boolean conditional expression is determined as follows:<span class="assertion-id"> [jsr335-15.25.1-20]</span></span>
</p>
<ul><li> <span class="norm-static"> If both the second and the third operands are of type <code style="background-color:inherit;font-size:medium">Boolean</code>, the conditional has type <code style="background-color:inherit;font-size:medium">Boolean</code>.<span class="assertion-id"> [jsr335-15.25.1-20-A]</span></span>
</li><li> <span class="norm-static"> Otherwise, the conditional has type <code style="background-color:inherit;font-size:medium">boolean</code>.<span class="assertion-id"> [jsr335-15.25.1-20-B]</span></span>
</li></ul>
<div id="D15.25.2"></div>
<h3> <span class="mw-headline" id="15.25.2_Numeric_Conditional_Expressions_.5BNew.5D"> 15.25.2 Numeric Conditional Expressions [New] </span></h3>
<p><span class="norm-static">
Numeric conditional expressions are standalone expressions (<a href="#D15.2" title="Lambda D" class="mw-redirect">15.2</a>).<span class="assertion-id"> [jsr335-15.25.2-10]</span></span>
</p><p><span class="norm-static">
The type of a numeric conditional expression is determined as follows:<span class="assertion-id"> [jsr335-15.25.2-20]</span></span>
</p>
<ul><li> <span class="norm-static"> If both the second and the third operands have the same type, then that is the type of the conditional expression.<span class="assertion-id"> [jsr335-15.25.2-20-A]</span></span>
</li><li> <span class="norm-static"> If one of the second and third operands is of primitive type <em>T</em>, and the type of the other is the result of applying boxing conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.7" class="external text" rel="nofollow">5.1.7</a>) to <em>T</em>, then the type of the conditional expression is <em>T</em>.<span class="assertion-id"> [jls-15.25-300-B]</span></span>
</li><li> <span class="norm-static"> If one of the operands is of type <code style="background-color:inherit;font-size:medium">byte</code> or <code style="background-color:inherit;font-size:medium">Byte</code> and the other is of type <code style="background-color:inherit;font-size:medium">short</code> or <code style="background-color:inherit;font-size:medium">Short</code>, then the type of the conditional expression is <code style="background-color:inherit;font-size:medium">short</code>.<span class="assertion-id"> [jls-15.25-300-D-1]</span></span>
</li><li> <span class="norm-static"> If one of the operands is of type <em>T</em>, where <em>T</em> is <code style="background-color:inherit;font-size:medium">byte</code>, <code style="background-color:inherit;font-size:medium">short</code>, or <code style="background-color:inherit;font-size:medium">char</code>, and the other operand is a constant expression of type <code style="background-color:inherit;font-size:medium">int</code> whose value is representable in type <em>T</em>, then the type of the conditional expression is <em>T</em>.<span class="assertion-id"> [jls-15.25-300-D-2]</span></span>
</li><li> <span class="norm-static"> If one of the operands is of type <em>T</em>, where <em>T</em> is <code style="background-color:inherit;font-size:medium">Byte</code>, <code style="background-color:inherit;font-size:medium">Short</code>, or <code style="background-color:inherit;font-size:medium">Character</code>, and the other operand is a constant expression of type <code style="background-color:inherit;font-size:medium">int</code> whose value is representable in the type <em>U</em> which is the result of applying unboxing conversion to <em>T</em>, then the type of the conditional expression is <em>U</em>.<span class="assertion-id"> [jls-15.25-300-D-3]</span></span>
</li><li> <span class="norm-static"> Otherwise, binary numeric promotion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.6.2" class="external text" rel="nofollow">5.6.2</a>) is applied to the operand types, and the type of the conditional expression is the promoted type of the second and third operands.<span class="assertion-id"> [jls-15.25-300-D-4]</span></span><p>Note that binary numeric promotion performs value set conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.13" class="external text" rel="nofollow">5.1.13</a>) and may perform unboxing conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.8" class="external text" rel="nofollow">5.1.8</a>).</p>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The typing rules are lifted directly from the relevant parts of <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.25" class="external text" rel="nofollow">15.25</a>.</div></blockquote>
<div id="D15.25.3"></div>
<h3> <span class="mw-headline" id="15.25.3_Reference_Conditional_Expressions_.5BNew.5D"> 15.25.3 Reference Conditional Expressions [New] </span></h3>
<p><span class="norm-static">
A reference conditional expression is a poly expression if it appears in an assignment context (<a href="#D5.2" title="Lambda D" class="mw-redirect">5.2</a>) or an invocation context (<a href="#D5.3" title="Lambda D" class="mw-redirect">5.3</a>).  Otherwise, it is a standalone expression.<span class="assertion-id"> [jsr335-15.25.3-10]</span></span>
</p><p><span class="norm-static">
Where a poly reference conditional expression appears in a context of a particular kind with target type <em>T</em> (<a href="#D5" title="Lambda D" class="mw-redirect">5</a>), its second and third operand expressions similarly appear in a context of the same kind with target type <em>T</em>.<span class="assertion-id"> [jsr335-15.25.3-20]</span></span>
</p><p><span class="norm-static">
The type of a poly reference conditional expression is the same as its target type.<span class="assertion-id"> [jsr335-15.25.3-30]</span></span>
</p><p><span class="norm-static">
The type of a standalone reference conditional expression is determined as follows:<span class="assertion-id"> [jsr335-15.25.3-35]</span></span>
</p>
<ul><li> <span class="norm-static"> If both the second and the third operands have the same type (which may be the null type), then that is the type of the conditional expression.<span class="assertion-id"> [jls-15.25-300-A]</span></span>
</li><li> <span class="norm-static"> If one of the second and third operands is of the null type and the type of the other is a reference type, then the type of the conditional expression is that reference type.<span class="assertion-id"> [jls-15.25-300-C]</span></span>
</li><li> <span class="norm-static"> Otherwise, the second and third operands are of types <em>S<sub>1</sub></em> and <em>S<sub>2</sub></em> respectively.  Let <em>T<sub>1</sub></em> be the type that results from applying boxing conversion to <em>S<sub>1</sub></em>, and let <em>T<sub>2</sub></em> be the type that results from applying boxing conversion to <em>S<sub>2</sub></em>.<span class="assertion-id"> [jls-15.25-300-E]</span></span><p><span class="norm-static"> The type of the conditional expression is the result of applying capture conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.10" class="external text" rel="nofollow">5.1.10</a>) to <em>lub(T<sub>1</sub>, T<sub>2</sub>)</em> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.7" class="external text" rel="nofollow">15.12.2.7</a>).<span class="assertion-id"> [jls-15.25-300-E.1]</span></span>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The standalone typing rules are lifted directly from the relevant parts of <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.25" class="external text" rel="nofollow">15.25</a>.</div></blockquote>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> By making conditional operator expressions poly expressions, we allow them to "pass down" context to their arguments.  This allows lambda expressions and method references to appear as subexpressions.
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">return condition ? (x -&gt; x) : (x -&gt; -x);</pre>
<p>It also allows us to use the extra information to improve type checking of generic method invocations.  In Java SE 7, this is well-typed:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">List&lt;String&gt; l = Arrays.asList();</pre>
<p>While this is not:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">List&lt;String&gt; l = condition ? Arrays.asList() : Arrays.asList(&quot;a&quot;,&quot;b&quot;);</pre>
<p>These rules allow both expressions to be considered well-typed.
</p>
</div></li>
<li style="margin-bottom:12px;"><div>
<p>A reference conditional expression does not have to <i>contain</i> a poly expression as an operand in order to <i>be</i> a poly expression.  It is a poly expression simply by virtue of the context in which it appears.
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
Class&lt;? super Integer&gt; choose(boolean b,
                              Class&lt;Integer&gt; c1,
                              Class&lt;Number&gt; c2) {
  return b ? c1 : c2;
}
</pre>
<p>Even though <em>lub(<code style="background-color:inherit;font-size:medium">Class&lt;Number&gt;</code>, <code style="background-color:inherit;font-size:medium">Class&lt;Integer&gt;</code>)</em> is defined as <code style="background-color:inherit;font-size:medium">Class&lt;? extends Number&gt;</code>, there is no compile-time error in the declaration of <code style="background-color:inherit;font-size:medium">choose</code>: the conditional expression is a poly expression, and so rather than computing a <em>lub</em>, each operand is considered to be in an assignment context targeting <code style="background-color:inherit;font-size:medium">Class&lt;? super Integer&gt;</code>.
</p>
</div></li></ol></div></blockquote>
<div id="D15.26"></div>
<h3> <span class="mw-headline" id="15.26_Assignment_Operators_.5BNew.5D"> 15.26 Assignment Operators [New] </span></h3>
<p>...
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
Assignment:
  LeftHandSide AssignmentOperator <del>AssignmentExpression</del> <u>Expression</u>
</pre>
<p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
The right-hand side of an assignment may be a <em>LambdaExpression</em>.</div></blockquote></p>



<a id="top"></a>
	
	<a id="E"/><h1 id="firstHeading" class="firstHeading">Lambda Specification, Part E: Typing and Evaluation</h1>
									<p><small>
Navigation: <a href="#overview" title="Lambda Specification" class="mw-redirect">Overview</a>&nbsp;- <a href="#A" title="Lambda A" class="mw-redirect">Part A</a>&nbsp;- <a href="#B" title="Lambda B" class="mw-redirect">Part B</a>&nbsp;- <a href="#C" title="Lambda C" class="mw-redirect">Part C</a>&nbsp;- <a href="#D" title="Lambda D" class="mw-redirect">Part D</a>&nbsp;- <a href="#E" title="Lambda E" class="mw-redirect">Part E</a>&nbsp;- <a href="#F" title="Lambda F" class="mw-redirect">Part F</a>&nbsp;- <a href="#G" title="Lambda G" class="mw-redirect">Part G</a>&nbsp;- <a href="#H" title="Lambda H" class="mw-redirect">Part H</a>&nbsp;- <a href="#J" title="Lambda J" class="mw-redirect">Part J</a>
<br />
Sections: <a href="#E15.27">15.27</a>&nbsp;- <a href="#E15.27.3">15.27.3</a>&nbsp;- <a href="#E15.27.4">15.27.4</a>&nbsp;- <a href="#E15.13">15.13</a>&nbsp;- <a href="#E15.13.1">15.13.1</a>&nbsp;- <a href="#E15.13.2">15.13.2</a>&nbsp;- <a href="#E15.13.3">15.13.3</a>&nbsp;- <a href="#E6.6.2.1">6.6.2.1</a>&nbsp;- <a href="#E6.6.2.2">6.6.2.2</a>&nbsp;- <a href="#E11.2.1">11.2.1</a>&nbsp;- <a href="#E11.2.3">11.2.3</a>&nbsp;- <a href="#E12.5">12.5</a>&nbsp;- <a href="#E13.1">13.1</a>&nbsp;- <a href="#E15.7.5">15.7.5</a>&nbsp;- <a href="#ESerialization">Serialization</a>
<br />
Version 0.9.3.  Copyright © 2014 Oracle America, Inc.  <a href="#Legal_Notice" title="Lambda Specification" class="mw-redirect">Legal Notice</a>.
</small>
</p>
<h3> <span class="mw-headline" id="Summary"> Summary </span></h3>
<p>Lambda expressions and method references are always poly expressions. It is a compile-time error if one of these occurs in a program in someplace other than an assignment context, an invocation context, or a casting context.
</p><p>The type of a lambda expression or method reference is a functional interface type, derived from its target type.  To be compatible with the target type, the expression must be <i>congruent</i> with the function type of this functional interface type.
</p><p>To test that a lambda expression is congruent, the function type's parameter and return types are compared to the expression.  The lambda parameter types (if given) must exactly match those of the function type, while the body must be assignment-compatible with the function type's return type.  The lambda's expression body (or each result expression of its block body) may be a poly expression.
</p><p>To test that a method reference is congruent, a <i>compile-time declaration</i> is determined following the process used for method <i>invocations</i>. The function type's parameter types are used as argument types in this search, where the first parameter type may sometimes act as the receiver for an instance method. The selected declaration's return type is then checked to be assignment-compatible with the function type's return type.
</p><p>For some method references, there is only one possible compile-time declaration with only one possible invocation type, regardless of the targeted function type. These are referred to as <i>exact method references</i>.
</p><p>In addition to the compatibility requirement, lambda bodies and referenced methods must not throw exceptions that are incompatible with the function type's <code style="background-color:inherit;font-size:medium">throws</code> clause.
</p><p>Evaluation of a lambda expression or method reference produces an instance of a functional interface.  Evaluation does not cause the execution of a lambda body or the invocation of a referenced method; instead, this may occur at a later time when an appropriate method of the interface is invoked.
</p><p>To evaluate the expression, either a new instance of an appropriate class is allocated and initialized, or an existing instance of an appropriate class is referenced.  The evaluation rules are minimally restrictive, thus allowing VMs freedom for optimization.  For example, a separate class need not be defined for each distinct expression, nor must a new object be allocated on every evaluation.
</p>
<div id="E15.27"></div>
<h3> <span class="mw-headline" id="15.27_Lambda_Expressions_.5BAddendum.5D"> 15.27 Lambda Expressions [Addendum] </span></h3>
<p><small>See <a href="#B15.27" title="Lambda B" class="mw-redirect">15.27</a></small>
</p><p><span class="norm-static">
Lambda expressions are always poly expressions (<a href="#D15.2" title="Lambda D" class="mw-redirect">15.2</a>).<span class="assertion-id"> [jsr335-15.27-10]</span></span>
</p><p><span class="norm-error">
It is a compile-time error if a lambda expression occurs in a program in someplace other than an assignment context (<a href="#D5.2" title="Lambda D" class="mw-redirect">5.2</a>), an invocation context (<a href="#D5.3" title="Lambda D" class="mw-redirect">5.3</a>), or a casting context (<a href="#D5.5" title="Lambda D" class="mw-redirect">5.5</a>).<span class="assertion-id"> [jsr335-15.27-20]</span></span>
</p><p>Evaluation of a lambda expression produces an instance of a functional interface (<a href="#A9.8" title="Lambda A" class="mw-redirect">9.8</a>).  Lambda expression evaluation does <i>not</i> cause the execution of the expression's body; instead, this may occur at a later time when an appropriate method of the functional interface is invoked.
</p>
<div id="E15.27.3"></div>
<h3> <span class="mw-headline" id="15.27.3_Type_of_a_Lambda_Expression_.5BNew.5D"> 15.27.3 Type of a Lambda Expression [New] </span></h3>
<p><span class="norm-static">
A lambda expression is compatible in an assignment, invocation, or casting context with type <em>T</em> if <em>T</em> is a functional interface type (<a href="#A9.8" title="Lambda A" class="mw-redirect">9.8</a>) and the expression is <i>congruent</i> with the function type of a <i>ground target type</i> derived from <em>T</em>.<span class="assertion-id"> [jsr335-15.27.3-15]</span></span>
</p><p><span class="norm-static">
If a lambda expression is compatible with its target type, <em>T</em>, then the type of the expression is the ground target type derived from <em>T</em>.<span class="assertion-id"> [jsr335-15.27.3-10]</span></span>
</p><p><span class="norm-static">
The <i>ground target type</i> is derived from <em>T</em> as follows:<span class="assertion-id"> [jsr335-15.27.3-20]</span></span>
</p>
<ul><li> <span class="norm-static"> If <em>T</em> is a wildcard-parameterized functional interface type and the lambda expression is explicitly-typed, then the ground target type is inferred as described in <a href="#G18.5.3" title="Lambda G" class="mw-redirect">18.5.3</a>.<span class="assertion-id"> [jsr335-15.27.3-20-A]</span></span>
</li><li> <span class="norm-static"> If <em>T</em> is a wildcard-parameterized functional interface type and the lambda expression is implicitly-typed, then the ground target type is the non-wildcard parameterization (<a href="#A9.8" title="Lambda A" class="mw-redirect">9.8</a>) of the target type.<span class="assertion-id"> [jsr335-15.27.3-20-F]</span></span>
</li><li> <span class="norm-static"> Otherwise, the ground target type is the target type.<span class="assertion-id"> [jsr335-15.27.3-20-E]</span></span>
</li></ul>
<p><span class="norm-static">
A lambda expression is <i>congruent</i> with a function type if all of the following are true:<span class="assertion-id"> [jsr335-15.27.3-30]</span></span>
</p>
<ul><li> <span class="norm-static"> The function type has no type parameters.  (The functional interface from which the function type is derived may, of course, have type parameters.)<span class="assertion-id"> [jsr335-15.27.3-30-H]</span></span>
</li><li> <span class="norm-static"> The number of lambda parameters is the same as the number of parameter types of the function type.<span class="assertion-id"> [jsr335-15.27.3-30-A]</span></span>
</li><li> <span class="norm-static"> If the lambda expression is explicitly-typed, its parameter types are the same as the parameter types of the function type.<span class="assertion-id"> [jsr335-15.27.3-30-B]</span></span>
</li><li> <span class="norm-static"> Where the lambda parameters are assumed to have the same types as the function type's parameter types:<span class="assertion-id"> [jsr335-15.27.3-30-G]</span></span>
<ul><li> <span class="norm-static"> If the function type's return type is <code style="background-color:inherit;font-size:medium">void</code>, then the lambda body is either a statement expression or a <code style="background-color:inherit;font-size:medium">void</code>-compatible block.<span class="assertion-id"> [jsr335-15.27.3-30-E]</span></span>
</li><li> <span class="norm-static">If the function type's return type is a (non-<code style="background-color:inherit;font-size:medium">void</code>) type <em>R</em>, then either i) the lambda body is an expression that is compatible with <em>R</em> in an assignment context, or ii) the lambda body is a value-compatible block, and each result expression is compatible with <em>R</em> in an assignment context.<span class="assertion-id"> [jsr335-15.27.3-30-F]</span></span>
</li></ul>
</li></ul>
<p><span class="norm-error"> Where <em>T'</em> is the type of the lambda expression, it is a compile-time error if any class or interface mentioned by either <em>T'</em> or the function type of <em>T'</em> is not accessible from the class or interface in which the lambda expression appears.<span class="assertion-id"> [jsr335-15.27.3-50]</span></span>
</p><p><span class="norm-error"> Where <em>T'</em> is the type of the lambda expression, for each non-<code style="background-color:inherit;font-size:medium">static</code> member method <em>m</em> of <em>T'</em>, if the function type of <em>T'</em> has a subsignature of the signature of <em>m</em>, then a notional method with the function type is said to override <em>m</em>, and any error or warning specified in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.8.3" class="external text" rel="nofollow">8.4.8.3</a> may occur.<span class="assertion-id"> [jsr335-15.27.3-55]</span></span>
</p><p>In addition, a checked exception that can be thrown in the body of the lambda may cause an error, as specified in <a href="#E11.2.3" title="Lambda E" class="mw-redirect">11.2.3</a>.
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div>
<p>There is some flexibility in the design of lambda expression compatibility: a well-formedness check may either occur as part of the definition, or as an extra check after compatibility is established.  Since overload resolution of explicitly-typed lambdas depends on compatibility but not subsequent checks (see <a href="#F" title="Lambda F" class="mw-redirect">Part F</a>), this distinction is important.  In one extreme, every check could be part of compatibility—in that case, subtle differences in, say, the exceptions thrown by the lambda body, could trigger different overloading choices.  In the other extreme, the expressions could always be "compatible," and then overload resolution would be entirely unable to distinguish between appropriate and inappropriate target types.
</p><p>The approach we've chosen is to check the parameter and return types, but <i>not</i> the <code style="background-color:inherit;font-size:medium">throws</code> clause.  We avoid exception checking for two reasons:
</p>
<ul><li> Exception checking is subtle, and the common practice is to refine <code style="background-color:inherit;font-size:medium">throws</code> clauses based on compiler feedback.  We would not want this "feedback" to take the form of subtle overload resolution changes (by making the lambda compatible with different sets of target types depending on the body's exceptions).
</li><li> Inference may influence the target type's <code style="background-color:inherit;font-size:medium">throws</code> clause and the exceptions thrown by result expressions in the body.  It is easiest to cope with these dependencies by avoiding exception checking until after overload resolution and inference are complete.
</li></ul>
<p>Matters are complicated further by implicitly-typed lambdas.  Hence, while the compatibility rules for implicitly-typed lambdas are the same, the compatibility check itself is almost entirely sidestepped by overload resolution (see <a href="#F" title="Lambda F" class="mw-redirect">Part F</a>).
</p>
</div></li>
<li style="margin-bottom:12px;"><div>
<p>We require the parameter types of explicitly-typed lambdas to exactly match those of the function type.  While it would be possible to be more flexible—allow boxing or contravariance, for example—this kind of generality seems unnecessary, and is inconsistent with the way overriding works in class declarations.  A programmer ought to know exactly what function type is being targeted when writing a lambda expression, so he should thus know exactly what signature must be overridden.  (In contrast, this is not the case for method references, and so more flexibility is allowed when they are used.)  In addition, more flexibility with parameter types would add to the complexity of type inference and overload resolution.
</p>
</div></li>
<li style="margin-bottom:12px;"><div>
<p>While boxing is not allowed in a strict invocation context, boxing of lambda result expressions is <i>always</i> allowed—that is, the result expression appears in an assignment context, regardless of the context enclosing the lambda expression.
</p><p>However, if an explicitly-typed lambda expression is an argument to an overloaded method, a method signature that avoids boxing or unboxing the lambda result is preferred by the most-specific check (<a href="#F15.12.2.5" title="Lambda F" class="mw-redirect">see 15.12.2.5</a>).
</p><p>Similarly, lambda returns are allowed to perform narrowing of constant expressions, as in all assignment contexts.
</p>
</div></li>
<li style="margin-bottom:12px;"><div>
<p>If the body of a lambda is a statement expression (that is, an expression that would be allowed to stand alone as a statement), it is compatible with a <code style="background-color:inherit;font-size:medium">void</code>-producing function type; any result is simply discarded.  So, for example, both of the following are legal:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
// Predicate has a boolean return
Predicate&lt;String&gt; p = s -&gt; list.add(s);
// Consumer has a void return
Consumer&lt;String&gt; c = s -&gt; list.add(s);
</pre>
<p>Generally speaking, a lambda of the form <em><code style="background-color:inherit;font-size:medium">() -&gt;</code> expr</em>, where <em>expr</em> is a statement expression, is interpreted as either <em><code style="background-color:inherit;font-size:medium">() -&gt; { return </code>expr<code style="background-color:inherit;font-size:medium">; }</code></em> or <em><code style="background-color:inherit;font-size:medium">() -&gt; { </code>expr<code style="background-color:inherit;font-size:medium">; }</code></em>, depending on the target type.
</p>
</div></li></ol></div></blockquote>
<div id="E15.27.4"></div>
<h3> <span class="mw-headline" id="15.27.4_Run-time_Evaluation_of_Lambda_Expressions_.5BNew.5D"> 15.27.4 Run-time Evaluation of Lambda Expressions [New] </span></h3>
<p><span class="norm-dynamic">
At run time, the evaluation of a lambda expression (distinct from execution of a lambda body) either produces a reference to an object of the targeted functional interface type or completes abruptly, as described below.<span class="assertion-id"> [jsr335-15.27.4-10]</span></span>
</p><p><span class="norm-dynamic">
The value of a lambda expression is a reference to an instance of a class with the following properties:<span class="assertion-id"> [jsr335-15.27.4-20]</span></span>
</p>
<ul><li> <span class="norm-dynamic"> The class implements the targeted functional interface and, if the target type is an intersection type, every other interface element of the intersection.<span class="assertion-id"> [jsr335-15.27.4-20-A]</span></span>
</li><li> <span class="norm-dynamic"> Where the lambda expression has type <em>T'</em>, for each non-<code style="background-color:inherit;font-size:medium">static</code> member method <em>m</em> of <em>T'</em>, if the function type of <em>T'</em> has a subsignature of the signature of <em>m</em>, then the class declares a method that overrides <em>m</em>.<span class="assertion-id"> [jsr335-15.27.4-20-B]</span></span>
</li><li> <span class="norm-dynamic"> Each method's body has the effect of evaluating the lambda body, if it is an expression, or of executing the lambda body, if it is a block; if a result is expected, it is returned from the method.<span class="assertion-id"> [jsr335-15.27.4-20-D]</span></span>
</li><li> <span class="norm-dynamic">  If the erasure of the type of a method being overridden differs in its signature from the erasure of the function type of <em>T'</em>, then before evaluating or executing the lambda body, the method body checks that each argument value is an instance of a subclass or subinterface of the erasure of the corresponding parameter type in the function type of <em>T'</em>; if not, a <code style="background-color:inherit;font-size:medium">ClassCastException</code> is thrown.<span class="assertion-id"> [jsr335-15.27.4-20-F]</span></span>
</li><li> <span class="norm-dynamic"> The class overrides no other methods of the interface or interfaces mentioned above, except that it may override methods of the <code style="background-color:inherit;font-size:medium">Object</code> class.<span class="assertion-id"> [jsr335-15.27.4-20-E]</span></span>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The rule describing when a <code style="background-color:inherit;font-size:medium">ClassCastException</code> occurs mimics <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4.5" class="external text" rel="nofollow">15.12.4.5</a>.</div></blockquote>
<p><span class="norm-dynamic">
To evaluate the lambda expression, either a new instance of an appropriate class is allocated and initialized, or an existing instance of an appropriate class is referenced.<span class="assertion-id"> [jsr335-15.27.4-30]</span></span>
</p><p>This implies that the behavior of an equality operator (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.21" class="external text" rel="nofollow">15.21</a>) is unpredictable when applied to the result of evaluation of a lambda expression: the equality test may produce different results in different implementations, or even upon different lambda expression evaluations in the same implementation.
</p><p><span class="norm-dynamic">
If a new instance is to be created, but there is insufficient space to allocate the object, evaluation of the lambda expression completes abruptly by throwing an <code style="background-color:inherit;font-size:medium">OutOfMemoryError</code> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.6" class="external text" rel="nofollow">15.9.6</a>).<span class="assertion-id"> [jsr335-15.27.4-40]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>This section was influenced by <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.4" class="external text" rel="nofollow">15.9.4</a> "Run-time Evaluation of Class Instance Creation Expressions."</div></blockquote>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> This section is meant to be minimally restrictive, thus allowing VMs freedom for optimization.  Some flexibility it provides:
<ul><li> A new object need not be allocated on every evaluation
</li><li> Objects produced by different lambda expressions need not belong to different classes (if the bodies are identical, for example)
</li><li> Every object produced by evaluation need not belong to the same class (captured local variables might be inlined, for example)
</li><li> If an "existing instance" is available, it need not have been created at a previous lambda evaluation (it might have been allocated during the enclosing class's initialization, for example).
</li></ul>
</div></li>
<li style="margin-bottom:12px;"><div> While it is outside the scope of the language specification to prescribe compiler behavior, it is expected that all compilers will encode lambda bodies as methods, typically of the enclosing class.  The evaluation behavior specified above will then be achieved via an <code style="background-color:inherit;font-size:medium">invokedynamic</code> instruction that mentions the compiled method and invokes a standard API.  The runtime library, independent of the compiler, provides the implementation of this API and is free to use whatever strategy it prefers to manage class and object creation.
</div></li>
<li style="margin-bottom:12px;"><div> If the targeted functional interface type is a subtype of <code style="background-color:inherit;font-size:medium">Serializable</code>, the resulting object will automatically be an instance of a serializable class.  Making an object derived from a lambda expression serializable can have extra runtime overhead and negative security implications, so we do not require <i>all</i> lambda-derived objects to be serializable.
<p>The standard API for lambda evaluation provides special support for serialization which is more robust than the automatic graph-traversal behavior, and which is supported across different VM implementations.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> It is expected that the lambda implementation class will typically override the <code style="background-color:inherit;font-size:medium">toString</code> method, since the implementation provided by <code style="background-color:inherit;font-size:medium">Object</code> is quite unhelpful—any useful information about the lambda expression, if the <code style="background-color:inherit;font-size:medium">Object</code> implementation were used, could only be deduced from the class's name.
</div></li></ol></div></blockquote>
<div id="E15.13"></div>
<h3> <span class="mw-headline" id="15.13_Method_Reference_Expressions_.5BAddendum.5D"> 15.13 Method Reference Expressions [Addendum] </span></h3>
<p><small>See <a href="#C15.13" title="Lambda C" class="mw-redirect">15.13</a></small>
</p><p><span class="norm-static">
Method reference expressions are always poly expressions (<a href="#D15.2" title="Lambda D" class="mw-redirect">15.2</a>).<span class="assertion-id"> [jsr335-15.28-10]</span></span>
</p><p><span class="norm-error">
It is a compile-time error if a method reference expression occurs in a program in someplace other than an assignment context (<a href="#D5.2" title="Lambda D" class="mw-redirect">5.2</a>), an invocation context (<a href="#D5.3" title="Lambda D" class="mw-redirect">5.3</a>), or a casting context (<a href="#D5.5" title="Lambda D" class="mw-redirect">5.5</a>).<span class="assertion-id"> [jsr335-15.28-20]</span></span>
</p><p>Evaluation of a method reference expression produces an instance of a functional interface (<a href="#A9.8" title="Lambda A" class="mw-redirect">9.8</a>).  Method reference evaluation does <i>not</i> cause the execution of the corresponding method; instead, this may occur at a later time when an appropriate method of the functional interface is invoked.
</p>
<div id="E15.13.1"></div>
<h3> <span class="mw-headline" id="15.13.1_Compile-Time_Declaration_of_a_Method_Reference_.5BNew.5D"> 15.13.1 Compile-Time Declaration of a Method Reference [New] </span></h3>
<p><span class="norm-static">
The <i>compile-time declaration</i> of a method reference is the method to which the expression refers.  In special cases, the compile-time declaration does not actually exist, but is a notional method that represents a class instance creation or an array creation.  The choice of compile-time declaration depends on a function type targeted by the expression (just as the compile-time declaration of a method invocation depends on the invocation's arguments (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">15.12</a>)).<span class="assertion-id"> [jsr335-15.28.1-40]</span></span>
</p><p><span class="norm-static">
The identification of a compile-time declaration mirrors the process for method invocations in <a href="#H15.12.1" title="Lambda H" class="mw-redirect">15.12.1</a> and <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2" class="external text" rel="nofollow">15.12.2</a>.<span class="assertion-id"> [jsr335-15.28.1-100]</span></span>
</p><p><span class="norm-static">
First, a type to search must be determined (compare <a href="#H15.12.1" title="Lambda H" class="mw-redirect">15.12.1</a>):<span class="assertion-id"> [jsr335-15.28.1-110]</span></span>
</p>
<ul><li> <span class="norm-static"> If the method reference has the form <em>ExpressionName <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em> or <em>Primary <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, the type to search is the type of the expression preceding the <code style="background-color:inherit;font-size:medium">::</code> token.<span class="assertion-id"> [jsr335-15.28.1-110-A]</span></span>
</li><li> <span class="norm-static"> If the method reference has the form <em><code style="background-color:inherit;font-size:medium">super</code> <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, the type to search is the superclass type of the class whose declaration contains the method reference.<span class="assertion-id"> [jsr335-15.28.1-110-B]</span></span>
</li><li> <span class="norm-static"> If the method reference has the form <em>TypeName <code style="background-color:inherit;font-size:medium">.</code> <code style="background-color:inherit;font-size:medium">super</code> <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, then if <em>TypeName</em> denotes a class, the type to search is the superclass type of the named class; otherwise, <em>TypeName</em> denotes an interface, and the corresponding superinterface type of the class or interface whose declaration contains the method reference is the type to search.<span class="assertion-id"> [jsr335-15.28.1-110-C]</span></span>
</li><li> <span class="norm-static"> If the method reference has the form <em>ReferenceType <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, the type to search is the result of capture conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.10" class="external text" rel="nofollow">5.1.10</a>) applied to the <em>ReferenceType</em>.<span class="assertion-id"> [jsr335-15.28.1-110-E]</span></span>
</li><li> <span class="norm-static"> For all other forms, the referenced method is notional and there is no type to search.<span class="assertion-id"> [jsr335-15.28.1-110-D]</span></span>
</li></ul>
<p><span class="norm-static">
Second, given a targeted function type with <em>n</em> parameters, a set of potentially-applicable methods is identified (compare <a href="#F15.12.2.1" title="Lambda F" class="mw-redirect">15.12.2.1</a>):<span class="assertion-id"> [jsr335-15.28.1-120]</span></span>
</p>
<ul><li> <span class="norm-static"> If the method reference has the form <em>ReferenceType <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, the potentially-applicable methods are the member methods of the type to search that have an appropriate name (given by <em>Identifier</em>), accessibility, arity (<em>n</em> or <em>n-1</em>), and type argument arity (derived from <em>NonWildTypeArguments<sub>opt</sub></em>), as described in <a href="#F15.12.2.1" title="Lambda F" class="mw-redirect">15.12.2.1</a>.  Two different arities, <em>n</em> and <em>n-1</em>, are considered, to account for the possibility that this form refers to either a <code style="background-color:inherit;font-size:medium">static</code> method or an instance method.<span class="assertion-id"> [jsr335-15.28.1-120-A]</span></span>
</li><li> <span class="norm-static"> If the method reference has the form <em>ClassType <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> <code style="background-color:inherit;font-size:medium">new</code></em>, the potentially-applicable methods are a set of notional methods corresponding to the constructors of <em>ClassType</em>.  If <em>ClassType</em> is a raw type, but is not a non-static member type of a raw type, the candidate notional member methods are those described in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.3" class="external text" rel="nofollow">15.9.3</a> for a class instance creation expression that uses <code style="background-color:inherit;font-size:medium">&lt;&gt;</code> to elide class type arguments.  Otherwise, the candidate notional member methods are the constructors of <em>ClassType</em>, treated as if they were methods with return type <em>ClassType</em>.  Among these candidates, the methods with appropriate accessibility, arity (<em>n</em>), and type argument arity (derived from <em>NonWildTypeArguments<sub>opt</sub></em>) are selected, as described in <a href="#F15.12.2.1" title="Lambda F" class="mw-redirect">15.12.2.1</a>.<span class="assertion-id"> [jsr335-15.28.1-120-B]</span></span>
</li><li> <span class="norm-static"> If the method reference has the form <em>ArrayType <code style="background-color:inherit;font-size:medium">::</code> <code style="background-color:inherit;font-size:medium">new</code></em>, a single notional method is considered.  The method has a single parameter of type <code style="background-color:inherit;font-size:medium">int</code>, returns the <em>ArrayType</em>, and has no <code style="background-color:inherit;font-size:medium">throws</code> clause.  If <em>n = 1</em>, this is the only potentially-applicable method; if not, there are no potentially-applicable methods.<span class="assertion-id"> [jsr335-15.28.1-120-C]</span></span>
</li><li> <span class="norm-static"> For all other forms, the potentially-applicable methods are the member methods of the type to search that have an appropriate name (given by <em>Identifier</em>), accessibility, arity (<em>n</em>), and type argument arity (derived from <em>NonWildTypeArguments<sub>opt</sub></em>), as described in <a href="#F15.12.2.1" title="Lambda F" class="mw-redirect">15.12.2.1</a>.<span class="assertion-id"> [jsr335-15.28.1-120-D]</span></span>
</li></ul>
<p><span class="norm-static">
If there are no potentially-applicable methods, then the method reference does not have a compile-time declaration.<span class="assertion-id"> [jsr335-15.28.1-125]</span></span>
</p><p><span class="norm-static">
Finally, given a targeted function type with parameter types <em>P<sub>1</sub>..P<sub>n</sub></em> and a set of potentially-applicable methods, the compile-time declaration is selected, according to the process in <a href="#F15.12.2.2" title="Lambda F" class="mw-redirect">15.12.2.2</a>-<a href="#F15.12.2.5" title="Lambda F" class="mw-redirect">15.12.2.5</a>, with the following clarifications:<span class="assertion-id"> [jsr335-15.28.1-130]</span></span>
</p>
<ul><li> <span class="norm-static"> If the method reference has the form <em>ReferenceType <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, then two searches for a most-specific applicable method are performed.  Each search may produce a method or, in the case of an error as specified in <a href="#F15.12.2.2" title="Lambda F" class="mw-redirect">15.12.2.2</a>-<a href="#F15.12.2.5" title="Lambda F" class="mw-redirect">15.12.2.5</a>, no result.<span class="assertion-id"> [jsr335-15.28.1-45]</span></span><p><span class="norm-static"> In the first search, the reference is treated as if it were an invocation with argument expressions of types <em>P<sub>1</sub>..P<sub>n</sub></em>; the type arguments, if any, are given by the method reference.<span class="assertion-id"> [jsr335-15.28.1-45-A]</span></span></p><p><span class="norm-static"> In the second search, if <em>P<sub>1</sub>..P<sub>n</sub></em> is not empty and <em>P<sub>1</sub></em> is a subtype of <em>ReferenceType</em>, the reference is treated as if it were an invocation with argument expressions of types <em>P<sub>2</sub>..P<sub>n</sub></em>.  If the <em>ReferenceType</em> is a raw type, and there exists a parameterization of this type, <em>T</em>, that is a supertype of <em>P<sub>1</sub></em>, the type to search is the result of capture conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.10" class="external text" rel="nofollow">5.1.10</a>) applied to <em>T</em>; otherwise, the type to search is the same as the type of the first search.  Again, the type arguments, if any, are given by the method reference.<span class="assertion-id"> [jsr335-15.28.1-45-B]</span></span></p><p><span class="norm-static">If the first search produces a <code style="background-color:inherit;font-size:medium">static</code> method, and no non-<code style="background-color:inherit;font-size:medium">static</code> method is applicable for the second search, then the result of the first search is the compile-time declaration.<span class="assertion-id"> [jsr335-15.28.1-45-F]</span></span></p><p><span class="norm-static">If the second search produces a non-<code style="background-color:inherit;font-size:medium">static</code> method, and no <code style="background-color:inherit;font-size:medium">static</code> method is applicable for the first search, then the result of the second search is the compile-time declaration.<span class="assertion-id"> [jsr335-15.28.1-45-G]</span></span></p><p><span class="norm-static">If neither of the above is true, there is no compile-time declaration.<span class="assertion-id"> [jsr335-15.28.1-45-H]</span></span></p>
</li><li> <span class="norm-static"> For all other forms, the invocation's argument types are <em>P<sub>1</sub>...P<sub>n</sub></em>, and the type arguments (if any) are given by the method reference.  If the search results in an error, as specified in <a href="#F15.12.2.2" title="Lambda F" class="mw-redirect">15.12.2.2</a>-<a href="#F15.12.2.5" title="Lambda F" class="mw-redirect">15.12.2.5</a>, or if the chosen method is declared <code style="background-color:inherit;font-size:medium">static</code>, there is no compile-time declaration.  Otherwise, the compile-time declaration is the most-specific applicable method.<span class="assertion-id"> [jsr335-15.28.1-46]</span></span>
</li></ul>
<p>For some method references, there is only one possible compile-time declaration with only one possible invocation type (<a href="#F15.12.2.6" title="Lambda F" class="mw-redirect">15.12.2.6</a>), regardless of the targeted function type.  These are referred to as <i>exact method references</i>.
</p><p><span class="norm-static">
Specifically, a method reference ending in an <em>Identifier</em> is <i>exact</i> if it satisfies all of the following:<span class="assertion-id"> [jsr335-15.28.1-200]</span></span>
</p>
<ul><li> <span class="norm-static"> If the method reference has the form <em>ReferenceType <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, the <em>ReferenceType</em> is not a raw type.<span class="assertion-id"> [jsr335-15.28.1-200-D]</span></span>
</li><li> <span class="norm-static"> The type to search has exactly one member method with the name <em>Identifier</em> that is accessible (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6" class="external text" rel="nofollow">6.6</a>) to the class or interface in which the method reference appears.<span class="assertion-id"> [jsr335-15.28.1-200-A]</span></span>
</li><li> <span class="norm-static"> This method is not a variable-arity method (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1" class="external text" rel="nofollow">8.4.1</a>).<span class="assertion-id"> [jsr335-15.28.1-200-B]</span></span>
</li><li> <span class="norm-static"> If this method is generic (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.4" class="external text" rel="nofollow">8.4.4</a>), then the method reference provides <em>NonWildTypeArguments</em>.<span class="assertion-id"> [jsr335-15.28.1-200-C]</span></span>
</li></ul>
<p><span class="norm-static">
A method reference of the form <em>ClassType <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> <code style="background-color:inherit;font-size:medium">new</code></em> is <i>exact</i> if it satisfies all of the following:<span class="assertion-id"> [jsr335-15.28.1-210]</span></span>
</p>
<ul><li> <span class="norm-static"> The <em>ClassType</em> is not a raw type, or is a non-<code style="background-color:inherit;font-size:medium">static</code> member type of a raw type.<span class="assertion-id"> [jsr335-15.28.1-210-D]</span></span>
</li><li> <span class="norm-static"> The <em>ClassType</em> has exactly one constructor that is accessible (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6" class="external text" rel="nofollow">6.6</a>) to the class or interface in which the method reference appears.<span class="assertion-id"> [jsr335-15.28.1-210-A]</span></span>
</li><li> <span class="norm-static"> This constructor is not a variable-arity constructor.<span class="assertion-id"> [jsr335-15.28.1-210-B]</span></span>
</li><li> <span class="norm-static"> If this constructor is generic (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8.4" class="external text" rel="nofollow">8.8.4</a>), then the method reference provides <em>NonWildTypeArguments</em>.<span class="assertion-id"> [jsr335-15.28.1-210-C]</span></span>
</li></ul>
<p><span class="norm-static">
A method reference of the form <em>ArrayType <code style="background-color:inherit;font-size:medium">::</code> <code style="background-color:inherit;font-size:medium">new</code></em> is always <i>exact</i>.<span class="assertion-id"> [jsr335-15.28.1-220]</span></span>
</p><p><span class="norm-static">
A method reference that is not <i>exact</i> is referred to as <i>inexact</i>.<span class="assertion-id"> [jsr335-15.28.1-250]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> 
<p>Method references of the form <em>ReferenceType <code style="background-color:inherit;font-size:medium">::</code> id</em> can be interpreted in different ways.  It is ambiguous whether the identifier refers to a static method or an instance method; in the latter case, the implicit lambda expression has an extra parameter.  It's possible, of course, for both kinds of applicable methods to exist, and the search for an applicable method via <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2" class="external text" rel="nofollow">15.12.2</a> must identify them separately, since there are different parameter types for each case.
</p><p>An example of ambiguity:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
interface Fun&lt;T,R&gt; { R apply(T arg); }

class C {
  int size() { return 3; }
  static int size(C arg) { return arg.size(); }

  void test() {
    Fun&lt;C, Integer&gt; f1 = C::size; // error: c.size() or C.size(c)?
  }
}
</pre>
<p>The search is smart enough to ignore potential ambiguities in which all the candidate methods of one arity have mismatched "staticness":
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
interface Fun&lt;T,R&gt; { R apply(T arg); }

class C {
  int size() { return 3; }
  int size(Object arg) { return 0; }
  int size(C arg) { return arg.size(); }

  void test() {
    Fun&lt;C, Integer&gt; f1 = C::size; // no error: must be c.size()
  }
}
</pre>
<p>But when an applicable candidate with mismatched staticness is more specific than an applicable candidate <i>at the same arity</i> with correct staticness, the mismatched method will not be ignored.
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
interface Fun&lt;T,R&gt; { R apply(T arg); }

class C {
  int size() { return 3; }
  static int size(Object arg) { return 0; }
  int size(C arg) { return arg.size(); }

  void test() {
    Fun&lt;C, Integer&gt; f1 = C::size; // error: c.size() or C.size(c)?
  }
}
</pre>
</div></li>
<li style="margin-bottom:12px;"><div>
<p>For convenience, when a generic type is used to refer to an instance method (where the receiver becomes the first parameter), the target type can used to determine the type arguments.  This facilitates usage like <code style="background-color:inherit;font-size:medium">Pair::first</code> in place of <code style="background-color:inherit;font-size:medium">Pair&lt;String,Integer&gt;::first</code>.
</p><p>Similarly, a method reference like <code style="background-color:inherit;font-size:medium">Pair::new</code> is treated like a "diamond" instance creation (<code style="background-color:inherit;font-size:medium">new Pair&lt;&gt;()</code>).  There is no need for the <code style="background-color:inherit;font-size:medium">&lt;&gt;</code> syntax here; in fact, it is not allowed by the grammar.  Note that this form does <i>not</i> instantiate a raw type, and there is no way to express a reference to a raw type constructor—this is because the raw instance creation would almost never be more useful than its inferred-parameters counterpart.
</p>
</div></li></ol></div></blockquote>
<div id="E15.13.2"></div>
<h3> <span class="mw-headline" id="15.13.2_Type_of_a_Method_Reference_.5BNew.5D"> 15.13.2 Type of a Method Reference [New] </span></h3>
<p><span class="norm-static">
A method reference expression is compatible in an assignment, invocation, or casting context with type <em>T</em> if <em>T</em> is a functional interface type (<a href="#A9.8" title="Lambda A" class="mw-redirect">9.8</a>) and the expression is <i>congruent</i> with the function type of a <i>ground target type</i> derived from <em>T</em>.<span class="assertion-id"> [jsr335-15.28.1-15]</span></span>
</p><p><span class="norm-static">
If a method reference expression is compatible with its target type, <em>T</em>, then the type of the expression is the ground target type derived from <em>T</em>.<span class="assertion-id"> [jsr335-15.28.1-10]</span></span>
</p><p><span class="norm-static">
The <i>ground target type</i> is derived from <em>T</em> as follows:<span class="assertion-id"> [jsr335-15.28.1-18]</span></span>
</p>
<ul><li> <span class="norm-static"> If the target type is a wildcard-parameterized functional interface type, then the ground target type is the non-wildcard parameterization (<a href="#A9.8" title="Lambda A" class="mw-redirect">9.8</a>) of the target type.<span class="assertion-id"> [jsr335-15.28.1-18-A]</span></span>
</li><li> <span class="norm-static"> Otherwise, the ground target type is the target type.<span class="assertion-id"> [jsr335-15.28.1-18-B]</span></span>
</li></ul>
<p><span class="norm-static">
A method reference is <i>congruent</i> with a function type if the following are true:<span class="assertion-id"> [jsr335-15.28.1-30]</span></span>
</p>
<ul><li> <span class="norm-static"> The function type identifies a single compile-time declaration corresponding to the reference.<span class="assertion-id"> [jsr335-15.28.1-30-A]</span></span>
</li><li> <span class="norm-static"> One of the following is true:<span class="assertion-id"> [jsr335-15.28.1-30-B]</span></span>
<ul><li> <span class="norm-static"> The return type of the function type is <code style="background-color:inherit;font-size:medium">void</code>.<span class="assertion-id"> [jsr335-15.28.1-30-B1]</span></span>
</li><li> <span class="norm-static"> The return type of the function type is <em>R</em>; the result of applying capture conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.10" class="external text" rel="nofollow">5.1.10</a>) to the return type of the invocation type (<a href="#F15.12.2.6" title="Lambda F" class="mw-redirect">15.12.2.6</a>) of the chosen declaration is <em>R'</em>, where <em>R</em> is the target type that may be used to infer <em>R'</em>; neither <em>R</em> nor <em>R'</em> is <code style="background-color:inherit;font-size:medium">void</code>; and <em>R'</em> is compatible with <em>R</em> in an assignment context.<span class="assertion-id"> [jsr335-15.28.1-30-B2]</span></span>
</li></ul>
</li></ul>
<p><span class="norm-error">
A compile-time unchecked warning occurs if unchecked conversion was necessary for the compile-time declaration to be applicable and, per <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.9" class="external text" rel="nofollow">5.1.9</a>, this conversion would cause an unchecked warning in an invocation context.<span class="assertion-id"> [jsr335-15.28.1-40]</span></span>
</p><p><span class="norm-error">
A compile-time unchecked warning occurs if unchecked conversion was necessary for the return type <em>R'</em>, described above, to be compatible with the function type's return type, <em>R</em>, and, per <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.9" class="external text" rel="nofollow">5.1.9</a>, this conversion would cause an unchecked warning in an assignment context.<span class="assertion-id"> [jsr335-15.28.1-41]</span></span>
</p><p><span class="norm-error"> For each checked exception that is listed in the <code style="background-color:inherit;font-size:medium">throws</code> clause of the invocation type of the compile-time declaration, a compile-time error occurs unless that exception type or a supertype of that exception type is mentioned in the <code style="background-color:inherit;font-size:medium">throws</code> clause of the target type's function type.<span class="assertion-id"> [jsr335-15.28.1-60]</span></span>
</p><p><span class="norm-error"> Where <em>T'</em> is the type of the method reference, it is a compile-time error if any class or interface mentioned by either <em>T'</em> or the function type of <em>T'</em> is not accessible from the class or interface in which the method reference appears.<span class="assertion-id"> [jsr335-15.28.1-70]</span></span>
</p><p><span class="norm-error"> Where <em>T'</em> is the type of the method reference, for each non-<code style="background-color:inherit;font-size:medium">static</code> member method <em>m</em> of <em>T'</em>, if the function type of <em>T'</em> has a subsignature of the signature of <em>m</em>, then a notional method with the function type is said to override <em>m</em>, and any error or warning specified in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.8.3" class="external text" rel="nofollow">8.4.8.3</a> may occur.<span class="assertion-id"> [jsr335-15.28.1-75]</span></span>
</p><p><span class="norm-error"> It is a compile-time error if the method reference is of the form <em>ReferenceType <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, and the compile-time declaration is <code style="background-color:inherit;font-size:medium">static</code>, but <em>ReferenceType</em> is not expressed as a simple or qualified name (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.2" class="external text" rel="nofollow">6.2</a>).<span class="assertion-id"> [jsr335-15.28.1-80]</span></span>
</p><p><span class="norm-error"> It is a compile-time error if the method reference is of the form <em><code style="background-color:inherit;font-size:medium">super</code> <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em> and the compile-time declaration is <code style="background-color:inherit;font-size:medium">abstract</code>.<span class="assertion-id"> [jsr335-15.28.1-90]</span></span>
</p><p><span class="norm-error"> It is a compile-time error if the method reference is of the form <em>TypeName <code style="background-color:inherit;font-size:medium">.</code> <code style="background-color:inherit;font-size:medium">super</code> <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, and either of the following are true:<span class="assertion-id"> [jsr335-15.28.1-91]</span></span>
</p>
<ul><li> <span class="norm-error"> The compile-time declaration is <code style="background-color:inherit;font-size:medium">abstract</code>.<span class="assertion-id"> [jsr335-15.28.1-91-A]</span></span>
</li><li> <span class="norm-error"> The <em>TypeName</em> denotes an interface and, where <em>C</em> is the type declaration immediately enclosing the method reference, there exists a method, distinct from the compile-time declaration, that overrides (<a href="#G9.4.1" title="Lambda G" class="mw-redirect">9.4.1</a>) the compile-time declaration from a direct superinterface of <em>C</em>.<span class="assertion-id"> [jsr335-15.28.1-91-B]</span></span>
</li></ul>
<p><span class="norm-error"> It is a compile-time error if the method reference is of the form <em>ClassType <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> <code style="background-color:inherit;font-size:medium">new</code></em> and an error would occur when determining an enclosing instance for a <em>ClassType</em>, as described in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.2" class="external text" rel="nofollow">15.9.2</a> (treating the method reference as if it were a class instance creation expression).<span class="assertion-id"> [jsr335-15.28.1-95]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>Parts of this section mimic <a href="#E15.27.3" title="Lambda E" class="mw-redirect">15.27.3</a>.</div></blockquote>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> The key idea driving this compatibility definition is that a method reference is compatible if and only if the equivalent lambda expression <code style="background-color:inherit;font-size:medium">(x, y, z) -&gt; exp.&lt;T1, T2&gt;method(x, y, z)</code> is compatible.  (This is informal, and there are issues that make it difficult or impossible to formally define the semantics in terms of such a rewrite.)
</div></li>
<li style="margin-bottom:12px;"><div> 
<p>Note that static method invocations have the form <em>TypeName<code style="background-color:inherit;font-size:medium">.</code>method<code style="background-color:inherit;font-size:medium">()</code></em>, while the method reference syntax uses the more general <em>ReferenceType</em>; an error occurs if the referenced method ends up being <code style="background-color:inherit;font-size:medium">static</code> and the qualifier is a parameterized type.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> These compatibility rules provide a convenient facility for converting from one functional interface to another:
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
Task t = () -&gt; System.out.println(&quot;hi&quot;);
Runnable r = t::invoke;
</pre>
<p>The implementation may be optimized so that when a lambda-derived object is passed around and converted to various types, this does not result in many levels of adaptation logic around the core lambda body.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> Unlike a lambda expression, a method reference can be congruent with a generic function type (that is, a function type that has type parameters).  This is because the lambda expression would need to be able to declare type parameters, and no syntax supports this; while for a method reference, no such declaration is necessary.
<p>For example, the following program is legal:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
interface ListFactory { &lt;T&gt; List&lt;T&gt; make(); }
ListFactory arrayListFactory = ArrayList::new;
List&lt;String&gt; ls = arrayListFactory.make();
List&lt;Number&gt; ln = arrayListFactory.make();
</pre>
</div></li></ol></div></blockquote>
<div id="E15.13.3"></div>
<h3> <span class="mw-headline" id="15.13.3_Run-time_Evaluation_of_Method_References_.5BNew.5D"> 15.13.3 Run-time Evaluation of Method References [New] </span></h3>
<p><span class="norm-dynamic">
At run time, the evaluation of a method reference (distinct from invocation of the method itself) either produces a reference to an object of the targeted functional interface type or completes abruptly, as described below.<span class="assertion-id"> [jsr335-15.28.2-10]</span></span>
</p><p><span class="norm-dynamic">
The value of a method reference is a reference to an instance of a class with the following properties:<span class="assertion-id"> [jsr335-15.28.2-20]</span></span>
</p>
<ul><li> <span class="norm-dynamic"> The class implements the targeted functional interface and, if the target type is an intersection type, every other interface mentioned in the intersection.<span class="assertion-id"> [jsr335-15.28.2-20-A]</span></span>
</li><li> <span class="norm-dynamic"> Where the method reference expression has type <em>T'</em>, for each non-<code style="background-color:inherit;font-size:medium">static</code> member method <em>m</em> of <em>T'</em>, if the function type of <em>T'</em> has a subsignature of the signature of <em>m</em>, then the class declares an <i>invocation method</i> that overrides <em>m</em>.<span class="assertion-id"> [jsr335-15.28.2-20-B]</span></span>
</li><li> <span class="norm-dynamic"> Each invocation method's body invokes the referenced method, creates a class instance, or creates an array instance, as described below.<span class="assertion-id"> [jsr335-15.28.2-20-D]</span></span>
</li><li> <span class="norm-dynamic"> If the erasure of the type of a method being overridden differs in its signature from the erasure of the function type of <em>T'</em>, then before the method invocation or instance creation, an invocation method body checks that each argument value is an instance of a subclass or subinterface of the erasure of the corresponding parameter type in the function type of <em>T'</em>; if not, a <code style="background-color:inherit;font-size:medium">ClassCastException</code> is thrown.<span class="assertion-id"> [jsr335-15.28.2-20-G]</span></span>
</li><li> <span class="norm-dynamic"> If an invocation method's return type is not <code style="background-color:inherit;font-size:medium">void</code>, then the body returns the result of the method invocation or object instantiation, after any necessary assignment conversions (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.2" class="external text" rel="nofollow">5.2</a>).<span class="assertion-id"> [jsr335-15.28.2-20-E]</span></span>
</li><li> <span class="norm-dynamic"> The class overrides no other methods of the interface or interfaces mentioned above, except that it may override methods of the <code style="background-color:inherit;font-size:medium">Object</code> class.<span class="assertion-id"> [jsr335-15.28.2-20-F]</span></span>
</li></ul>
<p><span class="norm-dynamic">
If the method reference has the form <em>ExpressionName <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em> or <em>Primary <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, the body of the invocation method has the effect of invoking the compile-time declaration of the method reference, as described in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4.3" class="external text" rel="nofollow">15.12.4.3</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4.4" class="external text" rel="nofollow">15.12.4.4</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4.5" class="external text" rel="nofollow">15.12.4.5</a>.<span class="assertion-id"> [jsr335-15.28.2-41]</span></span>
</p>
<ul><li> <span class="norm-dynamic"> The invocation mode is derived from the compile-time declaration as described in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.3" class="external text" rel="nofollow">15.12.3</a>.<span class="assertion-id"> [jsr335-15.28.2-41-A]</span></span>
</li><li> <span class="norm-dynamic"> The target reference is the value of the <em>ExpressionName</em> or <em>Primary</em>, as determined <i>at the time</i> the method reference was evaluated.<span class="assertion-id"> [jsr335-15.28.2-41-B]</span></span>
</li><li> <span class="norm-dynamic"> The invocation arguments are the parameters of the invocation method.<span class="assertion-id"> [jsr335-15.28.2-41-C]</span></span>
</li></ul>
<p><span class="norm-dynamic">
If the method reference has the form <em><code style="background-color:inherit;font-size:medium">super</code> <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em> or <em>TypeName <code style="background-color:inherit;font-size:medium">.</code> <code style="background-color:inherit;font-size:medium">super</code> <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, the body of the invocation method similarly has the effect of invoking the compile-time declaration of the method reference, as described in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4.3" class="external text" rel="nofollow">15.12.4.3</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4.4" class="external text" rel="nofollow">15.12.4.4</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4.5" class="external text" rel="nofollow">15.12.4.5</a>.<span class="assertion-id"> [jsr335-15.28.2-42]</span></span>
</p>
<ul><li> <span class="norm-dynamic"> The invocation mode is <code style="background-color:inherit;font-size:medium">super</code>.<span class="assertion-id"> [jsr335-15.28.2-42-A]</span></span>
</li><li> <span class="norm-dynamic"> If the method reference begins with a <em>TypeName</em> that names a class, the target reference is the value of <em>TypeName <code style="background-color:inherit;font-size:medium">.</code> <code style="background-color:inherit;font-size:medium">this</code></em> at the point at which the method reference is evaluated.  Otherwise, the target reference is the value of <code style="background-color:inherit;font-size:medium">this</code> at the point at which the method reference is evaluated.<span class="assertion-id"> [jsr335-15.28.2-42-B]</span></span>
</li><li> <span class="norm-dynamic"> The invocation arguments are the parameters of the invocation method.<span class="assertion-id"> [jsr335-15.28.2-42-C]</span></span>
</li></ul>
<p><span class="norm-dynamic">
If the method reference has the form <em>ReferenceType <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, the body of the invocation method similarly has the effect of invoking the compile-time declaration of the method reference, as described in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4.3" class="external text" rel="nofollow">15.12.4.3</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4.4" class="external text" rel="nofollow">15.12.4.4</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4.5" class="external text" rel="nofollow">15.12.4.5</a>.<span class="assertion-id"> [jsr335-15.28.2-43]</span></span>
</p>
<ul><li> <span class="norm-dynamic"> The invocation mode is derived from the compile-time declaration as described in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.3" class="external text" rel="nofollow">15.12.3</a>.<span class="assertion-id"> [jsr335-15.28.2-43-A]</span></span>
</li><li> <span class="norm-dynamic"> If the compile-time declaration is an instance method, then the target reference is the first parameter of the invocation method.  Otherwise, there is no target reference.<span class="assertion-id"> [jsr335-15.28.2-43-B]</span></span>
</li><li> <span class="norm-dynamic"> If the compile-time declaration is an instance method, then the invocation arguments (if any) are the second and subsequent parameters of the invocation method.  Otherwise, the invocation arguments are the parameters of the invocation method.<span class="assertion-id"> [jsr335-15.28.2-43-C]</span></span>
</li></ul>
<p><span class="norm-dynamic">
If the method reference has the form <em>ClassType <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> <code style="background-color:inherit;font-size:medium">new</code></em>, the body of the invocation method has the same effect as a class instance creation expression of the form <em><code style="background-color:inherit;font-size:medium">new</code> NonWildTypeArguments<sub>opt</sub> ClassType(param<sub>1</sub>, ..., param<sub>n</sub>)</em> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.4" class="external text" rel="nofollow">15.9.4</a>), where <em>param<sub>1</sub>, ..., param<sub>n</sub></em> are the parameters of the invocation method.<span class="assertion-id"> [jsr335-15.28.2-50]</span></span>
</p>
<ul><li> <span class="norm-dynamic"> The enclosing instance for the new object, if any, is derived from the site of the method reference, as described in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.2" class="external text" rel="nofollow">15.9.2</a>.<span class="assertion-id"> [jsr335-15.28.2-50-A]</span></span>
</li><li> <span class="norm-dynamic"> The constructor to invoke is the constructor that corresponds to the compile-time declaration of the method reference (<a href="#E15.13.1" title="Lambda E" class="mw-redirect">15.13.1</a>).<span class="assertion-id"> [jsr335-15.28.2-50-B]</span></span>
</li></ul>
<p><span class="norm-dynamic">
If the method reference has the form, for some <em>k ≥ 1</em>, <em>Type <code style="background-color:inherit;font-size:medium">[]</code><sup>k</sup> <code style="background-color:inherit;font-size:medium">::</code> <code style="background-color:inherit;font-size:medium">new</code></em>, the body of the invocation method has the same effect as an array creation expression of the form <em><code style="background-color:inherit;font-size:medium">new</code> Type <code style="background-color:inherit;font-size:medium">[</code> size <code style="background-color:inherit;font-size:medium">]</code> <code style="background-color:inherit;font-size:medium">[]</code><sup>k-1</sup></em>, where <em>size</em> is the invocation method's single <code style="background-color:inherit;font-size:medium">int</code>-valued parameter.  (The notation <em><code style="background-color:inherit;font-size:medium">[]</code><sup>k</sup></em> indicates a sequence of <em>k</em> bracket pairs.)<span class="assertion-id"> [jsr335-15.28.2-52]</span></span>
</p><p><span class="norm-dynamic">
In any case, if the compile-time declaration of the method reference is signature polymorphic (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.3" class="external text" rel="nofollow">15.12.3</a>), then:<span class="assertion-id"> [jsr335-15.28.2-60]</span></span>
</p>
<ul><li> <span class="norm-dynamic"> The types of the parameters for the invocation are the types of the corresponding arguments.<span class="assertion-id"> [jsr335-15.28.2-60-A]</span></span>
</li><li> <span class="norm-dynamic"> The result type is <code style="background-color:inherit;font-size:medium">void</code> if the invocation method's return type is <code style="background-color:inherit;font-size:medium">void</code>, and <code style="background-color:inherit;font-size:medium">Object</code> otherwise.<span class="assertion-id"> [jsr335-15.28.2-60-B]</span></span>
</li></ul>
<p><span class="norm-dynamic"> To evaluate the method reference, the following steps are taken:<span class="assertion-id"> [jsr335-15.28.2-30]</span></span>
</p>
<ul><li> <span class="norm-dynamic"> If the expression is a method reference that begins with an <em>ExpressionName</em> or a <em>Primary</em>, this subexpression is first evaluated.<span class="assertion-id"> [jsr335-15.28.2-30-A]</span></span><p><span class="norm-dynamic"> If the subexpression evaluation completes abruptly, then the method reference evaluation completes abruptly for the same reason.<span class="assertion-id"> [jsr335-15.28.2-30-A1]</span></span></p><p> <span class="norm-dynamic"> If the result of evaluation of the subexpression is <code style="background-color:inherit;font-size:medium">null</code>, then a <code style="background-color:inherit;font-size:medium">NullPointerException</code> is thrown.<span class="assertion-id"> [jsr335-15.28.2-30-A2]</span></span></p>
</li><li> <span class="norm-dynamic">Next, either a new instance of an appropriate class is allocated and initialized, or an existing instance of an appropriate class is referenced.<span class="assertion-id"> [jsr335-15.28.2-30-B]</span></span><p>This implies that the behavior of an equality operator (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.21" class="external text" rel="nofollow">15.21</a>) is unpredictable when applied to the result of evaluation of a method reference: the equality test may produce different results in different implementations, or even upon different method reference evaluations in the same implementation.</p><p><span class="norm-dynamic">If a new instance is to be created, but there is insufficient space to allocate the object, evaluation of the method reference completes abruptly by throwing an <code style="background-color:inherit;font-size:medium">OutOfMemoryError</code> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.6" class="external text" rel="nofollow">15.9.6</a>).<span class="assertion-id"> [jsr335-15.28.2-30-B1]</span></span></p>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>This section borrows heavily <a href="#E15.27.4" title="Lambda E" class="mw-redirect">15.27.4</a>, above.  The rules for invocation also reproduce, in simplified form, some of <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4" class="external text" rel="nofollow">15.12.4</a>.</div></blockquote>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> The timing of method reference evaluation is a little more complex than that of lambda expressions: when a method reference is qualified with an expression (rather than a type), the expression is evaluated <i>immediately</i>.  The result of evaluation is then stored until the functional interface's method is invoked; at that point, the value is used as the target reference for the invocation.  This means that the portion of the method reference preceding the <code style="background-color:inherit;font-size:medium">::</code> delimiter is only evaluated when the program encounters the method reference; subsequent invocations of the functional interface do not re-evaluate the subexpression.
</div></li>
<li style="margin-bottom:12px;"><div> It is useful to contrast the treatment of <code style="background-color:inherit;font-size:medium">null</code> here with its treatment for a method <i>invocation</i>.  When a method invocation is evaluated, it is possible for the <em>Primary</em> that qualifies the invocation to produce <code style="background-color:inherit;font-size:medium">null</code>, but for no <code style="background-color:inherit;font-size:medium">NullPointerException</code> to occur.  This occurs when the invoked method is <code style="background-color:inherit;font-size:medium">static</code> (despite the syntax of the invocation suggesting an instance method).  Since we explicitly prohibit a matched method for this kind of method <i>reference</i> from being <code style="background-color:inherit;font-size:medium">static</code> (<a href="#E15.13.1" title="Lambda E" class="mw-redirect">15.13.1</a>), the evaluation behavior described here is simpler—a <code style="background-color:inherit;font-size:medium">null</code> primary always triggers a <code style="background-color:inherit;font-size:medium">NullPointerException</code>.
</div></li>
<li style="margin-bottom:12px;"><div> As was the case for lambda expression evaluation, it is outside the scope of the language specification to prescribe compiler behavior, but it is expected that all compilers will generate an <code style="background-color:inherit;font-size:medium">invokevirtual</code> instruction that delegates to a standard API the wrapping of a referenced method as an instance of a particular interface.
</div></li></ol></div></blockquote>
<div id="E6.6.2.1"></div>
<h3> <span class="mw-headline" id="6.6.2.1_Access_to_a_protected_Member_.5BModified.5D"> 6.6.2.1 Access to a <code style="background-color:inherit;font-size:medium">protected</code> Member [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6.2.1" class="external text" rel="nofollow">JLS 6.6.2.1</a></small>
</p><p><span class="norm-static">
Let <em>C</em> be the class in which a <code style="background-color:inherit;font-size:medium">protected</code> member is declared.  Access is permitted only within the body of a subclass <em>S</em> of <em>C</em>.<span class="assertion-id"> [jls-6.6.2.1-100]</span></span>
</p><p><span class="norm-static">
In addition, if <em>Id</em> denotes an instance field or instance method, then:<span class="assertion-id"> [jls-6.6.2.1-110]</span></span>
</p>
<ul><li> <span class="norm-static"> If the access is by a qualified name <em>Q <code style="background-color:inherit;font-size:medium">.</code> Id</em>, <u>or by a method reference expression <em>Q <code style="background-color:inherit;font-size:medium">::</code> Id</em>,</u> where <em>Q</em> is an <em>ExpressionName</em>, then the access is permitted if and only if the type of the expression <em>Q</em> is <em>S</em> or a subclass of <em>S</em>.<span class="assertion-id"> [jls-6.6.2.1-110-A]</span></span>
</li><li> <span class="norm-static"> If the access is by a field access expression <em>E <code style="background-color:inherit;font-size:medium">.</code> Id</em>, <del>where <em>E</em> is a <em>Primary</em> expression,</del> or by a method invocation expression <em>E <code style="background-color:inherit;font-size:medium">.</code> Id <code style="background-color:inherit;font-size:medium">(</code> .. <code style="background-color:inherit;font-size:medium">)</code></em>, <u>or by a method reference expression, <em>E <code style="background-color:inherit;font-size:medium">::</code> Id</em>,</u> where <em>E</em> is a <em>Primary</em> expression, then the access is permitted if and only if the type of <em>E</em> is <em>S</em> or a subclass of <em>S</em>.<span class="assertion-id"> [jls-6.6.2.1-110-B]</span></span>
</li><li> <span class="norm-static"> <u>If the access is by a method reference expression <em>T <code style="background-color:inherit;font-size:medium">::</code> Id</em>, where <em>T</em> is a <em>ReferenceType</em>, then the access is permitted if and only if the type <em>T</em> is <em>S</em> or a subclass of <em>S</em>.</u><span class="assertion-id"> [jsr335-6.6.2.1-110-C]</span></span>
</li></ul>
<p>...
</p>
<div id="E6.6.2.2"></div>
<h3> <span class="mw-headline" id="6.6.2.2_Qualified_Access_to_a_protected_Constructor_.5BModified.5D"> 6.6.2.2 Qualified Access to a <code style="background-color:inherit;font-size:medium">protected</code> Constructor [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6.2.2" class="external text" rel="nofollow">JLS 6.6.2.2</a></small>
</p><p><span class="norm-static">
Let <em>C</em> be the class in which a <code style="background-color:inherit;font-size:medium">protected</code> constructor is declared and let <em>S</em> be the innermost class in whose declaration the use of the <code style="background-color:inherit;font-size:medium">protected</code> constructor occurs.  Then:<span class="assertion-id"> [ jls-6.6.2.2-100]</span></span>
</p>
<ul><li> <span class="norm-static"> If the access is by a superclass constructor invocation <code style="background-color:inherit;font-size:medium">super(...)</code> or by a qualified superclass constructor invocation of the form <em>E <code style="background-color:inherit;font-size:medium">.</code> <code style="background-color:inherit;font-size:medium">super</code> <code style="background-color:inherit;font-size:medium">(</code> ... <code style="background-color:inherit;font-size:medium">)</code></em>, where <em>E</em> is a <em>Primary</em> expression, then the access is permitted.<span class="assertion-id"> [jls-6.6.2.2-100-A]</span></span>
</li><li> <span class="norm-static"> If the access is by an anonymous class instance creation expression of the form <em><code style="background-color:inherit;font-size:medium">new</code> C <code style="background-color:inherit;font-size:medium">(</code> ... <code style="background-color:inherit;font-size:medium">)</code> <code style="background-color:inherit;font-size:medium">{</code>...<code style="background-color:inherit;font-size:medium">}</code></em>, or by a qualified class instance creation expression of the form <em>E <code style="background-color:inherit;font-size:medium">.</code> <code style="background-color:inherit;font-size:medium">new</code> C <code style="background-color:inherit;font-size:medium">(</code> ... <code style="background-color:inherit;font-size:medium">)</code> <code style="background-color:inherit;font-size:medium">{</code>...<code style="background-color:inherit;font-size:medium">}</code></em>, where <em>E</em> is a <em>Primary</em> expression, then the access is permitted.<span class="assertion-id"> [jls-6.6.2.2-100-B]</span></span>
</li><li> <span class="norm-static"> Otherwise, if the access is by a simple class instance creation expression of the form <em><code style="background-color:inherit;font-size:medium">new</code> C <code style="background-color:inherit;font-size:medium">(</code> ... <code style="background-color:inherit;font-size:medium">)</code></em>, or by a qualified class instance creation expression of the form <em>E <code style="background-color:inherit;font-size:medium">.</code> <code style="background-color:inherit;font-size:medium">new</code> C <code style="background-color:inherit;font-size:medium">(</code> ... <code style="background-color:inherit;font-size:medium">)</code></em>, where <em>E</em> is a <em>Primary</em> expression, <u>or by a method reference expression of the form <em>C <code style="background-color:inherit;font-size:medium">::</code> <code style="background-color:inherit;font-size:medium">new</code></em>, where <em>C</em> is a <em>ClassType</em>,</u> then the access is not permitted.<span class="assertion-id"> [jls-6.6.2.2-100-C]</span></span>
</li></ul>
<p><span class="norm-static">
A <code style="background-color:inherit;font-size:medium">protected</code> constructor can be accessed by a class instance creation expression (that does not declare an anonymous class) <u>or a method reference expression</u> only from within the package in which it is defined.<span class="assertion-id"> [jls-6.6.2.2-100-C.1]</span></span>
</p>
<div id="E11.2.1"></div>
<h3> <span class="mw-headline" id="11.2.1_Exception_Analysis_of_Expressions_.5BModified.5D"> 11.2.1 Exception Analysis of Expressions [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-11.html#jls-11.2.1" class="external text" rel="nofollow">JLS 11.2.1</a></small>
</p><p><span class="norm-static">
A class instance creation expression (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9" class="external text" rel="nofollow">15.9</a>) can throw an exception class <em>E</em> iff ...<span class="assertion-id"> [jls-11.2.1-100]</span></span>
</p><p><span class="norm-static">
A method invocation expression (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">15.12</a>) can throw an exception class <em>E</em> iff ...<span class="assertion-id"> [jls-11.2.1-110]</span></span>
</p><p><span class="norm-static">
<u>A lambda expression (<a href="#B15.27" title="Lambda B" class="mw-redirect">15.27</a>) can throw no exception types.</u><span class="assertion-id"> [jsr335-11.2.1-120]</span></span>
</p><p><span class="norm-static">
For every other kind of expression, the expression can throw an exception type <em>E</em> iff one of its immediate subexpressions can throw <em>E</em>.<span class="assertion-id"> [jls-11.2.1-200]</span></span>
</p>
<div id="E11.2.3"></div>
<h3> <span class="mw-headline" id="11.2.3_Exception_Checking_.5BModified.5D"> 11.2.3 Exception Checking [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-11.html#jls-11.2.3" class="external text" rel="nofollow">JLS 11.2.3</a></small>
</p><p><span class="norm-error">
It is a compile-time error if a method or constructor body <i>can throw</i> some exception class <em>E</em> when <em>E</em> is a checked exception class and <em>E</em> is not a subclass of some class declared in the <code style="background-color:inherit;font-size:medium">throws</code> clause of the method or constructor.<span class="assertion-id"> [jls-11.2.3-100]</span></span>
</p><p><span class="norm-error">
<u>It is a compile-time error if a lambda body <i>can throw</i> some exception class <em>E</em> when <em>E</em> is a checked exception class and <em>E</em> is not a subclass of some class declared in the <code style="background-color:inherit;font-size:medium">throws</code> clause of the function type targeted by the lambda expression.</u><span class="assertion-id"> [jsr335-11.2.3-105]</span></span>
</p><p><span class="norm-error">
It is a compile-time error if a class variable initializer (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.2" class="external text" rel="nofollow">8.3.2</a>) or static initializer (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.7" class="external text" rel="nofollow">8.7</a>) of a named class or interface <i>can throw</i> a checked exception class.<span class="assertion-id"> [jls-11.2.3-110]</span></span>
</p><p><span class="norm-error">
It is a compile-time error if an instance variable initializer or instance initializer of a named class <i>can throw</i> a checked exception class unless that exception class or one of its superclasses is explicitly declared in the <code style="background-color:inherit;font-size:medium">throws</code> clause of each constructor of its class and the class has at least one explicitly declared constructor.<span class="assertion-id"> [jls-11.2.3-120]</span></span>
</p><p>...
</p><p><span class="norm-error">
It is a compile-time error if a <code style="background-color:inherit;font-size:medium">catch</code> clause <i>can catch</i> checked exception class <em>E<sub>1</sub></em> and it is not the case that the <code style="background-color:inherit;font-size:medium">try</code> block corresponding to the <code style="background-color:inherit;font-size:medium">catch</code> clause <i>can throw</i> a checked exception class that is a subclass or superclass of <em>E<sub>1</sub></em>, unless <em>E<sub>1</sub></em> is <code style="background-color:inherit;font-size:medium">Exception</code> or a superclass of <code style="background-color:inherit;font-size:medium">Exception</code>.<span class="assertion-id"> [jls-11.2.3-200]</span></span>
</p><p><span class="norm-error">
It is a compile-time error if a <code style="background-color:inherit;font-size:medium">catch</code> clause <i>can catch</i> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-11.html#jls-11.2" class="external text" rel="nofollow">11.2</a>) checked exception class <em>E<sub>1</sub></em> and a preceding <code style="background-color:inherit;font-size:medium">catch</code> clause of the immediately enclosing <code style="background-color:inherit;font-size:medium">try</code> statement <i>can catch</i> <em>E<sub>1</sub></em> or a superclass of <em>E<sub>1</sub></em>.<span class="assertion-id"> [jls-11.2.3-210]</span></span>
</p><p>...
</p>
<div id="E12.5"></div>
<h3> <span class="mw-headline" id="12.5_Creation_of_New_Class_Instances_.5BModified.5D"> 12.5 Creation of New Class Instances [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.5" class="external text" rel="nofollow">JLS 12.5</a></small>
</p><p>A new class instance may be implicitly created in the following situations:
</p>
<ul><li> Loading of a class or interface that contains a String literal ...
</li><li> Execution of an operation that causes boxing conversion ...
</li><li> Execution of a string concatenation operator ...
</li><li> <u>Evaluation of a lambda expression (<a href="#E15.27.4" title="Lambda E" class="mw-redirect">15.27.4</a>) or a method reference (<a href="#E15.13.2" title="Lambda E" class="mw-redirect">15.13.2</a>) may require that a new instance of a class that implements a functional interface type be created.</u>
</li></ul>
<div id="E13.1"></div>
<h3> <span class="mw-headline" id="13.1_Creation_of_New_Class_Instances_.5BModified.5D"> 13.1 Creation of New Class Instances [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html#jls-13.1" class="external text" rel="nofollow">JLS 13.1</a></small>
</p><p>...
</p><p><span class="norm-static">
Given a method invocation expression <u>or a method reference expression (<a href="#C15.13" title="Lambda C" class="mw-redirect">15.13</a>)</u> in a class or interface <em>C</em> referencing a method named <em>m</em> declared (or implicitly declared (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.2" class="external text" rel="nofollow">9.2</a>)) in a (possibly distinct) class or interface <em>D</em>, we define the <i>qualifying type of the method invocation</i> as follows:<span class="assertion-id"> [jls-13.1-110-E]</span></span>
</p>
<ul><li> <span class="norm-static"> If <em>D</em> is <code style="background-color:inherit;font-size:medium">Object</code> then the qualifying type of the expression is <code style="background-color:inherit;font-size:medium">Object</code>.<span class="assertion-id"> [jls-13.1-110-E-A]</span></span>
</li><li> <span class="norm-static"> Otherwise:<span class="assertion-id"> [jls-13.1-110-E-B]</span></span>
<ul><li> <span class="norm-static"> If the method is referenced by a simple name, ...<span class="assertion-id"> [jls-13.1-110-E-B-A]</span></span>
</li><li> <span class="norm-static"> If the <del>reference</del> <u>expression</u> is of the form <del><em>X<code style="background-color:inherit;font-size:medium">.</code>m</em>, where <em>X</em> denotes a class or interface</del> <u><em>TypeName<code style="background-color:inherit;font-size:medium">.</code>m</em> or <em>ReferenceType<code style="background-color:inherit;font-size:medium">::</code>m</em>,</u> then the <del>class or interface</del> <u>type</u> denoted by <del><em>X</em></del> <u><em>TypeName</em> or <em>ReferenceType</em></u> is the qualifying type of the method invocation.<span class="assertion-id"> [jls-13.1-110-E-B-B]</span></span>
</li><li> <span class="norm-static"> If the expression is of the form <u><em>ExpressionName<code style="background-color:inherit;font-size:medium">.</code>m</em></u>, <em>Primary<code style="background-color:inherit;font-size:medium">.</code>m</em>, <u><em>ExpressionName<code style="background-color:inherit;font-size:medium">::</code>m</em>, or <em>Primary<code style="background-color:inherit;font-size:medium">::</code>m</em></u>, then:<span class="assertion-id"> [jls-13.1-110-E-B-C]</span></span>
<ul><li> <span class="norm-static"> If the compile-time type of <em>Primary</em> <u>or <em>ExpressionName</em></u> is an intersection type ...<span class="assertion-id"> [jls-13.1-110-E-B-C-A]</span></span>
</li><li> <span class="norm-static"> Otherwise, the compile-time type of <em>Primary</em> <u>or <em>ExpressionName</em></u> is the qualifying type of the method invocation.<span class="assertion-id"> [jls-13.1-110-E-B-C-B]</span></span>
</li></ul>
</li><li> <span class="norm-static"> If the expression is of the form <em><code style="background-color:inherit;font-size:medium">super</code><code style="background-color:inherit;font-size:medium">.</code>m</em> <u>or <code style="background-color:inherit;font-size:medium">super</code><code style="background-color:inherit;font-size:medium">::</code>m</u>, then: ...<span class="assertion-id"> [jls-13.1-110-E-B-D]</span></span>
</li><li> <span class="norm-static"> If the expression is of the form <em>X<code style="background-color:inherit;font-size:medium">.</code><code style="background-color:inherit;font-size:medium">super</code><code style="background-color:inherit;font-size:medium">.</code>m</em> <u>or <em>X<code style="background-color:inherit;font-size:medium">.</code><code style="background-color:inherit;font-size:medium">super</code><code style="background-color:inherit;font-size:medium">::</code>m</em></u>, then <u>if <em>X</em> is a class</u>, the superclass of <em>X</em> is the qualifying type of the method invocation; <u>if <em>X</em> is an interface, the named superinterface of <em>C</em> is the qualifying type of the method invocation.</u><span class="assertion-id"> [jls-13.1-110-E-B-E]</span></span>
</li></ul>
</li></ul>
<p>...
</p><p><span class="norm-static">
Given a class instance creation expression (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9" class="external text" rel="nofollow">15.9</a>), <del>or</del> a constructor invocation statement (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8.7.1" class="external text" rel="nofollow">8.8.7.1</a>), <u>or a method reference of the form <em>ClassType<code style="background-color:inherit;font-size:medium">::</code><code style="background-color:inherit;font-size:medium">new</code></em></u> in a class or interface <em>C</em> referencing a constructor <em>m</em> declared in a (possibly distinct) class or interface <em>D</em>, we define the qualifying type of the constructor invocation as follows:<span class="assertion-id"> [jls-13.1-110-F]</span></span>
</p>
<ul><li> <span class="norm-static"> If the expression is of the form <em><code style="background-color:inherit;font-size:medium">new</code> D<code style="background-color:inherit;font-size:medium">(</code>...<code style="background-color:inherit;font-size:medium">)</code></em>, <del>or</del> <em>X<code style="background-color:inherit;font-size:medium">.</code><code style="background-color:inherit;font-size:medium">new</code> D<code style="background-color:inherit;font-size:medium">(</code>...<code style="background-color:inherit;font-size:medium">)</code></em>, <u>or <em>D<code style="background-color:inherit;font-size:medium">::</code><code style="background-color:inherit;font-size:medium">new</code></em>,</u> then the qualifying type of the invocation is <em>D</em>.<span class="assertion-id"> [jls-13.1-110-F-A]</span></span>
</li></ul>
<p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
These changes simply indicate that the compiled form of a method reference must include the equivalent method or constructor invocation.  We also account for the changes to <code style="background-color:inherit;font-size:medium">super</code> method invocation syntax described in Part H (<a href="#H15.12" title="Lambda H" class="mw-redirect">15.12</a>).</div></blockquote>
<div id="E15.7.5"></div>
<h3> <span class="mw-headline" id="15.7.5_Evaluation_Order_for_Other_Expressions_.5BModified.5D"> 15.7.5 Evaluation Order for Other Expressions [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.7.5" class="external text" rel="nofollow">JLS 15.7.5</a></small>
</p><p>The order of evaluation for some expressions is not completely covered by these general rules, because these expressions may raise exceptional conditions at times that must be specified.  See the detailed explanations of evaluation order for the following kinds of expressions:
</p>
<ul><li> class instance creation expressions (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.4" class="external text" rel="nofollow">15.9.4</a>)
</li><li> array creation expressions (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.10.1" class="external text" rel="nofollow">15.10.1</a>)
</li><li> method invocation expressions (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4" class="external text" rel="nofollow">15.12.4</a>)
</li><li> array access expressions (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.13.1" class="external text" rel="nofollow">15.13.1</a>)
</li><li> assignments involving array components (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.26" class="external text" rel="nofollow">15.26</a>)
</li><li> <u>lambda expressions (<a href="#E15.27.4" title="Lambda E" class="mw-redirect">15.27.4</a>)</u>
</li><li> <u>method reference expressions (<a href="#E15.13.3" title="Lambda E" class="mw-redirect">15.13.3</a>)</u>
</li></ul>
<div id="ESerialization"></div>
<h3> <span class="mw-headline" id="Serialization_Specification_.5BAddendum.5D"> Serialization Specification [Addendum] </span></h3>
<p><small>See <a href="http://docs.oracle.com/javase/7/docs/platform/serialization/spec/serialTOC.html" class="external text" rel="nofollow">Java Object Serialization Specification</a></small>
</p><p>As with inner classes, serialization of lambda expressions is strongly discouraged.  Names of synthetic methods generated by javac (or other Java compilers) to implement lambda expressions are implementation-dependent, may vary between compilers, and may change due to unrelated modifications in the same source file; differences in such names can disrupt compatibility.  Lambda expressions may refer to values from the enclosing scope; when the lambda expressions are serialized, these values will be serialized as well.  The order in which values from the enclosing scope are captured is implementation-dependent, may vary between compilers, and any modification of the source file containing the lambda expression may change this capture order, affecting deserialization correctness.  Lambda expressions cannot use field- or method-based mechanisms to control their serialized form.  If serializable lambdas are used, to minimize compatibility risks, it is recommended that class files identical to those that were present at serialization time be present at deserialization time.
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div> This paragraph is to be added to <a href="http://docs.oracle.com/javase/7/docs/platform/serialization/spec/serial-arch.html#4539" class="external text" rel="nofollow">section 1.10</a> of the Java Object Serialization Specification.  It parallels a similar discussion about inner classes.
</div></blockquote>



<a id="top"></a>
	
	<a id="F"/><h1 id="firstHeading" class="firstHeading">Lambda Specification, Part F: Overload Resolution</h1>
									<p><small>
Navigation: <a href="#overview" title="Lambda Specification" class="mw-redirect">Overview</a>&nbsp;- <a href="#A" title="Lambda A" class="mw-redirect">Part A</a>&nbsp;- <a href="#B" title="Lambda B" class="mw-redirect">Part B</a>&nbsp;- <a href="#C" title="Lambda C" class="mw-redirect">Part C</a>&nbsp;- <a href="#D" title="Lambda D" class="mw-redirect">Part D</a>&nbsp;- <a href="#E" title="Lambda E" class="mw-redirect">Part E</a>&nbsp;- <a href="#F" title="Lambda F" class="mw-redirect">Part F</a>&nbsp;- <a href="#G" title="Lambda G" class="mw-redirect">Part G</a>&nbsp;- <a href="#H" title="Lambda H" class="mw-redirect">Part H</a>&nbsp;- <a href="#J" title="Lambda J" class="mw-redirect">Part J</a>
<br />
Sections: <a href="#F15.12.2">15.12.2</a>&nbsp;- <a href="#F15.12.2.1">15.12.2.1</a>&nbsp;- <a href="#F15.12.2.2">15.12.2.2</a>&nbsp;- <a href="#F15.12.2.3">15.12.2.3</a>&nbsp;- <a href="#F15.12.2.4">15.12.2.4</a>&nbsp;- <a href="#F15.12.2.5">15.12.2.5</a>&nbsp;- <a href="#F15.12.2.6">15.12.2.6</a>&nbsp;- <a href="#F15.12.3">15.12.3</a>&nbsp;- <a href="#F15.9.3">15.9.3</a>
<br />
Version 0.9.3.  Copyright © 2014 Oracle America, Inc.  <a href="#Legal_Notice" title="Lambda Specification" class="mw-redirect">Legal Notice</a>.
</small>
</p>
<h3> <span class="mw-headline" id="Summary"> Summary </span></h3>
<p>Method and constructor declarations can be overloaded, meaning multiple matching declarations with different parameter types can co-exist in a type.  In order to interpret a method invocation or a class instance creation expression, the compiler performs "overload resolution," inferring the declaration intended by the user at a particular invocation site.  This occurs in three steps: i) identifying <i>potentially applicable methods</i>, that is, methods of the appropriate shape; ii) performing type analysis to identify <i>applicable methods</i> for the given arguments; iii) among the applicable methods, choosing one that is <i>most specific</i>.
</p><p>To accomodate lambda expressions, the definition of potential applicability is expanded to take into account both the arity of the candidate methods and the presence and "shape" of functional interface target types.
</p><p>To check for applicability, the types of an invocation's arguments can no longer, in general, be inputs to the analysis.  This is because:
</p>
<ul><li> The arguments to a method invocation may be poly expressions
</li><li> Poly expressions cannot be typed in the absence of a target type
</li><li> Overload resolution has to be completed before the arguments' target types will be known
</li></ul>
<p>Instead, the input to the applicability check is a list of argument <i>expressions</i>, which <i>can</i> be checked for compatibility with potential target types, even if the ultimate types of the expressions are unknown.
</p><p>The meaning of an implicitly-typed lambda expression or an inexact method reference is sufficiently vague prior to resolving a target type that arguments containing these expressions are not considered <i>pertinent to applicability</i>; they are simply ignored (except for their expected arity) until overload resolution is finished.
</p><p>The Java 7 most-specific analysis was defined as a pairwise comparison of method declarations via subtyping.  Here, we augment the analysis so that, where the corresponding argument is an explicitly-typed lambda expression or an exact method reference, one functional interface type can be preferred over another if it has a "better" function type return type, by a variety of measures: subtyping, boxing, or <code style="background-color:inherit;font-size:medium">void</code> vs. non-<code style="background-color:inherit;font-size:medium">void</code>.
</p>
<div id="F15.12.2"></div>
<h3> <span class="mw-headline" id="15.12.2_Compile-Time_Step_2:_Determine_Method_Signature_.5BModified.5D"> 15.12.2 Compile-Time Step 2: Determine Method Signature [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2" class="external text" rel="nofollow">JLS 15.12.2</a></small>
</p><p>The second step searches the type determined in the previous step for member methods.  This step uses the name of the method and <u>the argument expressions</u> to locate methods that are both <i>accessible</i> and <i>applicable</i>, that is, declarations that can be correctly invoked on the given arguments.
</p><p>There may be more than one such method, in which case the <i>most specific</i> one is chosen.  The descriptor (signature plus return type) of the most specific method is <u>the</u> one used at run time to perform the method dispatch.
</p><p><span class="norm-static">
A method is <i>applicable</i> if it is <del>either</del> applicable by <u>one of strict invocation</u> (<a href="#F15.12.2.2" title="Lambda F" class="mw-redirect">15.12.2.2</a>), <del>applicable by</del> <u>loose invocation</u> (<a href="#F15.12.2.3" title="Lambda F" class="mw-redirect">15.12.2.3</a>), or <del>it is an applicable</del> variable arity <del>method</del> <u>invocation</u> (<a href="#F15.12.2.4" title="Lambda F" class="mw-redirect">15.12.2.4</a>).<span class="assertion-id"> [jls-15.12.2-120]</span></span>
</p><p><u>Certain argument expressions that contain implicitly-typed lambda expressions (<a href="#B15.27.1" title="Lambda B" class="mw-redirect">15.27.1</a>) or inexact method references (<a href="#E15.13.1" title="Lambda E" class="mw-redirect">15.13.1</a>) are ignored by the applicability tests, because their meaning cannot be determined until a target type is selected.</u>
</p><p><u>Although the method invocation may be a poly expression, only its argument expressions—<i>not</i> the invocation's target type—influence the selection of applicable methods.</u>
</p><p>...
</p><p>Deciding whether a method is applicable will, in the case of generic methods (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.4" class="external text" rel="nofollow">8.4.4</a>), require <u>an analysis of the type arguments</u>.  Type arguments may be passed explicitly or implicitly.  If they are passed implicitly, <u>bounds on the type arguments</u> must be inferred <u>(<a href="#G18" title="Lambda G" class="mw-redirect">18</a>)</u> from <del>the types of</del> the argument expressions.
</p><p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div>
<p>To check for applicability, the types of an invocation's arguments can no longer, in general, be inputs to the analysis.  This is because:
</p>
<ul><li> The arguments to a method invocation may be poly expressions
</li><li> Poly expressions cannot be typed in the absence of a target type
</li><li> Overload resolution has to be completed before the arguments' target types will be known
</li></ul>
<p>Instead, the input to the applicability check is a list of argument expressions, which <i>can</i> be checked for compatibility with potential target types, even if the ultimate types of the expressions are unknown.
</p>
</div></li>
<li style="margin-bottom:12px;"><div>
<p>Overload resolution is independent of a target type for two reasons:
</p>
<ul><li> First, it makes the user model more accessible and less error-prone.  The meaning of a method name (i.e., the declaration corresponding to the name) is too fundamental to the meaning of a program to depend on subtle contextual hints.  (In contrast, other poly expressions may have different behavior depending on a target type; but the variation in behavior is always limited and essentially equivalent, while no such guarantees can be made about the behavior of an arbitrary set of methods that share a name and arity.)
</li><li> Second, it allows other properties—such as whether or not the method is a poly expression (<a href="#D15.12" title="Lambda D" class="mw-redirect">15.12</a>) or how to categorize a conditional (<a href="#D15.25" title="Lambda D" class="mw-redirect">15.25</a>)—to depend on the meaning of the method name, even before a target type is known.
</li></ul>
</div></li></ol></div></blockquote>
<div id="F15.12.2.1"></div>
<h3> <span class="mw-headline" id="15.12.2.1_Identify_Potentially_Applicable_Methods_.5BModified.5D"> 15.12.2.1 Identify Potentially Applicable Methods [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.1" class="external text" rel="nofollow">JLS 15.12.2.1</a></small>
</p><p>...
</p><p><span class="norm-static">
A member method is <i>potentially applicable</i> to a method invocation if and only if all of the following are true:<span class="assertion-id"> [jls-15.12.2.1-200]</span></span>
</p>
<ul><li> <span class="norm-static"> The name of the member is identical to the name of the method in the method invocation.<span class="assertion-id"> [jls-15.12.2.1-200-A]</span></span>
</li><li> <span class="norm-static"> The member is accessible (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6" class="external text" rel="nofollow">6.6</a>) to the class or interface in which the method invocation appears.<span class="assertion-id"> [jls-15.12.2.1-200-B]</span></span><p>Whether a member method is accessible at a method invocation depends on the access modifier (<code style="background-color:inherit;font-size:medium">public</code>, none, <code style="background-color:inherit;font-size:medium">protected</code>, or <code style="background-color:inherit;font-size:medium">private</code>) in the member's declaration and on where the method invocation appears.</p>
</li><li> <span class="norm-static"> If the member is a fixed arity method with arity <em>n</em>, the arity of the method invocation is equal to <em>n</em>, <u>and for all <em>i</em>, <em>1 ≤ i ≤ n</em>, the <em>i</em>th argument of the method invocation is <i>potentially compatible</i>, as defined below, with the type of the <em>i</em>th parameter of the method.</u><span class="assertion-id"> [jls-15.12.2.1-200-D]</span></span>
</li><li> <span class="norm-static"> If the member is a variable arity method with arity <em>n</em>, <u>then for all <em>i</em>, <em>1 ≤ i ≤ n-1</em>, the <em>i</em>th argument of the method invocation is <i>potentially compatible</i> with the type of the <em>i</em>th parameter of the method; and, where the <em>n</em>th parameter of the method has type <em>T<code style="background-color:inherit;font-size:medium">[]</code></em>, one of the following is true:</u><span class="assertion-id"> [jls-15.12.2.1-200-C]</span></span>
<ul><li> <span class="norm-static"> <u>The arity of the method invocation is equal to <em>n-1</em>.</u><span class="assertion-id"> [jsr335-15.12.2.1-200-C1]</span></span>
</li><li> <span class="norm-static"> <u>The arity of the method invocation is equal to <em>n</em>, and the <em>n</em>th argument of the method invocation is potentially compatible with either <em>T</em> or <em>T<code style="background-color:inherit;font-size:medium">[]</code></em>.</u><span class="assertion-id"> [jsr335-15.12.2.1-200-C2]</span></span>
</li><li> <span class="norm-static"> <u>The arity of the method invocation is <em>m</em>, where <em>m &gt; n</em>, and for all <em>i</em>, <em>n ≤ i ≤ m</em>, the <em>i</em>th argument of the method invocation is potentially compatible with <em>T</em>.</u><span class="assertion-id"> [jsr335-15.12.2.1-200-C3]</span></span>
</li></ul>
</li><li> <span class="norm-static"> If the method invocation includes explicit type arguments, and the member is a generic method, then the number of type arguments is equal to the number of type parameters of the method.<span class="assertion-id"> [jls-15.12.2.1-200-E]</span></span>
</li></ul>
<p>...
</p><p><span class="norm-static">
<u>An expression is <i>potentially compatible</i> with a target type according to the following rules:</u><span class="assertion-id"> [jsr335-15.12.2.1-10]</span></span>
</p>
<ul><li> <span class="norm-static"> <u>A lambda expression (<a href="#B15.27" title="Lambda B" class="mw-redirect">15.27</a>) is potentially compatible with a functional interface type (<a href="#A9.8" title="Lambda A" class="mw-redirect">9.8</a>) if all of the following are true:</u><span class="assertion-id"> [jsr335-15.12.2.1-10-A]</span></span>
<ul><li> <span class="norm-static"> <u>The arity of the targeted type's function type is the same as the arity of the lambda expression.</u><span class="assertion-id"> [jsr335-15.12.2.1-10-A1]</span></span>
</li><li> <span class="norm-static"> <u>If the targeted type's function type has a <code style="background-color:inherit;font-size:medium">void</code> return, then the lambda body is either a statement expression (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.8" class="external text" rel="nofollow">14.8</a>) or a void-compatible block (<a href="#B15.27.2" title="Lambda B" class="mw-redirect">15.27.2</a>).</u><span class="assertion-id"> [jsr335-15.12.2.1-10-A2]</span></span>
</li><li> <span class="norm-static"> <u>If the targeted type's function type has a (non-<code style="background-color:inherit;font-size:medium">void</code>) return type, then the lambda body is either an expression or a value-compatible block (<a href="#B15.27.2" title="Lambda B" class="mw-redirect">15.27.2</a>).</u><span class="assertion-id"> [jsr335-15.12.2.1-10-A3]</span></span>
</li></ul>
</li><li> <span class="norm-static"> <u>A method reference (<a href="#B15.13" title="Lambda B" class="mw-redirect">15.13</a>) is potentially compatible with a functional interface type if, where the type's function type arity is <em>n</em>, there exists at least one potentially-applicable method for the method reference at arity <em>n</em> (<a href="#B15.13.1" title="Lambda B" class="mw-redirect">15.13.1</a>), and one of the following is true:</u><span class="assertion-id"> [jsr335-15.12.2.1-10-B]</span></span>
<ul><li> <span class="norm-static"> <u>The method reference has the form <em>ReferenceType <code style="background-color:inherit;font-size:medium">::</code> NonWildTypeArguments<sub>opt</sub> Identifier</em> and at least one potentially-applicable method either i) is declared <code style="background-color:inherit;font-size:medium">static</code> and supports arity <em>n</em>, or ii) is <i>not</i> declared <code style="background-color:inherit;font-size:medium">static</code> and supports arity <em>n-1</em>.</u><span class="assertion-id"> [jsr335-15.12.2.1-10-B1]</span></span>
</li><li> <span class="norm-static"> <u>The method reference has some other form and at least one potentially-applicable method is <i>not</i> declared <code style="background-color:inherit;font-size:medium">static</code>.</u><span class="assertion-id"> [jsr335-15.12.2.1-10-B2]</span></span>
</li></ul>
</li><li> <span class="norm-static"> <u>A lambda expression or a method reference is potentially compatible with a type variable if the type variable is a type parameter of the candidate method.</u><span class="assertion-id"> [jsr335-15.12.2.1-10-C]</span></span>
</li><li> <span class="norm-static"> <u>A parenthesized expression (<a href="#D15.8.5" title="Lambda D" class="mw-redirect">15.8.5</a>) is potentially compatible with a type if its contained expression is potentially compatible with that type.</u><span class="assertion-id"> [jsr335-15.12.2.1-10-D]</span></span>
</li><li> <span class="norm-static"> <u>A conditional expression (<a href="#D15.25" title="Lambda D" class="mw-redirect">15.25</a>) is potentially compatible with a type if each of its second and third operand expressions are potentially compatible with that type.</u><span class="assertion-id"> [jsr335-15.12.2.1-10-E]</span></span>
</li><li> <span class="norm-static"> <u>A class instance creation expression (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9" class="external text" rel="nofollow">15.9</a>), a method invocation expression, or an expression of a standalone form (<a href="#D15.2" title="Lambda D" class="mw-redirect">15.2</a>) is potentially compatible with any type.</u><span class="assertion-id"> [jsr335-15.12.2.1-10-F]</span></span>
</li></ul>
<p><span class="norm-error">
If the search does not yield at least one method that is potentially applicable, then a compile-time error occurs.<span class="assertion-id"> [jls-15.12.2.1-210]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p><p>This definition of potential applicability expands the previous arity check to also take into account the presence and "shape" of functional interface target types.
</p>
In some cases involving type argument inference, a lambda expression appearing as a method invocation argument cannot be properly typed until after overload resolution.  These rules allow the form of the lambda expression to still be taken into account, discarding obviously incorrect target types that might otherwise cause ambiguity errors.</div></blockquote>
<div id="F15.12.2.2"></div>
<h3> <span class="mw-headline" id="15.12.2.2_Phase_1:_Identify_Matching_Arity_Methods_Applicable_by_Subtyping_Strict_Invocation_.5BModified.5D"> 15.12.2.2 Phase 1: Identify Matching Arity Methods Applicable by <del>Subtyping</del> <u>Strict Invocation</u> [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.2" class="external text" rel="nofollow">JLS 15.12.2.2</a></small>
</p><p><span class="norm-static">
<u>An argument expression is considered <i>pertinent to applicability</i> for a potentially-applicable method <em>m</em> unless it has one of the following forms:</u><span class="assertion-id"> [jsr335-15.12.2.2-5]</span></span>
</p>
<ul><li> <span class="norm-static"> <u>An implicitly-typed lambda expression (<a href="#B15.27.1" title="Lambda B" class="mw-redirect">15.27.1</a>).</u><span class="assertion-id"> [jsr335-15.12.2.2-5-A]</span></span>
</li><li> <span class="norm-static"> <u>An inexact method reference (<a href="#E15.13.1" title="Lambda E" class="mw-redirect">15.13.1</a>).</u><span class="assertion-id"> [jsr335-15.12.2.2-5-B]</span></span>
</li><li> <span class="norm-static"> <u>If <em>m</em> is a generic method and the method invocation does not provide explicit type arguments, an explicitly-typed lambda expression or an exact method reference for which the corresponding target type (as derived from the signature of <em>m</em>) is a type parameter of <em>m</em>.</u><span class="assertion-id"> [jsr335-15.12.2.2-5-C]</span></span>
</li><li> <span class="norm-static"> <u>An explicitly-typed lambda expression whose body is an expression that is not pertinent to applicability.</u><span class="assertion-id"> [jsr335-15.12.2.2-5-D]</span></span>
</li><li> <span class="norm-static"> <u>An explicitly-typed lambda expression whose body is a block, where at least one result expression is not pertinent to applicability.</u><span class="assertion-id"> [jsr335-15.12.2.2-5-E]</span></span>
</li><li> <span class="norm-static"> <u>A parenthesized expression (<a href="#D15.8.5" title="Lambda D" class="mw-redirect">15.8.5</a>) whose contained expression is not pertinent to applicability.</u><span class="assertion-id"> [jsr335-15.12.2.2-5-F]</span></span>
</li><li> <span class="norm-static"> <u>A conditional expression (<a href="#D15.25" title="Lambda D" class="mw-redirect">15.25</a>) whose second or third operand is not pertinent to applicability.</u><span class="assertion-id"> [jsr335-15.12.2.2-5-G]</span></span>
</li></ul>
<p><span class="norm-static">
Let <em>m</em> be a potentially applicable method (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.1" class="external text" rel="nofollow">15.12.2.1</a>) <u>with arity <em>n</em></u>, let <em>e<sub>1</sub>, ..., e<sub>n</sub></em> be the actual argument expressions of the method invocation, and let <del><em>A<sub>i</sub></em> be the type of <em>e<sub>i</sub></em> (<em>1 ≤ i ≤ n</em>)</del> <u><em>F<sub>1</sub>, ..., F<sub>n</sub></em> be the types of the formal parameters of <em>m</em></u>.  Then:<span class="assertion-id"> [jls-15.12.2.2-100]</span></span>
</p>
<ul><li> <span class="norm-static"> <u>If <em>m</em> is a generic method and the method invocation does not provide explicit type arguments, then the applicability of the method is inferred as described in <a href="#G18.5.1" title="Lambda G" class="mw-redirect">18.5.1</a>.</u><span class="assertion-id"> [jsr335-15.12.2.2-10-A]</span></span>
</li><li> <span class="norm-static"> <u>Otherwise,</u> if <em>m</em> is a generic method, then let <em>R<sub>1</sub>, ..., R<sub>p</sub></em> (<em>p ≥ 1</em>) be the type parameters of <em>m</em>, <del>and</del> let <em>B<sub>l</sub></em> be the declared bound of <em>R<sub>l</sub></em> (<em>1 ≤ l ≤ p</em>), <u>and</u> let <em>U<sub>1</sub>, ..., U<sub>p</sub></em> be the explicit type arguments given in the method invocation.  <u>Then <em>m</em> is <i>applicable by strict invocation</i> if:</u><span class="assertion-id"> [jsr335-15.12.2.2-10-B]</span></span>
<ul><li> <span class="norm-static"> For <em>1 ≤ i ≤ n</em>, <u>if <em>e<sub>i</sub></em> is pertinent to applicability then <em>e<sub>i</sub></em> is compatible in a strict invocation context with <em>F<sub>i</sub>[R<sub>1</sub>:=U<sub>1</sub>, ..., R<sub>p</sub>:=U<sub>p</sub>]</em>.</u><span class="assertion-id"> [jsr335-15.12.2.2-10-B1]</span></span>
</li><li> <span class="norm-static"> <u>For <em>1 ≤ l ≤ p</em></u>, <em>U<sub>l</sub> &lt;: B<sub>l</sub>[R<sub>1</sub>:=U<sub>1</sub>, ..., R<sub>p</sub>:=U<sub>p</sub>]</em>.<span class="assertion-id"> [jsr335-15.12.2.2-10-B2]</span></span>
</li></ul>
</li><li> <span class="norm-static"> Otherwise, <u><em>m</em> is <i>applicable by strict invocation</i> if, for <em>1 ≤ i ≤ n</em>, either <em>e<sub>i</sub></em> is compatible in a strict invocation context with <em>F<sub>i</sub></em> or <em>e<sub>i</sub></em> is not pertinent to applicability.</u><span class="assertion-id"> [jsr335-15.12.2.2-10-C]</span></span>
</li></ul>
<p><span class="norm-static">
If no method applicable by <u>strict invocation</u> is found, the search for applicable methods continues with phase 2 (<a href="#F15.12.2.3" title="Lambda F" class="mw-redirect">15.12.2.3</a>).<span class="assertion-id"> [jls-15.12.2.2-120]</span></span>
</p><p><span class="norm-static">
Otherwise, the most specific method (<a href="#F15.12.2.5" title="Lambda F" class="mw-redirect">15.12.2.5</a>) is chosen among the methods that are applicable by <u>strict invocation</u>.<span class="assertion-id"> [jls-15.12.2.2-130]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> The rules for handling generic method type argument inference, and associated terminology, have become too unwieldy to simply inline in the applicability rules.  Instead, in this and the subsequent applicability sections, the inference problem has been factored out to <a href="#G18.5.1" title="Lambda G" class="mw-redirect">18.5.1</a>.
</div></li>
<li style="margin-bottom:12px;"><div> The meaning of an implicitly-typed lambda expression or an inexact method reference is sufficiently vague prior to resolving a target type that arguments containing these expressions are not considered <i>pertinent to applicability</i>; they are simply ignored (except for their expected arity) until overload resolution is finished.
</div></li></ol></div></blockquote>
<div id="F15.12.2.3"></div>
<h3> <span class="mw-headline" id="15.12.2.3_Phase_2:_Identify_Matching_Arity_Methods_Applicable_by_Invocation_Conversion_Loose_Invocation_.5BModified.5D"> 15.12.2.3 Phase 2: Identify Matching Arity Methods Applicable by <del>Invocation Conversion</del> <u>Loose Invocation</u> [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.3" class="external text" rel="nofollow">JLS 15.12.2.3</a></small>
</p><p><span class="norm-static">
Let <em>m</em> be a potentially applicable method (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.1" class="external text" rel="nofollow">15.12.2.1</a>) <u>with arity <em>n</em></u>, let <em>e<sub>1</sub>, ..., e<sub>n</sub></em> be the actual argument expressions of the method invocation, and let <del><em>A<sub>i</sub></em> be the type of <em>e<sub>i</sub></em> (<em>1 ≤ i ≤ n</em>)</del> <u><em>F<sub>1</sub>, ..., F<sub>n</sub></em> be the types of the formal parameters of <em>m</em></u>.  Then:<span class="assertion-id"> [jls-15.12.2.3-100]</span></span>
</p>
<ul><li> <span class="norm-static"> <u>If <em>m</em> is a generic method and the method invocation does not provide explicit type arguments, then the applicability of the method is inferred as described in <a href="#G18.5.1" title="Lambda G" class="mw-redirect">18.5.1</a>.</u><span class="assertion-id"> [jsr335-15.12.2.3-10-A]</span></span>
</li><li> <span class="norm-static"> <u>Otherwise,</u> if <em>m</em> is a generic method, then let <em>R<sub>1</sub>, ..., R<sub>p</sub></em> (<em>p ≥ 1</em>) be the type parameters of <em>m</em>, <del>and</del> let <em>B<sub>l</sub></em> be the declared bound of <em>R<sub>l</sub></em> (<em>1 ≤ l ≤ p</em>), <u>and</u> let <em>U<sub>1</sub>, ..., U<sub>p</sub></em> be the explicit type arguments given in the method invocation.  <u>Then <em>m</em> is <i>applicable by loose invocation</i> if:</u><span class="assertion-id"> [jsr335-15.12.2.3-10-B]</span></span>
<ul><li> <span class="norm-static"> For <em>1 ≤ i ≤ n</em>, <u>if <em>e<sub>i</sub></em> is pertinent to applicability (<a href="#F15.12.2.2" title="Lambda F" class="mw-redirect">15.12.2.2</a>) then <em>e<sub>i</sub></em> is compatible in a loose invocation context with <em>F<sub>i</sub>[R<sub>1</sub>:=U<sub>1</sub>, ..., R<sub>p</sub>:=U<sub>p</sub>]</em>.</u><span class="assertion-id"> [jsr335-15.12.2.3-10-B1]</span></span>
</li><li> <span class="norm-static"> <u>For <em>1 ≤ l ≤ p</em></u>, <em>U<sub>l</sub> &lt;: B<sub>l</sub>[R<sub>1</sub>:=U<sub>1</sub>, ..., R<sub>p</sub>:=U<sub>p</sub>]</em>.<span class="assertion-id"> [jsr335-15.12.2.3-10-B2]</span></span>
</li></ul>
</li><li> <span class="norm-static"> Otherwise, <u><em>m</em> is <i>applicable by loose invocation</i> if, for <em>1 ≤ i ≤ n</em>, either <em>e<sub>i</sub></em> is compatible in a loose invocation context with <em>F<sub>i</sub></em> or <em>e<sub>i</sub></em> is not pertinent to applicability (<a href="#F15.12.2.2" title="Lambda F" class="mw-redirect">15.12.2.2</a>).</u><span class="assertion-id"> [jsr335-15.12.2.3-10-C]</span></span>
</li></ul>
<p><span class="norm-static">
If no method applicable by <u>loose invocation</u> is found, the search for applicable methods continues with phase 3 (<a href="#F15.12.2.4" title="Lambda F" class="mw-redirect">15.12.2.4</a>).<span class="assertion-id"> [jls-15.12.2.3-120]</span></span>
</p><p><span class="norm-static">
Otherwise, the most specific method (<a href="#F15.12.2.5" title="Lambda F" class="mw-redirect">15.12.2.5</a>) is chosen among the methods that are applicable by <u>loose invocation</u>.<span class="assertion-id"> [jls-15.12.2.3-130]</span></span>
</p>
<div id="F15.12.2.4"></div>
<h3> <span class="mw-headline" id="15.12.2.4_Phase_3:_Identify_Methods_Applicable_by_Variable_Arity_Methods_Invocation_.5BModified.5D"> 15.12.2.4 Phase 3: Identify <u>Methods</u> Applicable <u>by</u> Variable Arity <del>Methods</del> <u>Invocation</u> [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.4" class="external text" rel="nofollow">JLS 15.12.2.4</a></small>
</p><p><span class="norm-static">
<u>Where a variable-arity method has formal parameter types <em>F<sub>1</sub>, ..., F<sub>n-1</sub>, F<sub>n</sub><code style="background-color:inherit;font-size:medium">[]</code></em>, define the <i><em>i</em>th variable-arity parameter type</i> of the method as follows:</u><span class="assertion-id"> [jsr335-15.12.2.4-5]</span></span>
</p>
<ul><li> <span class="norm-static"> <u>For <em>i ≤ n-1</em>, the <em>i</em>th variable-arity parameter type is <em>F<sub>i</sub></em>.</u><span class="assertion-id"> [jsr335-15.12.2.4-5-A]</span></span>
</li><li> <span class="norm-static"> <u>For <em>i ≥ n</em>, the <em>i</em>th variable-arity parameter type is <em>F<sub>n</sub></em>.</u><span class="assertion-id"> [jsr335-15.12.2.4-5-B]</span></span>
</li></ul>
<p><span class="norm-static">
Let <em>m</em> be a potentially applicable method (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.1" class="external text" rel="nofollow">15.12.2.1</a>) with variable arity, let <em>e<sub>1</sub>, ..., e<sub>k</sub></em> be the actual argument expressions of the method invocation and let <del><em>A<sub>i</sub></em> be the type of <em>e<sub>i</sub></em> (<em>1 ≤ i ≤ k</em>)</del> <u><em>T<sub>1</sub>, ..., T<sub>k</sub></em> be first <em>k</em> variable-arity parameter types of <em>m</em></u>.  Then:<span class="assertion-id"> [jls-15.12.2.4-100]</span></span>
</p>
<ul><li> <span class="norm-static"> <u>If <em>m</em> is a generic method and the method invocation does not provide explicit type arguments, then the applicability of the method is inferred as described in <a href="#G18.5.1" title="Lambda G" class="mw-redirect">18.5.1</a>.</u><span class="assertion-id"> [jsr335-15.12.2.4-10-A]</span></span>
</li><li> <span class="norm-static"> <u>Otherwise,</u> if <em>m</em> is a generic method, then let <em>R<sub>1</sub>, ..., R<sub>p</sub></em> (<em>p ≥ 1</em>) be the type parameters of <em>m</em>, <del>and</del> let <em>B<sub>l</sub></em> be the declared bound of <em>R<sub>l</sub></em> (<em>1 ≤ l ≤ p</em>), <u>and</u> let <em>U<sub>1</sub>, ..., U<sub>p</sub></em> be the explicit type arguments given in the method invocation.  <u>Then <em>m</em> is an <i>applicable variable-arity method</i> if:</u><span class="assertion-id"> [jsr335-15.12.2.4-10-B]</span></span>
<ul><li> <span class="norm-static"> <u>For <em>1 ≤ i ≤ k</em>, if <em>e<sub>i</sub></em> is pertinent to applicability (<a href="#F15.12.2.2" title="Lambda F" class="mw-redirect">15.12.2.2</a>) then <em>e<sub>i</sub></em> is compatible in a loose invocation context with <em>T<sub>i</sub>[R<sub>1</sub>:=U<sub>1</sub>, ..., R<sub>p</sub>:=U<sub>p</sub>]</em>.</u><span class="assertion-id"> [jsr335-15.12.2.4-10-B1]</span></span>
</li><li> <span class="norm-static"> <u>For <em>1 ≤ l ≤ p</em></u>, <em>U<sub>l</sub> &lt;: B<sub>l</sub>[R<sub>1</sub>:=U<sub>1</sub>, ..., R<sub>p</sub>:=U<sub>p</sub>]</em>.<span class="assertion-id"> [jsr335-15.12.2.4-10-B4]</span></span>
</li></ul>
</li><li> <span class="norm-static"> Otherwise, <u><em>m</em> is <i>applicable by variable-arity invocation</i> if for <em>1 ≤ i ≤ k</em>, either <em>e<sub>i</sub></em> is compatible in a loose invocation context with <em>T<sub>i</sub></em> or <em>e<sub>i</sub></em> is not pertinent to applicability (<a href="#F15.12.2.2" title="Lambda F" class="mw-redirect">15.12.2.2</a>).</u><span class="assertion-id"> [jsr335-15.12.2.4-10-C]</span></span>
</li></ul>
<p><span class="norm-error">
If no <u>method</u> applicable <u>by</u> variable-arity <del>method</del> <u>invocation</u> is found, a compile-time error occurs.<span class="assertion-id"> [jls-15.12.2.4-120]</span></span>
</p><p><span class="norm-static">
Otherwise, the most specific method (<a href="#F15.12.2.5" title="Lambda F" class="mw-redirect">15.12.2.5</a>) is chosen among the <u>methods</u> applicable <u>by</u> variable-arity <del>methods</del> <u>invocation</u>.<span class="assertion-id"> [jls-15.12.2.4-130]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> The previous "applicable variable arity method" terminology incorrectly hinted that, if a variable-arity method is applicable in any phase, it is applicable in and only in Phase 3.  This overlooks the fact that variable arity methods can act as fixed-arity methods in Phases 1 and 2.  What is relevant is the kinds of adaptations actually used to determine applicability, <i>not</i> the kinds of adaptations allowed by the method declaration.
</div></li>
<li style="margin-bottom:12px;"><div> The <i>ith variable arity parameter type</i> is a notational shorthand that simplifies the problem of describing all possible ways in which arguments might be matched up with parameter types.  This is especially useful in the next section.
</div></li>
<li style="margin-bottom:12px;"><div> An access check on the type of the last parameter appeared here previously, but has been moved to <a href="#F15.12.3" title="Lambda F" class="mw-redirect">15.12.3</a>.
</div></li></ol></div></blockquote>
<div id="F15.12.2.5"></div>
<h3> <span class="mw-headline" id="15.12.2.5_Choosing_the_Most_Specific_Method_.5BModified.5D"> 15.12.2.5 Choosing the Most Specific Method [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.5" class="external text" rel="nofollow">JLS 15.12.2.5</a></small>
</p><p>If more than one member method is both accessible and applicable to a method invocation, it is necessary to choose one to provide the descriptor for the run-time method dispatch.  The Java programming language uses the rule that the <i>most specific</i> method is chosen.
</p><p>The informal intuition is that one method is more specific than another if any invocation handled by the first method could be passed on to the other one without a compile-time error.  <u>In cases such as an explicitly-typed lambda expression argument (<a href="#B15.27.1" title="Lambda B" class="mw-redirect">15.27.1</a>) or a variable-arity invocation (<a href="#F15.12.2.4" title="Lambda F" class="mw-redirect">15.12.2.4</a>), some flexibility is allowed to adapt one signature to the other.</u>
</p><p><span class="norm-static">
One <del>fixed-arity member</del> <u>applicable</u> method <del>named <em>m</em></del> <u><em>m<sub>1</sub></em></u> is <i>more specific</i> than another <del>member</del>  <u>applicable</u> method <del>of the same name and arity</del>, <u><em>m<sub>2</sub></em>, for an invocation with argument expressions <em>exp<sub>1</sub>, ..., exp<sub>k</sub>,</em> if any of the following are true</u>:<span class="assertion-id"> [jls-15.12.2.5-200]</span></span>
</p>
<ul><li> <span class="norm-static"> <u><em>m<sub>2</sub></em> is generic and <em>m<sub>1</sub></em> is inferred to be more specific than <em>m<sub>2</sub></em> for argument expressions <em>exp<sub>1</sub>, ..., exp<sub>k</sub></em> by <a href="#G18.5.4" title="Lambda G" class="mw-redirect">18.5.4</a>.</u><span class="assertion-id"> [jsr335-15.12.2.5-200-B]</span></span>
</li><li> <span class="norm-static"> <u><em>m<sub>2</sub></em> is not generic, <em>m<sub>1</sub></em> and <em>m<sub>2</sub></em> are applicable by strict or loose invocation, and where <em>m<sub>1</sub></em> has parameter types <em>S<sub>1</sub>, ..., S<sub>n</sub></em> and <em>m<sub>2</sub></em> has parameter types <em>T<sub>1</sub>, ..., T<sub>n</sub></em>, for all <em>i</em> (<em>1 ≤ i ≤ n</em>), the type <em>S<sub>i</sub></em> is <i>more specific</i> than <em>T<sub>i</sub></em> for argument <em>exp<sub>i</sub></em>.</u><span class="assertion-id"> [jsr335-15.12.2.5-200-C]</span></span>
</li><li> <span class="norm-static"> <u><em>m<sub>2</sub></em> is not generic, <em>m<sub>1</sub></em> and <em>m<sub>2</sub></em> are applicable by variable arity invocation, and where the first <em>k</em> variable-arity parameter types of <em>m<sub>1</sub></em> are <em>S<sub>1</sub>, ..., S<sub>k</sub></em> and the first <em>k</em> variable-arity parameter types of <em>m<sub>2</sub></em> are <em>T<sub>1</sub>, ..., T<sub>k</sub></em>, for all <em>i</em> (<em>1 ≤ i ≤ k</em>), the type <em>S<sub>i</sub></em> is <i>more specific</i> than <em>T<sub>i</sub></em> for argument <em>exp<sub>i</sub></em>; additionally, if <em>m<sub>2</sub></em> has <em>k+1</em> parameters, then the <em>k+1</em>th variable-arity parameter type of <em>m<sub>1</sub></em> is a subtype of the <em>k+1</em>th variable-arity parameter type of <em>m<sub>2</sub></em>.</u><span class="assertion-id"> [jsr335-15.12.2.5-300-C]</span></span>
</li></ul>
<p><span class="norm-static">
The above conditions are the only circumstances under which one method may be more specific than another.<span class="assertion-id"> [jls-15.12.2.5-400]</span></span>
</p><p><span class="norm-static"> <u>A type <em>S</em> is <i>more specific</i> than a type <em>T</em> for <i>any</i> expression if <em>S &lt;: T</em>.</u><span class="assertion-id"> [jsr335-15.12.2.5-10-A]</span></span>
</p><p><span class="norm-static">
<u>In addition, a functional interface type <em>S</em> is <i>more specific</i> than a functional interface type <em>T</em> for an expression <em>exp</em> if <em>T</em> is not a subtype of <em>S</em> and one of the following conditions apply.  Let <em>U<sub>1</sub>, ..., U<sub>k</sub></em> and <em>R<sub>1</sub></em> be the parameter types and return type, respectively, of the function type of <i>the capture of</i> <em>S</em>, and let <em>V<sub>1</sub>, ..., V<sub>k</sub></em> and <em>R<sub>2</sub></em> be the parameter types and return type, respectively, of the function type of <em>T</em>.</u><span class="assertion-id"> [jsr335-15.12.2.5-10]</span></span>
</p>
<ul><li> <span class="norm-static"> <u><em>exp</em> is an explicitly-typed lambda expression (<a href="#B15.27.1" title="Lambda B" class="mw-redirect">15.27.1</a>) and one of the following is true (where <i>result expression</i> is defined in <a href="#B15.27.2" title="Lambda B" class="mw-redirect">15.27.2</a> for a block body, and refers to the body itself for an expression body):</u><span class="assertion-id"> [jsr335-15.12.2.5-10-F]</span></span>
<ul><li> <span class="norm-static"> <u><em>R<sub>2</sub></em> is <code style="background-color:inherit;font-size:medium">void</code>.</u><span class="assertion-id"> [jsr335-15.12.2.5-10-F5]</span></span>
</li><li> <span class="norm-static"> <u><em>R<sub>1</sub> &lt;: R<sub>2</sub></em>.</u><span class="assertion-id"> [jsr335-15.12.2.5-10-F6]</span></span>
</li><li> <span class="norm-static"> <u><em>R<sub>1</sub></em> and <em>R<sub>2</sub></em> are functional interface types, and <em>R<sub>1</sub></em> is more specific than <em>R<sub>2</sub></em> for each result expression.</u><span class="assertion-id"> [jsr335-15.12.2.5-10-F7]</span></span>
</li><li> <span class="norm-static"> <u><em>R<sub>1</sub></em> is a primitive type, <em>R<sub>2</sub></em> is a reference type, and each result expression is a standalone expression (<a href="#D15.2" title="Lambda D" class="mw-redirect">15.2</a>) of a primitive type.</u><span class="assertion-id"> [jsr335-15.12.2.5-10-F8]</span></span>
</li><li> <span class="norm-static"> <u><em>R<sub>1</sub></em> is a reference type, <em>R<sub>2</sub></em> is a primitive type, and each result expression is either a standalone expression of a reference type or a poly expression.</u><span class="assertion-id"> [jsr335-15.12.2.5-10-F9]</span></span>
</li></ul>
</li><li> <span class="norm-static"> <u><em>exp</em> is an exact method reference (<a href="#B15.13.1" title="Lambda B" class="mw-redirect">15.13.1</a>); for all <em>i</em>, <em>1 ≤ i ≤ k</em>, <em>U<sub>i</sub></em> is the same as <em>V<sub>i</sub></em>; and one of the following is true:</u><span class="assertion-id"> [jsr335-15.12.2.5-10-G]</span></span>
<ul><li> <span class="norm-static"> <u><em>R<sub>2</sub></em> is <code style="background-color:inherit;font-size:medium">void</code>.</u><span class="assertion-id"> [jsr335-15.12.2.5-10-G5]</span></span>
</li><li> <span class="norm-static"> <u><em>R<sub>1</sub> &lt;: R<sub>2</sub></em>.</u><span class="assertion-id"> [jsr335-15.12.2.5-10-G6]</span></span>
</li><li> <span class="norm-static"> <u><em>R<sub>1</sub></em> is a primitive type, <em>R<sub>2</sub></em> is a reference type, and the compile-time declaration for the method reference has a primitive return type.</u><span class="assertion-id"> [jsr335-15.12.2.5-10-G8]</span></span>
</li><li> <span class="norm-static"> <u><em>R<sub>1</sub></em> is a reference type, <em>R<sub>2</sub></em> is a primitive type, and the compile-time declaration for the method reference has a reference return type.</u><span class="assertion-id"> [jsr335-15.12.2.5-10-G9]</span></span>
</li></ul>
</li><li> <span class="norm-static"> <u><em>exp</em> is a parenthesized expression (<a href="#D15.8.5" title="Lambda D" class="mw-redirect">15.8.5</a>) and one of these conditions applies recursively to the wrapped expression.</u><span class="assertion-id"> [jsr335-15.12.2.5-10-D]</span></span>
</li><li> <span class="norm-static"> <u><em>exp</em> is a conditional expression (<a href="#D15.25.3" title="Lambda D" class="mw-redirect">15.25.3</a>) and for each of the second and third operands, one of these conditions applies recursively.</u><span class="assertion-id"> [jsr335-15.12.2.5-10-E]</span></span>
</li></ul>
<p><span class="norm-static">
A method <em>m<sub>1</sub></em> is <i>strictly more specific</i> than another method <em>m<sub>2</sub></em> if and only if <em>m<sub>1</sub></em> is more specific than <em>m<sub>2</sub></em> and <em>m<sub>2</sub></em> is not more specific than <em>m<sub>1</sub></em>.<span class="assertion-id"> [jls-15.12.2.5-500]</span></span>
</p><p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div>
<p>The Java 7 most-specific analysis was defined as a pairwise comparison of method declarations via subtyping.  Here, we augment the analysis so that, where the corresponding argument is an explicitly-typed lambda expression or an exact method reference, one functional interface type can be preferred over another if it has a "better" function type return type, by a variety of measures: subtyping, boxing, or <code style="background-color:inherit;font-size:medium">void</code> vs. non-<code style="background-color:inherit;font-size:medium">void</code>.
</p>
</div></li>
<li style="margin-bottom:12px;"><div>
<p>As above, the inference problem associated with the most-specific analysis has been factored out into its own section, <a href="#G18.5.4" title="Lambda G" class="mw-redirect">18.5.4</a>.
</p>
</div></li></ol></div></blockquote>
<div id="F15.12.2.6"></div>
<h3> <span class="mw-headline" id="15.12.2.6_Method_Invocation_Type_Result_and_Throws_Types_.5BModified.5D"> 15.12.2.6 Method <u>Invocation Type</u> <del>Result and Throws Types</del> [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.6" class="external text" rel="nofollow">JLS 15.12.2.6</a></small>
</p><p><span class="norm-static">
<u>The <i>invocation type</i> of a most-specific accessible and applicable method is a method type (<a href="#F8.2" title="Lambda F" class="mw-redirect">8.2</a>) expressing the target types of the invocation arguments, the result type of the invocation, and the exception types of the invocation.  It</u> is determined as follows:<span class="assertion-id"> [jsr335-15.12.2.6-10]</span></span>
</p>
<ul><li> <span class="norm-static"> <u>If the chosen method is generic and the method invocation does not provide explicit type arguments, the invocation type is inferred as described in <a href="#G18.5.2" title="Lambda G" class="mw-redirect">18.5.2</a>.</u><span class="assertion-id"> [jsr335-15.12.2.6-10-A]</span></span>
</li><li> <span class="norm-static"> Otherwise, if the chosen method is generic, then for <em>1 ≤ i ≤ <u>p</u></em>, let <u><em>P<sub>i</sub></em></u> be the formal type parameters of the method, <u>and</u> let <u><em>T<sub>i</sub></em></u> be the actual type arguments <u>provided</u> for the method invocation.  <u>Apply the substitution <em>[P<sub>1</sub>:=T<sub>1</sub>, ..., P<sub>p</sub>:=T<sub>p</sub>]</em> to the method's type. If unchecked conversion was not necessary for the method to be applicable, then this is the invocation type of m; if unchecked conversion <i>was</i> necessary, then this substitution provides the parameter types of the invocation type, while the return type and thrown types are given by the erasure of the method's type (without applying the substitution).</u><span class="assertion-id"> [jsr335-15.12.2.6-10-C]</span></span>
</li><li> <span class="norm-static"> Otherwise, if unchecked conversion was necessary for the method to be applicable, then <u>the parameter types of the invocation type are the parameter types of the method's type</u>; the <del>result</del> <u>return</u> type <u>and thrown types</u> <del>is</del> <u>are given by</u> the erasure (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.6" class="external text" rel="nofollow">4.6</a>) of the method's <del>declared return</del> type.<span class="assertion-id"> [jsr335-15.12.2.6-10-B]</span></span>
</li><li> <span class="norm-static"> <u>Otherwise, if the chosen method is the <code style="background-color:inherit;font-size:medium">getClass</code> method of the class <code style="background-color:inherit;font-size:medium">Object</code> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.3.2" class="external text" rel="nofollow">4.3.2</a>), the method's invocation type is the same as the method's type, except that the return type is <code style="background-color:inherit;font-size:medium">Class&lt;? extends <em>T</em>&gt;</code>, where <em>T</em> is the type that was searched, as determined by <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.1" class="external text" rel="nofollow">15.12.1</a>.</u><span class="assertion-id"> [jsr335-15.12.2.6-10-E]</span></span>
</li><li> <span class="norm-static"> <u>Otherwise, the method's invocation type is the same as the method's type.</u><span class="assertion-id"> [jsr335-15.12.2.6-10-D]</span></span>
</li></ul>
<p><span class="norm-static">
<u>The type of the method invocation expression is</u> obtained by applying capture conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.10" class="external text" rel="nofollow">5.1.10</a>) to the return type <u>of the invocation type</u> of the chosen method.<span class="assertion-id"> [jls-15.12.2.6-100-C.1]</span></span>
</p><p><span class="norm-static">
The exception types that a method invocation expression can throw are specified in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-11.html#jls-11.2.1" class="external text" rel="nofollow">11.2.1</a>.<span class="assertion-id"> [jls-15.12.2.6-300]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> We introduce <i>invocation type</i> here to group together the return type, exception types, and parameter types.  Because poly expressions can appear as method arguments, we need to be more explicit than before about what the target type of a method argument is.  This new abstraction also clarifies the interaction with inference (<a href="#G18.5.2" title="Lambda G" class="mw-redirect">18.5.2</a>), and simplifies the text for this section, which was needlessly concerned with the details of substitution and erasure on lists of types.
</div></li>
<li style="margin-bottom:12px;"><div> The return type of the <code style="background-color:inherit;font-size:medium">getClass</code> method was already defined in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.3.2" class="external text" rel="nofollow">4.3.2</a>, but the definition was added here for clarity.  (In particular, it should be clear that this special return type is also used for method reference compatibility testing (<a href="#E15.13.2" title="Lambda E" class="mw-redirect">15.13.2</a>).)
</div></li></ol></div></blockquote>
<div id="F15.12.3"></div>
<h3> <span class="mw-headline" id="15.12.3_Compile-Time_Step_3:_Is_the_Chosen_Method_Appropriate.3F_.5BAddendum.5D"> 15.12.3 Compile-Time Step 3: Is the Chosen Method Appropriate? [Addendum] </span></h3>
<p><small>See <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.3" class="external text" rel="nofollow">JLS 15.12.3</a></small>
</p><p><span class="norm-error">
It is a compile-time error if an argument to a method invocation is not compatible with its target type, as derived from the invocation type.<span class="assertion-id"> [jsr335-15.12.3-10]</span></span>
</p><p><span class="norm-error">
If the compile-time declaration is applicable by variable-arity invocation, then where the last formal parameter type of the invocation type of the method is <em>F<sub>n</sub><code style="background-color:inherit;font-size:medium">[]</code></em>, it is a compile-time error if the type which is the erasure of <u><em>F<sub>n</sub></em></u> is not accessible at the point of invocation.<span class="assertion-id"> [jsr335-15.12.3-20]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
The JLS 7 version of <a href="#F15.12.2.4" title="Lambda F" class="mw-redirect">15.12.2.4</a> performed this vararg access check during overload resolution.  The check is necessary in order to guarantee that it is possible for the compiler to create an array of the given type.  But it creates a soundness problem for inference (<a href="#G18.5.1" title="Lambda G" class="mw-redirect">18.5.1</a>): how can inference guarantee that an inferred type will be accessible?  Thus, the access check is more appropriate as a post-resolution step.</div></blockquote>
<div id="F15.9.3"></div>
<h3> <span class="mw-headline" id="15.9.3_Choosing_the_Constructor_and_its_Arguments_.5BAddendum.5D"> 15.9.3 Choosing the Constructor and its Arguments [Addendum] </span></h3>
<p><small>See <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.3" class="external text" rel="nofollow">JLS 15.9.3</a></small>
</p><p><span class="norm-error">
It is a compile-time error if an argument to a class instance creation expression is not compatible with its target type, as derived from the invocation type (<a href="#F15.12.2.6" title="Lambda F" class="mw-redirect">15.12.2.6</a>).<span class="assertion-id"> [jsr335-15.9.3-10]</span></span>
</p><p><span class="norm-error">
If the compile-time declaration is applicable by variable-arity invocation (<a href="#F15.12.2.4" title="Lambda F" class="mw-redirect">15.12.2.4</a>), then where the last formal parameter type of the invocation type of the constructor is <em>F<sub>n</sub><code style="background-color:inherit;font-size:medium">[]</code></em>, it is a compile-time error if the type which is the erasure of <u><em>F<sub>n</sub></em></u> is not accessible at the point of invocation.<span class="assertion-id"> [jsr335-15.9.3-20]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>These rules are identical to those for <a href="#F15.12.3" title="Lambda F" class="mw-redirect">15.12.3</a>.  The same checks should be performed for both constructors and methods.
</p>
</div></blockquote>



<a id="top"></a>
	
	<a id="G"/><h1 id="firstHeading" class="firstHeading">Lambda Specification, Part G: Type Inference</h1>
									<p><small>
Navigation: <a href="#overview" title="Lambda Specification" class="mw-redirect">Overview</a>&nbsp;- <a href="#A" title="Lambda A" class="mw-redirect">Part A</a>&nbsp;- <a href="#B" title="Lambda B" class="mw-redirect">Part B</a>&nbsp;- <a href="#C" title="Lambda C" class="mw-redirect">Part C</a>&nbsp;- <a href="#D" title="Lambda D" class="mw-redirect">Part D</a>&nbsp;- <a href="#E" title="Lambda E" class="mw-redirect">Part E</a>&nbsp;- <a href="#F" title="Lambda F" class="mw-redirect">Part F</a>&nbsp;- <a href="#G" title="Lambda G" class="mw-redirect">Part G</a>&nbsp;- <a href="#H" title="Lambda H" class="mw-redirect">Part H</a>&nbsp;- <a href="#J" title="Lambda J" class="mw-redirect">Part J</a>
<br />
Sections: <a href="#G18">18</a>&nbsp;- <a href="#G18.1">18.1</a>&nbsp;- <a href="#G18.1.1">18.1.1</a>&nbsp;- <a href="#G18.1.2">18.1.2</a>&nbsp;- <a href="#G18.1.3">18.1.3</a>&nbsp;- <a href="#G18.2">18.2</a>&nbsp;- <a href="#G18.2.1">18.2.1</a>&nbsp;- <a href="#G18.2.1.1">18.2.1.1</a>&nbsp;- <a href="#G18.2.1.2">18.2.1.2</a>&nbsp;- <a href="#G18.2.2">18.2.2</a>&nbsp;- <a href="#G18.2.3">18.2.3</a>&nbsp;- <a href="#G18.2.4">18.2.4</a>&nbsp;- <a href="#G18.2.5">18.2.5</a>&nbsp;- <a href="#G18.3">18.3</a>&nbsp;- <a href="#G18.4">18.4</a>&nbsp;- <a href="#G18.5">18.5</a>&nbsp;- <a href="#G18.5.1">18.5.1</a>&nbsp;- <a href="#G18.5.2">18.5.2</a>&nbsp;- <a href="#G18.5.3">18.5.3</a>&nbsp;- <a href="#G18.5.4">18.5.4</a>&nbsp;- <a href="#G4.10.4">4.10.4</a>&nbsp;- <a href="#G15.12.2.7">15.12.2.7</a>&nbsp;- <a href="#G15.12.2.8">15.12.2.8</a>
<br />
Version 0.9.3.  Copyright © 2014 Oracle America, Inc.  <a href="#Legal_Notice" title="Lambda Specification" class="mw-redirect">Legal Notice</a>.
</small>
</p>
<h3> <span class="mw-headline" id="Summary"> Summary </span></h3>
<p>A variety of compile-time analyses require reasoning about types that are not yet known.  Principal among these are generic method applicability testing and generic method invocation type inference.  In general, we refer to the process of reasoning about unknown types as <i>type inference</i>.
</p><p>At a high level, type inference consists of <i>reducing</i> compatibility assertions about expressions or types, called <i>constraint formulas</i>, to a set of <i>bounds</i> on <i>inference variables</i>.  For example, given inference variable <em>α</em>, it might be determined that the constraint formula <em>⟨<code style="background-color:inherit;font-size:medium">String[]</code> &lt;: α<code style="background-color:inherit;font-size:medium">[]</code>⟩</em> reduces to the lower bound <em><code style="background-color:inherit;font-size:medium">String</code> &lt;: α</em>.  As bounds are inferred, they are <i>incorporated</i> into a <i>bound set</i>.  Ultimately, this bound set is <i>resolved</i> to produce an instantiation for each of the inference variables.
</p><p>To infer a generic method's applicability, we assert that the arguments to the method are compatible with their corresponding formal parameter types, and reduce these constraints to a bound set.  We then check that there exists a resolution of the resulting bounds.
</p><p>To infer the type of a generic method invocation, we re-use the inferred bound set from method applicability testing, augmenting it with the results of asserting the compatibility of the method's return type with its target type.  If any invocation arguments are implicitly-typed lambda expressions or inexact method references, we resolve their targeted parameter types as necessary in order to allow their compatibility constraints to be safely reduced.  We also assert that any exceptions thrown by lambda expression bodies are contained by the <code style="background-color:inherit;font-size:medium">throws</code> clauses of their target function types.  After reduction, we resolve the inference variables and use them as type arguments to determine the invocation type of the method.
</p><p>Type inference is also used to determine: i) a target functional interface type for a lambda expression that is assigned to a wildcard-parameterized functional interface; and ii) whether an applicable method is more specific than another applicable, generic method.
</p><p>The following details of reduction are especially noteworthy:
</p><p>When a generic method invocation or diamond constructor invocation appears as the argument to another invocation, the target type of the nested invocation is the targeted formal parameter type.  If the target type contains inference variables, the inference variables and bounds from the nested invocation are "lifted" into the outer inference analysis, and dependencies between the outer and inner inference variables are inferred.  Ultimately, information from an outermost invocation can be "pushed down" to nested invocations via these dependencies.
</p><p>When a lambda expression appears as the argument to a generic invocation, and its target type includes inference variables, we proceed by:
</p>
<ul><li> Checking that the target type is a functional interface type and deriving a target function type.
</li><li> If the lambda parameters' types are implicit, ensuring that the target function type has proper types as its parameter types (allowing the lambda body to be type-checked).
</li><li> If the lambda parameters' types are explicit, asserting that these types match the target type's parameter types.
</li><li> Asserting that each result expression in the lambda body is compatible with the target type's return type.
</li></ul>
<p>Thus, lambda bodies can influence the instantiation of inference variables appearing in the targeted function type's return type, and lambda parameter types, if explicit, can influence the instantiation of inference variables appearing in the targeted function type's parameter types.
</p><p>A method reference appearing as the argument to a generic invocation is handled in much the same way.
</p>
<div id="G18"></div>
<h3> <span class="mw-headline" id="18_Type_Inference_.5BNew.5D"> 18 Type Inference [New] </span></h3>
<p>A variety of compile-time analyses require reasoning about types that are not yet known.  Principal among these are generic method applicability testing (<a href="#G18.5.1" title="Lambda G" class="mw-redirect">18.5.1</a>) and generic method invocation type inference (<a href="#G18.5.2" title="Lambda G" class="mw-redirect">18.5.2</a>).  In general, we refer to the process of reasoning about unknown types as <i>type inference</i>.
</p><p>At a high level, type inference can be decomposed into three processes:
</p>
<ul><li> <i>Reduction</i> takes a compatibility assertion about an expression or type, called a <i>constraint formula</i>, and reduces it to a set of <i>bounds</i> on <i>inference variables</i>.  Often, a constraint formula reduces to <i>other</i> constraint formulas, which must be recursively reduced.  A procedure is followed to identify these additional constraint formulas and, ultimately, to express via a bound set the conditions under which the choices for inferred types would render each constraint formula true.
</li></ul>
<ul><li> <i>Incorporation</i> maintains a set of inference variable bounds, ensuring that these are consistent as new bounds are added.  Because the bounds on one variable can sometimes impact the possible choices for another variable, this process propagates bounds between such interdependent variables.
</li></ul>
<ul><li> <i>Resolution</i> examines the bounds on an inference variable and determines an <i>instantiation</i> that is compatible with those bounds.  It also decides the order in which interdependent inference variables are to be resolved.
</li></ul>
<p>These processes interact closely: reduction can trigger incorporation; incorporation may lead to further reduction; and resolution may cause further incorporation.
</p><p>We elaborate in the following sections.
</p>
<ul><li> Section <a href="#G18.1" title="Lambda G" class="mw-redirect">18.1</a> more precisely defines the concepts used as intermediate results and the notation used to express them.
</li><li> Section <a href="#G18.2" title="Lambda G" class="mw-redirect">18.2</a> describes reduction in detail.
</li><li> Section <a href="#G18.3" title="Lambda G" class="mw-redirect">18.3</a> describes incorporation in detail.
</li><li> Section <a href="#G18.4" title="Lambda G" class="mw-redirect">18.4</a> describes resolution in detail.
</li><li> Section <a href="#G18.5" title="Lambda G" class="mw-redirect">18.5</a> defines how these inference tools are used to solve certain compile-time analysis problems.
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> This section introduces a new chapter to replace the current specification's definition of type argument inference in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.7" class="external text" rel="nofollow">15.12.2.7</a> and <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.8" class="external text" rel="nofollow">15.12.2.8</a>.
<p>In comparison to JLS 7, important changes to inference include:
</p>
<ul><li> Adding support for lambda expressions and method references as method invocation arguments.
</li><li> Generalizing to define inference in terms of poly expressions, which may not have well-defined types until <i>after</i> inference is complete.  This has the notable effect of improving inference for nested generic method and diamond constructor invocations.
</li><li> Describing how inference is used to handle wildcard-parameterized functional interface target types and most-specific method analysis.
</li><li> Clarifying the distinction between invocation applicability testing (which involves only the invocation arguments) and invocation type inference (which incorporates a target type).
</li><li> Delaying resolution of all inference variables, even those with lower bounds, until invocation type inference, in order to get better results.
</li><li> Improving inference behavior for interdependent (or self-dependent) variables.
</li><li> Eliminating bugs and potential sources of confusion.  This revision more carefully and precisely handles the distinction between specific conversion contexts and subtyping, and describes reduction by paralleling the corresponding non-inference relations.  Where there are intentional departures from the non-inference relations, these are explicitly identified as such.
</li><li> Laying a foundation for future evolution: enhancements to or new applications of inference will be easier to integrate into the specification.
</li></ul>
</div></li>
<li style="margin-bottom:12px;"><div> When reading this material for the first time, section <a href="#G18.1" title="Lambda G" class="mw-redirect">18.1</a> is useful for establishing the proper vocabulary; but then it may be useful for context to skip ahead to <a href="#G18.5" title="Lambda G" class="mw-redirect">18.5</a> and save the details of the algorithm (<a href="#G18.2" title="Lambda G" class="mw-redirect">18.2</a>, <a href="#G18.3" title="Lambda G" class="mw-redirect">18.3</a>, and <a href="#G18.4" title="Lambda G" class="mw-redirect">18.4</a>) for last.
</div></li></ol></div></blockquote>
<div id="G18.1"></div>
<h3> <span class="mw-headline" id="18.1_Concepts_and_Notation_.5BNew.5D"> 18.1 Concepts and Notation [New] </span></h3>
<p>This section defines <i>inference variables</i>, <i>constraint formulas</i>, and <i>bounds</i>, as the terms will be used throughout this chapter.  It also presents the notation we will use.
</p>
<div id="G18.1.1"></div>
<h3> <span class="mw-headline" id="18.1.1_Inference_Variables_.5BNew.5D"> 18.1.1 Inference Variables [New] </span></h3>
<p><i>Inference variables</i> are <i>meta-variables</i> for types—that is, they are special names that allow us to reason about types abstractly.  To distinguish them from <i>type variables</i>, we represent inference variables with Greek letters, principally <em>α</em>.
</p><p>We'll loosely use the term "type" in this chapter to include type-like syntax that contains inference variables.  We use the term <i>proper type</i> to exclude such "types" that mention inference variables.  Assertions that involve inference variables are assertions about every proper type that can be produced by replacing each inference variable with a proper type.
</p>
<div id="G18.1.2"></div>
<h3> <span class="mw-headline" id="18.1.2_Constraint_Formulas_.5BNew.5D"> 18.1.2 Constraint Formulas [New] </span></h3>
<p><span class="norm-static">
<i>Constraint formulas</i> are assertions of compatibility or subtyping that may involve inference variables.  The formulas may take one of the following forms:<span class="assertion-id"> [jsr335-18.1.2-10]</span></span>
</p>
<ul><li> <span class="norm-static"> <em>⟨Expression &rarr; T⟩</em>: An expression is compatible in a loose invocation context with type <em>T</em> (<a href="#D5" title="Lambda D" class="mw-redirect">5</a>).<span class="assertion-id"> [jsr335-18.1.2-10-A]</span></span>
</li><li> <span class="norm-static"> <em>⟨S &rarr; T⟩</em>: A type <em>S</em> is compatible in a loose invocation context with type <em>T</em> (<a href="#D5.3" title="Lambda D" class="mw-redirect">5.3</a>).<span class="assertion-id"> [jsr335-18.1.2-10-B]</span></span>
</li><li> <span class="norm-static"> <em>⟨S &lt;: T⟩</em>: A reference type <em>S</em> is a subtype of a reference type <em>T</em> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.10" class="external text" rel="nofollow">4.10</a>).<span class="assertion-id"> [jsr335-18.1.2-10-C]</span></span>
</li><li> <span class="norm-static"> <em>⟨S &lt;= T⟩</em>: A type argument <em>S</em> is contained by a type argument <em>T</em> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.5.1" class="external text" rel="nofollow">4.5.1</a>).<span class="assertion-id"> [jsr335-18.1.2-10-D]</span></span>
</li><li> <span class="norm-static"> <em>⟨S = T⟩</em>: A reference type <em>S</em> is the same as a reference type <em>T</em> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.3.4" class="external text" rel="nofollow">4.3.4</a>), or a type argument <em>S</em> is the same as type argument <em>T</em>.<span class="assertion-id"> [jsr335-18.1.2-10-E]</span></span>
</li><li> <span class="norm-static"> <em>⟨LambdaExpression &rarr;<sub><code style="background-color:inherit;font-size:medium">throws</code></sub> T⟩</em>: The checked exceptions thrown by the lambda body are declared by the <code style="background-color:inherit;font-size:medium">throws</code> clause of the function type derived from <em>T</em>.<span class="assertion-id"> [jsr335-18.1.2-10-F]</span></span>
</li><li> <span class="norm-static"> <em>⟨MethodReference &rarr;<sub><code style="background-color:inherit;font-size:medium">throws</code></sub> T⟩</em>: The checked exceptions thrown by the referenced method are declared by the <code style="background-color:inherit;font-size:medium">throws</code> clause of the function type of <em>T</em>.<span class="assertion-id"> [jsr335-18.1.2-10-F]</span></span>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div> Examples of constraint formulas:
<ul><li> From <code style="background-color:inherit;font-size:medium">Collections.singleton("hi")</code>, we have the constraint <blockquote><em>⟨<code style="background-color:inherit;font-size:medium">"hi"</code> &rarr; α⟩</em></blockquote>  Through reduction, this will become the constraint<blockquote><em>⟨<code style="background-color:inherit;font-size:medium">String</code> &lt;: α⟩</em></blockquote>
</li><li> From <code style="background-color:inherit;font-size:medium">Arrays.asList(1, 2.0)</code>, we have the constraints <blockquote><em>⟨<code style="background-color:inherit;font-size:medium">1</code> &rarr; α⟩</em><br /><em>⟨<code style="background-color:inherit;font-size:medium">2.0</code> &rarr; α⟩</em></blockquote> Through reduction, these will become the constraints <blockquote><em>⟨<code style="background-color:inherit;font-size:medium">int</code> &rarr; α⟩</em><br /><em>⟨<code style="background-color:inherit;font-size:medium">double</code> &rarr; α⟩</em></blockquote> and then <blockquote><em>⟨<code style="background-color:inherit;font-size:medium">Integer</code> &lt;: α⟩</em><br /><em>⟨<code style="background-color:inherit;font-size:medium">Double</code> &lt;: α⟩</em></blockquote>
</li><li> From the target type of the constructor invocation <code style="background-color:inherit;font-size:medium">List&lt;Thread&gt; lt = new ArrayList&lt;&gt;()</code>, we have the constraint <blockquote><em>⟨<code style="background-color:inherit;font-size:medium">ArrayList&lt;</code>α<code style="background-color:inherit;font-size:medium">&gt;</code> &rarr; <code style="background-color:inherit;font-size:medium">List&lt;Thread&gt;</code>⟩</em></blockquote>  Through reduction, this eventually becomes the constraint <blockquote><em>⟨α &lt;= <code style="background-color:inherit;font-size:medium">Thread</code>⟩</em></blockquote> and then <blockquote><em>⟨α = <code style="background-color:inherit;font-size:medium">Thread</code>⟩</em></blockquote>
</li></ul>
</div></blockquote>
<div id="G18.1.3"></div>
<h3> <span class="mw-headline" id="18.1.3_Bounds_.5BNew.5D"> 18.1.3 Bounds [New] </span></h3>
<p><span class="norm-static">
During the inference process, a set of <i>bounds</i> on inference variables is maintained.  A single bound has one of the following forms:<span class="assertion-id"> [jsr335-18.1.3-10]</span></span>
</p>
<ul><li> <span class="norm-static"> <em>S = T</em>, where at least one of <em>S</em> or <em>T</em> is an inference variable: <em>S</em> is the same as <em>T</em>.<span class="assertion-id"> [jsr335-18.1.3-10-A]</span></span>
</li><li> <span class="norm-static"> <em>S &lt;: T</em>, where at least one of <em>S</em> or <em>T</em> is an inference variable: <em>S</em> is a subtype of <em>T</em>.<span class="assertion-id"> [jsr335-18.1.3-10-B]</span></span>
</li><li> <span class="norm-static"> <em>false</em>: No valid choice of inference variables exists.<span class="assertion-id"> [jsr335-18.1.3-10-C]</span></span>
</li><li> <span class="norm-static"> <em>G<code style="background-color:inherit;font-size:medium">&lt;</code>α<sub>1</sub>, ..., α<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code> = capture(G<code style="background-color:inherit;font-size:medium">&lt;</code>A<sub>1</sub>, ..., A<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code>)</em>: The variables <em>α<sub>1</sub></em>, ..., <em>α<sub>n</sub></em> represent the result of capture conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.10" class="external text" rel="nofollow">5.1.10</a>) applied to <em>G<code style="background-color:inherit;font-size:medium">&lt;</code>A<sub>1</sub>, ..., A<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em> (where <em>A<sub>1</sub></em>, ..., <em>A<sub>n</sub></em> may be types or wildcards and may mention inference variables).<span class="assertion-id"> [jsr335-18.1.3-10-D]</span></span>
</li><li> <span class="norm-static"> <em><code style="background-color:inherit;font-size:medium">throws</code> α</em>: The inference variable <em>α</em> appears in a <code style="background-color:inherit;font-size:medium">throws</code> clause.<span class="assertion-id"> [jsr335-18.1.3-10-E]</span></span>
</li></ul>
<p><span class="norm-static">
A bound is <i>satisfied</i> by an inference variable substitution if, after applying the substitution, the assertion is true.  (The bound <em>false</em> can never be satisfied.)<span class="assertion-id"> [jsr335-18.1.3-20]</span></span>
</p><p><span class="norm-static">
Some bounds relate an inference variable to a proper type.  Let <em>T</em> be a proper type.  Given a bound of the form <em>α = T</em> or <em>T = α</em>, we say <em>T</em> as an <i>instantiation</i> of <em>α</em>.  Similarly, given a bound of the form <em>α &lt;: T</em>, we say <em>T</em> is a <i>proper upper bound</i> of <em>α</em>, and given a bound of the form <em>T &lt;: α</em>, we say <em>T</em> is a <i>proper lower bound</i> of <em>α</em>.<span class="assertion-id"> [jsr335-18.1.3-30]</span></span>
</p><p><span class="norm-static">
Other bounds relate two inference variables, or an inference variable to a type that contains inference variables.  Such bounds, of the form <em>S = T</em> or <em>S &lt;: T</em>, are called <i>dependencies</i>.<span class="assertion-id"> [jsr335-18.1.3-40]</span></span>
</p><p>A bound of the form <em>G<code style="background-color:inherit;font-size:medium">&lt;</code>α<sub>1</sub>, ..., α<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code> = capture(G<code style="background-color:inherit;font-size:medium">&lt;</code>A<sub>1</sub>, ..., A<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code>)</em> indicates that <em>α<sub>1</sub></em>, ..., <em>α<sub>n</sub></em> are placeholders for the results of capture.  This is necessary because capture conversion can only be performed on a proper type, and the inference variables in <em>A<sub>1</sub></em>, ..., <em>A<sub>n</sub></em> may not yet be resolved.
</p><p>A bound of the form <em><code style="background-color:inherit;font-size:medium">throws</code> α</em> is purely informational: it directs resolution to optimize the instantiation of <em>α</em> so that, if possible, it is not a checked exception.
</p><p>An important intermediate result of inference is a <i>bound set</i>.  It is sometimes convenient to refer to an <i>empty</i> bound set with the literal <em>true</em>; this is merely out of convenience, and the two are interchangeable.
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div> Examples of bound sets:
<ul><li> <em>{ α = <code style="background-color:inherit;font-size:medium">String</code> }</em> contains a single bound, instantiating <em>α</em> as <code style="background-color:inherit;font-size:medium">String</code>.
</li><li> <em>{ <code style="background-color:inherit;font-size:medium">Integer</code> &lt;: α, <code style="background-color:inherit;font-size:medium">Double</code> &lt;: α, α &lt;: <code style="background-color:inherit;font-size:medium">Object</code> }</em> describes two proper lower bounds and one proper upper bound for <em>α</em>.
</li><li> <em>{ α &lt;: <code style="background-color:inherit;font-size:medium">Iterable&lt;?&gt;</code>, β &lt;: <code style="background-color:inherit;font-size:medium">Object</code>, α &lt;: <code style="background-color:inherit;font-size:medium">List&lt;</code>β<code style="background-color:inherit;font-size:medium">&gt;</code> }</em> describes a proper upper bound for each of <em>α</em> and <em>β</em>, along with a dependency between them.
</li><li> <em>{ }</em> contains no bounds nor dependencies, and can be referred to as <em>true</em>.
</li><li> <em>{ false }</em> expresses the fact that no satisfactory instantiation exists.
</li></ul>
</div></blockquote>
<p><span class="norm-static">
When inference begins, a bound set is typically generated from a list of type parameter declarations <em>P<sub>1</sub>, ..., P<sub>p</sub></em> and associated inference variables <em>α<sub>1</sub>, ..., α<sub>p</sub></em>.  Such a bound set is constructed as follows.  For each <em>l</em> (<em>1 ≤ l ≤ p</em>):<span class="assertion-id"> [jsr335-18.1.4-80]</span></span>
</p>
<ul><li> <span class="norm-static"> If <em>P<sub>l</sub></em> has no <i>TypeBound</i>, the bound <em>α<sub>l</sub> &lt;: <code style="background-color:inherit;font-size:medium">Object</code></em> appears in the set.<span class="assertion-id"> [jsr335-18.1.4-80-A]</span></span>
</li><li> <span class="norm-static"> Otherwise, for each type <em>T</em> delimited by <code style="background-color:inherit;font-size:medium">&amp;</code> in the <i>TypeBound</i>, the bound <em>α<sub>l</sub> &lt;: T [P<sub>1</sub>:=α<sub>1</sub>, ..., P<sub>p</sub>:=α<sub>p</sub>]</em> appears in the set; if this results in no proper upper bounds for <em>α<sub>l</sub></em> (only dependencies), then the bound <em>α<sub>l</sub> &lt;: <code style="background-color:inherit;font-size:medium">Object</code></em> also appears in the set.<span class="assertion-id"> [jsr335-18.1.4-80-B]</span></span>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
The strategy described here of decomposing a <i>TypeBound</i> into individual types separated by <code style="background-color:inherit;font-size:medium">&amp;</code>, allowing some components to be treated as proper bounds and others as dependencies, is a slight enhancement to the JLS 7 behavior, which treats the bound as a monolithic intersection type.</div></blockquote>
<div id="G18.2"></div>
<h3> <span class="mw-headline" id="18.2_Reduction_.5BNew.5D"> 18.2 Reduction [New] </span></h3>
<p><i>Reduction</i> is the process by which a set of constraint formulas (<a href="#G18.1.2" title="Lambda G" class="mw-redirect">18.1.2</a>) is simplified to produce a bound set (<a href="#G18.1.3" title="Lambda G" class="mw-redirect">18.1.3</a>).
</p><p>Each constraint formula is considered in turn.  A "current" bound set is initially empty.  The rules in this section outline how the formula is reduced to one or both of:
</p>
<ul><li> A bound or bound set, which is to be incorporated with the current bound set
</li><li> Further constraint formulas, which are to be reduced recursively
</li></ul>
<p>Reduction completes when no further constraint formulas remain to be reduced.
</p><p>The results of a reduction step are always <i>soundness-preserving</i>: if an inference variable instantiation satisfies the reduced constraints and bounds, it will also satisfy the original constraint.  On the other hand, reduction is not <i>completeness-preserving</i>: there may exist inference variable instantiations that satisfy the original constraint but <i>do not</i> satisfy a reduced constraint or bound.  This is due to inherent limitations of the algorithm, along with a desire to avoid undue complexity.  One effect is that there are expressions for which type argument inference fails to find a solution, but that can be well-typed if the programmer explicitly inserts appropriate types.
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p><p>The reduction rules defined in JLS 7 are neither soundness- nor completeness-preserving.  The reduction rules described here improve upon this by guaranteeing soundness and reducing the set of invocations which inference is unable to handle.  The rules are also, of course, expanded to support the new language features.
</p><p>Unsoundness in JLS 7 arises, among other things, out of the fact that <em>false</em> and <em>true</em> results are treated interchangeably—neither has any impact on the current bound set.  It is not a fundamental type safety problem, because the results of inference are checked for validity before an expression is considered well-typed.  But it has the unfortunate effect of covering up bugs: if the spec misses an important constraint, there's not a hard line that says that's "wrong."  The claim of soundness here raises the bar: if the rules miss a constraint that is necessary to guarantee that the initial constraint formula is true, that is a failing of the rules, and it must be corrected to make the spec internally consistent.
</p>
In addition, a soundness-preserving approach avoids the potential confusion that could arise if, say, inference unsoundly ignored certain difficult-to-analyze lambda expression arguments.  (The effect might be that inference gets "lucky" in guessing valid type arguments in one scenario, only to fail when a seemingly unrelated adjustment changes the results.)</div></blockquote>
<div id="G18.2.1"></div>
<h3> <span class="mw-headline" id="18.2.1_Expression_Compatibility_Constraints_.5BNew.5D"> 18.2.1 Expression Compatibility Constraints [New] </span></h3>
<p><span class="norm-static">
A constraint formula of the form <em>⟨Expression &rarr; T⟩</em> is reduced as follows:<span class="assertion-id"> [jsr335-18.2.1-10]</span></span>
</p>
<ul><li> <span class="norm-static"> If <em>T</em> is a proper type, the constraint reduces to <em>true</em> if the expression is compatible in a loose invocation context with <em>T</em> (<a href="#D5" title="Lambda D" class="mw-redirect">5</a>), and <em>false</em> otherwise.<span class="assertion-id"> [jsr335-18.2.1-10-A]</span></span>
</li><li> <span class="norm-static"> Otherwise, if the expression is a standalone expression (<a href="#D15.2" title="Lambda D" class="mw-redirect">15.2</a>) of type <em>S</em>, the constraint reduces to <em>⟨S &rarr; T⟩</em>.<span class="assertion-id"> [jsr335-18.2.1-10-B]</span></span>
</li><li> <span class="norm-static"> Otherwise, the expression is a poly expression (<a href="#D15.2" title="Lambda D" class="mw-redirect">15.2</a>).  The result depends on the form of the expression:<span class="assertion-id"> [jsr335-18.2.1-10-C]</span></span>
<ul><li> <span class="norm-static"> If the expression is a parenthesized expression of the form <em><code style="background-color:inherit;font-size:medium">(</code> Expression' <code style="background-color:inherit;font-size:medium">)</code></em>, the constraint reduces to <em>⟨Expression' &rarr; T⟩</em>.<span class="assertion-id"> [jsr335-18.2.1-10-C1]</span></span>
</li><li> <span class="norm-static"> If the expression is a class instance creation expression or a method invocation, the constraint reduces to the bound set <em>B<sub>3</sub></em> which would be used to determine the expression's invocation type when targeting <em>T</em>, as defined in <a href="#G18.5.2" title="Lambda G" class="mw-redirect">18.5.2</a> (in the case of a class instance creation, the corresponding "method" used for inference is defined in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.3" class="external text" rel="nofollow">15.9.3</a>).<span class="assertion-id"> [jsr335-18.2.1-10-C2]</span></span><p>This bound set may contain new inference variables, as well as dependencies between these new variables and the inference variables in <em>T</em>.</p>
</li><li> <span class="norm-static"> If the expression is a conditional operator expression of the form <em>Expression<sub>1</sub> <code style="background-color:inherit;font-size:medium">?</code> Expression<sub>2</sub> <code style="background-color:inherit;font-size:medium">:</code> Expression<sub>3</sub></em>, the constraint reduces to two constraint formulas, <em>⟨Expression<sub>2</sub> &rarr; T⟩</em> and <em>⟨Expression<sub>3</sub> &rarr; T⟩</em>.<span class="assertion-id"> [jsr335-18.2.1-10-C3]</span></span>
</li><li> <span class="norm-static"> If the expression is a lambda expression, the result is defined in section <a href="#G18.2.1.1" title="Lambda G" class="mw-redirect">18.2.1.1</a>.<span class="assertion-id"> [jsr335-18.2.1-10-C4]</span></span>
</li><li> <span class="norm-static"> If the expression is a method reference, the result is defined in section <a href="#G18.2.1.2" title="Lambda G" class="mw-redirect">18.2.1.2</a>.<span class="assertion-id"> [jsr335-18.2.1-10-C5]</span></span>
</li></ul>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> By treating nested generic method invocations as poly expressions, we improve the behavior of inference for nested invocations.  For example, the following is illegal in Java 7 but legal in Java 8:
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">ProcessBuilder b = new ProcessBuilder(Collections.emptyList());
// Constructor expects a List&lt;String&gt;</pre>
<p>When <i>both</i> the outer and the nested invocation require inference, the problem is more difficult.  For example:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">List&lt;String&gt; ls = new ArrayList&lt;&gt;(Collections.emptyList());</pre>
<p>Our approach is to "lift" the bounds inferred for the nested invocation (simply <em>{ α &lt;: <code style="background-color:inherit;font-size:medium">Object</code> }</em> in the case of <code style="background-color:inherit;font-size:medium">emptyList</code> here) into the outer inference process (in this case, trying to infer <em>β</em> where the constructor is for type <em><code style="background-color:inherit;font-size:medium">ArrayList&lt;</code>β<code style="background-color:inherit;font-size:medium">&gt;</code></em>).  We also infer dependencies between the nested inference variables and the outer inference variables (the constraint <em>⟨<code style="background-color:inherit;font-size:medium">List&lt;</code>α<code style="background-color:inherit;font-size:medium">&gt;</code> &rarr; <code style="background-color:inherit;font-size:medium">Collection&lt;</code>β<code style="background-color:inherit;font-size:medium">&gt;</code>⟩</em> would reduce to the dependency <em>α = β</em>).  In this way, resolution of the inference variables in the nested invocation can wait until additional information can be inferred from the outer invocation (based on the assignment target, <em>β = <code style="background-color:inherit;font-size:medium">String</code></em>).
</p>
</div></li>
<li style="margin-bottom:12px;"><div> An alternative strategy for handling nested invocations was considered and rejected: in certain cases, the inference variables of the outer call are resolved before considering the nested call; typing of the nested call is delayed until a proper target type can be provided.  In other cases, the nested call is treated as a standalone invocation.
<p>This has the advantage of avoiding the extra complexity involved with reduction producing new inference variables and dependencies.  But there are two problems with this approach:
</p>
<ul><li> It is not powerful enough to handle situations in which information from both the outer and inner calls needs to be synthesized in order to choose an appropriate inference variable instantiation.
</li><li> There's not an obvious rule for choosing whether the outer or the inner call should be resolved first, and so the resulting behavior is very ad hoc.
</li></ul>
</div></li></ol></div></blockquote>
<div id="G18.2.1.1"></div>
<h3> <span class="mw-headline" id="18.2.1.1_Lambda_Expression_Compatibility_.5BNew.5D"> 18.2.1.1 Lambda Expression Compatibility [New] </span></h3>
<p><span class="norm-static">
A constraint formula of the form <em>⟨LambdaExpression &rarr; T⟩</em>, where <em>T</em> mentions at least one inference variable, is reduced as follows, following the compatibility rules outlined in <a href="#E15.27.3" title="Lambda E" class="mw-redirect">15.27.3</a>.<span class="assertion-id"> [jsr335-18.2.1.2-10]</span></span>
</p><p><span class="norm-static">
If <em>T</em> is not a functional interface type (<a href="#A9.8" title="Lambda A" class="mw-redirect">9.8</a>), the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.1.2-14]</span></span>
</p><p><span class="norm-static">
Otherwise, a ground target type, <em>T'</em>, must be derived from <em>T</em>, as described in <a href="#E15.27.3" title="Lambda E" class="mw-redirect">15.27.3</a>.  If <a href="#G18.5.3" title="Lambda G" class="mw-redirect">18.5.3</a> is used to derive a functional interface parameterization, then the test that <em>F<code style="background-color:inherit;font-size:medium">&lt;</code>A'<sub>1</sub>, ..., A'<sub>m</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em> is a subtype of <em>F<code style="background-color:inherit;font-size:medium">&lt;</code>A<sub>1</sub>, ..., A<sub>m</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em> is not performed (this is instead asserted with a constraint formula below).  If no valid type can be found, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.1.2-20]</span></span>
</p><p><span class="norm-static">
Otherwise, the congruence of the <em>LambdaExpression</em> with the function type of <em>T'</em> is asserted as follows:<span class="assertion-id"> [jsr335-18.2.1.2-30]</span></span>
</p>
<ul><li> <span class="norm-static"> If the number of lambda parameters differs from the number of parameter types of the function type, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.1.2-30-A]</span></span>
</li><li> <span class="norm-static"> If the lambda expression is implicitly-typed and one or more of the function type's parameter types is not a proper type, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.1.2-30-H]</span></span>
</li><li> <span class="norm-static"> If the function type's return type is <code style="background-color:inherit;font-size:medium">void</code> and the lambda body is neither a statement expression nor a void-compatible block, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.1.2-30-D]</span></span>
</li><li> <span class="norm-static"> If the function type's return type is not <code style="background-color:inherit;font-size:medium">void</code> and the lambda body is a block that is not value-compatible, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.1.2-30-E]</span></span>
</li><li> <span class="norm-static"> Otherwise, the constraint reduces to all of the following simplified constraints:<span class="assertion-id"> [jsr335-18.2.1.2-30-F]</span></span>
<ul><li> <span class="norm-static"> If the lambda parameters have explicitly-declared types <em>F<sub>1</sub>, ..., F<sub>n</sub></em> and the targeted function type has parameter types <em>G<sub>1</sub>, ..., G<sub>n</sub></em>, then for all <em>i</em>, <em>1 ≤ i ≤ n</em>, <em>⟨F<sub>i</sub> = G<sub>i</sub>⟩</em>; in addition, <em>⟨T' &lt;: T⟩</em>.<span class="assertion-id"> [jsr335-18.2.1.2-30-F1]</span></span>
</li><li> <span class="norm-static"> If the function type's return type is a (non-<code style="background-color:inherit;font-size:medium">void</code>) type <em>R</em>, assume the lambda's parameter types are the same as the function type's parameter types.  Then:<span class="assertion-id"> [jsr335-18.2.1.2-30-F2]</span></span>
<ul><li> <span class="norm-static"> If <em>R</em> is a proper type, and if the lambda body or some result expression in the lambda body is not compatible in an assignment context with <em>R</em>, <em>false</em>.<span class="assertion-id"> [jsr335-18.2.1.2-30-F21]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>R</em> is not a proper type, then where the lambda body has the form <em>Expression</em>, the constraint <em>⟨Expression &rarr; R⟩</em>; or where the lambda body is a block with result expressions <em>Expression<sub>1</sub>, ..., Expression<sub>m</sub></em>, for all <em>i</em>, <em>1 ≤ i ≤ m</em>, <em>⟨Expression<sub>i</sub> &rarr; R⟩</em>.<span class="assertion-id"> [jsr335-18.2.1.2-30-F22]</span></span>
</li></ul>
</li></ul>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> The key piece of information to derive from a compatibility constraint involving a lambda expression is the set of bounds on inference variables appearing in the target function type's return type.  This is crucial, because functional interfaces are often generic, and many methods operating on these types are generic, too.
<p>In the simplest case, a lambda expression may simply provide a lower bound for an inference variable:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
&lt;T&gt; List&lt;T&gt; makeThree(Factory&lt;T&gt; factory) { ... }
String s = makeThree(() -&gt; &quot;abc&quot;).get(2);
</pre>
<p>In more complex cases, a result expression may be a poly expression—perhaps even another lambda expression—and so the inference variable might be passed through multiple constraint formulas with different target types before a bound is produced.
</p><p>Most of the work described in this section precedes assertions about the result expressions; its purpose is to derive the lambda expression's function type, and to check for expressions that are clearly disqualified from compatibility.
</p><p>We do <i>not</i> attempt to produce bounds on inference variables that appear in the target function type's <code style="background-color:inherit;font-size:medium">throws</code> clause.  This is because exception containment is not part of compatibility (<a href="#E15.27.3" title="Lambda E" class="mw-redirect">15.27.3</a>)—in particular, it must not influence method applicability (<a href="#G18.5.1" title="Lambda G" class="mw-redirect">18.5.1</a>).  However, we <i>do</i> get bounds on these variables later, because invocation type inference (<a href="#G18.5.2" title="Lambda G" class="mw-redirect">18.5.2</a>) produces exception containment constraint formulas (<a href="#G18.2.5" title="Lambda G" class="mw-redirect">18.2.5</a>).
</p>
</div></li>
<li style="margin-bottom:12px;"><div> If the target type is an inference variable, or if the target type's parameter types contain inference variables, we produce <em>false</em>.  During invocation type inference (<a href="#G18.5.2" title="Lambda G" class="mw-redirect">18.5.2</a>), extra substitutions are performed in order to instantiate these inference variables, thus avoiding this scenario.  (In other words, reduction will, in practice, never be "invoked" with a target type of one of these forms.)
</div></li>
<li style="margin-bottom:12px;"><div> The result expressions of a lambda expression are required to be compatible in an <i>assignment</i> context with the target return type (see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.27.3" class="external text" rel="nofollow">15.27.3</a>).  Consider a targeted return type, <em>R</em>.  If <em>R</em> is a proper type (e.g., <code style="background-color:inherit;font-size:medium">Byte</code> derived from <code style="background-color:inherit;font-size:medium">Function&lt;<em>α</em>,Byte&gt;</code>), assignability is easy enough to test, and we do so.  If <em>R</em> is <i>not</i> a proper type (e.g., <em>α</em> derived from <code style="background-color:inherit;font-size:medium">Function&lt;String,<em>α</em>&gt;</code>), we make the simplifying assumption that <i>loose invocation</i> compatibility will be sufficient.
<p>The difference between assignment compatibility and loose invocation compatibility is that assignment allows narrowing of constant expressions (e.g., <code style="background-color:inherit;font-size:medium">Byte b = 100</code>).  So this simplifying assumption is not completeness-preserving: given target return type <em>α</em> and an integer literal return expression, <code style="background-color:inherit;font-size:medium">100</code>, it is possible that <em>α</em> could be instantiated to <code style="background-color:inherit;font-size:medium">Byte</code>; however, reduction will not produce such a bound.
</p>
</div></li></ol></div></blockquote>
<div id="G18.2.1.2"></div>
<h3> <span class="mw-headline" id="18.2.1.2_Method_Reference_Compatibility_.5BNew.5D"> 18.2.1.2 Method Reference Compatibility [New] </span></h3>
<p><span class="norm-static">
A constraint formula of the form <em>⟨MethodReference &rarr; T⟩</em>, where <em>T</em> mentions at least one inference variable, is reduced as follows, following the compatibility rules outlined in <a href="#E15.13.1" title="Lambda E" class="mw-redirect">15.13.1</a>.<span class="assertion-id"> [jsr335-18.2.1.3-10]</span></span>
</p><p><span class="norm-static">
If <em>T</em> is not a functional interface type (<a href="#A9.8" title="Lambda A" class="mw-redirect">9.8</a>), or if <em>T</em> <i>is</i> a functional interface type but does not have a function type, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.1.3-12]</span></span>
</p><p><span class="norm-static">
Otherwise, if there does not exist a potentially-applicable method for the method reference when targeting <em>T</em> (<a href="#E15.13.1" title="Lambda E" class="mw-redirect">15.13.1</a>), the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.1.3-20]</span></span>
</p><p><span class="norm-static">
Otherwise, there are two cases.  If the method reference is <i>exact</i> (<a href="#E15.13.1" title="Lambda E" class="mw-redirect">15.13.1</a>), then let <em>P<sub>1</sub>, ..., P<sub>n</sub></em> be the parameter types of the function type of <em>T</em>; let <em>P'<sub>1</sub>, ..., P'<sub>k</sub></em> be the parameter types of the potentially-applicable method.  The compatibility constraint reduces to a new set of constraints, as follows:<span class="assertion-id"> [jsr335-18.2.1.3-30]</span></span>
</p>
<ul><li> <span class="norm-static"> For the special case in which <em>n = k+1</em> (that is, the parameter of type <em>P<sub>1</sub></em> is to act as the target reference of the invocation), <em>⟨P<sub>1</sub> &lt;: ReferenceType⟩</em> and, for all <em>i</em>, <em>2 ≤ i ≤ n</em>, <em>⟨P<sub>i</sub> &rarr; P'<sub>i-1</sub>⟩</em>.<span class="assertion-id"> [jsr335-18.2.1.3-30-A]</span></span>
</li><li> <span class="norm-static"> In all other cases, <em>n = k</em>.  The constraints include, for all <em>i</em>, <em>1 ≤ i ≤ n</em>, <em>⟨P<sub>i</sub> &rarr; P'<sub>i</sub>⟩</em>.<span class="assertion-id"> [jsr335-18.2.1.3-30-B]</span></span>
</li><li> <span class="norm-static"> If the function type's return type is not <code style="background-color:inherit;font-size:medium">void</code>, let <em>R</em> be this type.  Then if the return type of the potentially-applicable compile-time declaration is <code style="background-color:inherit;font-size:medium">void</code>, the constraint reduces to <em>false</em>.  Otherwise, where <em>R'</em> is the result of applying capture conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.10" class="external text" rel="nofollow">5.1.10</a>) to the return type of the potentially-applicable compile-time declaration, <em>⟨R' &rarr; R⟩</em>.<span class="assertion-id"> [jsr335-18.2.1.3-30-C]</span></span>
</li></ul>
<p><span class="norm-static">
If, instead, the method reference is <i>inexact</i> (<a href="#E15.13.1" title="Lambda E" class="mw-redirect">15.13.1</a>), then if one or more of the function type's parameter types is not a proper type, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.1.3-35]</span></span>
</p><p><span class="norm-static">
Otherwise, a search for a compile-time declaration is performed, as defined in <a href="#E15.13.1" title="Lambda E" class="mw-redirect">15.13.1</a>.  If there does not exist a compile-time declaration for the method reference, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.1.3-16]</span></span>
</p><p><span class="norm-static">
If a compile-time declaration can be found then there are three cases:<span class="assertion-id"> [jsr335-18.2.1.3-40]</span></span>
</p>
<ul><li> <span class="norm-static"> If the return type of the function type is <code style="background-color:inherit;font-size:medium">void</code>, the constraint reduces to is <em>true</em>.<span class="assertion-id"> [jsr335-18.2.1.3-40-A]</span></span>
</li><li> <span class="norm-static"> Otherwise, if i) the method reference elides <em>NonWildTypeArguments</em>, ii) the compile-time declaration is a generic method, and iii) the return type of the compile-time declaration mentions at least one of the method's type parameters; then the constraint reduces to the bound set <em>B<sub>3</sub></em> which would be used to determine the method reference's invocation type when targeting the return type of the function type, as defined in <a href="#G18.5.2" title="Lambda G" class="mw-redirect">18.5.2</a>.<span class="assertion-id"> [jsr335-18.2.1.3-40-C]</span></span><p>This bound set may contain new inference variables, as well as dependencies between these new variables and the inference variables in <em>T</em>.</p>
</li><li> <span class="norm-static"> Otherwise, let <em>R</em> be the return type of the function type, and let <em>R'</em> be the result of applying capture conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.10" class="external text" rel="nofollow">5.1.10</a>) to the return type of the invocation type (<a href="#F15.12.2.6" title="Lambda F" class="mw-redirect">15.12.2.6</a>) of the chosen declaration.  If <em>R'</em> is <code style="background-color:inherit;font-size:medium">void</code>, the constraint reduces to <em>false</em>; otherwise, the constraint reduces to <em>⟨R' &rarr; R⟩</em>.<span class="assertion-id"> [jsr335-18.2.1.3-40-B]</span></span>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
The strategy used to determine a return type for a generic referenced method follows the same pattern as for generic method invocations (<a href="#G18.2.1" title="Lambda G" class="mw-redirect">18.2.1</a>).  This may involve "lifting" bounds into the outer context and inferring dependencies between the two sets of inference variables.</div></blockquote>
<div id="G18.2.2"></div>
<h3> <span class="mw-headline" id="18.2.2_Type_Compatibility_Constraints_.5BNew.5D"> 18.2.2 Type Compatibility Constraints [New] </span></h3>
<p><span class="norm-static">
A constraint formula of the form <em>⟨S &rarr; T⟩</em> is reduced as follows:<span class="assertion-id"> [jsr335-18.2.2-10]</span></span>
</p>
<ul><li> <span class="norm-static"> If <em>S</em> and <em>T</em> are proper types, the constraint reduces to <em>true</em> if <em>S</em> is compatible in a loose invocation context with <em>T</em> (<a href="#D5.3" title="Lambda D" class="mw-redirect">5.3</a>), and <em>false</em> otherwise.<span class="assertion-id"> [jsr335-18.2.2-10-A]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>S</em> is a primitive type, let <em>S'</em> be the result of applying boxing conversion (<a href="#G5.1.7" title="Lambda G" class="mw-redirect">5.1.7</a>) to <em>S</em>.  Then the constraint reduces to <em>⟨S' &rarr; T⟩</em>.<span class="assertion-id"> [jsr335-18.2.2-10-B]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>T</em> is a primitive type, let <em>T'</em> be the result of applying boxing conversion (<a href="#G5.1.7" title="Lambda G" class="mw-redirect">5.1.7</a>) to <em>T</em>.  Then the constraint reduces to <em>⟨S = T'⟩</em>.<span class="assertion-id"> [jsr335-18.2.2-10-C]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>T</em> is a parameterized type of the form <em>G<code style="background-color:inherit;font-size:medium">&lt;</code>T<sub>1</sub>, ..., T<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em>, and there exists no type of the form <em>G<code style="background-color:inherit;font-size:medium">&lt;</code>...<code style="background-color:inherit;font-size:medium">&gt;</code></em> that is a supertype (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.10" class="external text" rel="nofollow">4.10</a>) of <em>S</em>, but the raw type <em>G</em> is a supertype of <em>S</em>, then the constraint reduces to <em>true</em>.<span class="assertion-id"> [jsr335-18.2.2-10-E]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>T</em> is an array type of the form <em>G<code style="background-color:inherit;font-size:medium">&lt;</code>T<sub>1</sub>, ..., T<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code><code style="background-color:inherit;font-size:medium">[]</code><sup>k</sup></em>, and there exists no type of the form <em>G<code style="background-color:inherit;font-size:medium">&lt;</code>...<code style="background-color:inherit;font-size:medium">&gt;</code><code style="background-color:inherit;font-size:medium">[]</code><sup>k</sup></em> that is a supertype of <em>S</em>, but the raw type <em>G<code style="background-color:inherit;font-size:medium">[]</code><sup>k</sup></em> is a supertype of <em>S</em>, then the constraint reduces to <em>true</em>.  (The notation <em><code style="background-color:inherit;font-size:medium">[]</code><sup>k</sup></em> indicates an array type of <em>k</em> dimensions.)<span class="assertion-id"> [jsr335-18.2.2-10-F]</span></span>
</li><li> <span class="norm-static"> Otherwise, the constraint reduces to <em>⟨S &lt;: T⟩</em>.<span class="assertion-id"> [jsr335-18.2.2-10-D]</span></span>
</li></ul>
<p><span class="norm-static">
The fourth and fifth cases are considered uses of unchecked conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.9" class="external text" rel="nofollow">5.1.9</a>).  These, along with any use of unchecked conversion in the first case, may result in unchecked warnings, and may influence a method's invocation type (<a href="#F15.12.2.6" title="Lambda F" class="mw-redirect">15.12.2.6</a>).<span class="assertion-id"> [jsr335-18.2.2-12]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> Boxing <em>T</em> to <em>T'</em> is not completeness-preserving: for example, if <em>T</em> were <code style="background-color:inherit;font-size:medium">long</code>, <em>S</em> might be instantiated to <code style="background-color:inherit;font-size:medium">Integer</code>, which is not a subtype of <code style="background-color:inherit;font-size:medium">Long</code>, but could be unboxed and then widened to <code style="background-color:inherit;font-size:medium">long</code>.  We avoid this problem in most cases by giving special treatment to inference-variable return types that we know are already constrained to be certain boxed primitive types.  See <a href="#G18.5.2" title="Lambda G" class="mw-redirect">18.5.2</a>.
</div></li>
<li style="margin-bottom:12px;"><div> Similarly, the treatment of unchecked conversion sacrifices completeness in cases in which <em>T</em> is not a parameterized type (for example, if <em>T</em> is an inference variable).  It is not usually clear in such situations whether the unchecked conversion is necessary or not.  Since unchecked conversions introduce unchecked warnings, inference prefers to avoid them unless it is clearly necessary.
</div></li></ol></div></blockquote>
<div id="G18.2.3"></div>
<h3> <span class="mw-headline" id="18.2.3_Subtyping_Constraints_.5BNew.5D"> 18.2.3 Subtyping Constraints [New] </span></h3>
<p><span class="norm-static">
A constraint formula of the form <em>⟨S &lt;: T⟩</em> is reduced as follows:<span class="assertion-id"> [jsr335-18.2.3-10]</span></span>
</p>
<ul><li> <span class="norm-static"> If <em>S</em> and <em>T</em> are proper types, the constraint reduces to <em>true</em> if <em>S</em> is a subtype of <em>T</em> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.10" class="external text" rel="nofollow">4.10</a>), and <em>false</em> otherwise.<span class="assertion-id"> [jsr335-18.2.3-10-A]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>S</em> is the null type, the constraint reduces to <em>true</em>.<span class="assertion-id"> [jsr335-18.2.3-10-D]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>T</em> is the null type, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.3-10-E6]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>S</em> is an inference variable, <em>α</em>, the constraint reduces to the bound <em>α &lt;: T</em>.<span class="assertion-id"> [jsr335-18.2.3-10-B]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>T</em> is an inference variable, <em>α</em>, the constraint reduces to the bound <em>S &lt;: α</em>.<span class="assertion-id"> [jsr335-18.2.3-10-C]</span></span>
</li><li> <span class="norm-static"> Otherwise, the constraint is reduced according to the form of <em>T</em>:<span class="assertion-id"> [jsr335-18.2.3-10-E]</span></span>
<ul><li> <span class="norm-static"> If <em>T</em> is a parameterized class or interface type, or an inner class type of a parameterized class or interface type (directly or indirectly), let <em>A<sub>1</sub>, ..., A<sub>n</sub></em> be the type arguments appearing in <em>T</em>; among the supertypes (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.10" class="external text" rel="nofollow">4.10</a>) of <em>S</em>, a corresponding class or interface type is identified, with type arguments <em>B<sub>1</sub>, ..., B<sub>n</sub></em>.  If no such type exists, the constraint reduces to <em>false</em>.  Otherwise, the constraint reduces to the following new constraints: for all <em>i</em>, <em>1 ≤ i ≤ n</em>, <em>⟨B<sub>i</sub> &lt;= A<sub>i</sub>⟩</em>.<span class="assertion-id"> [jsr335-18.2.3-10-E2]</span></span>
</li><li> <span class="norm-static"> If <em>T</em> is any other class or interface type, then the constraint reduces to <em>true</em> if <em>T</em> is among the supertypes of <em>S</em>, and <em>false</em> otherwise.<span class="assertion-id"> [jsr335-18.2.3-10-E1]</span></span>
</li><li> <span class="norm-static"> If <em>T</em> is an array type, <em>T'<code style="background-color:inherit;font-size:medium">[]</code></em>, then among the supertypes of <em>S</em> that are array types, a most-specific type is identified: <em>S'<code style="background-color:inherit;font-size:medium">[]</code></em> (this may be <em>S</em> itself).  If no such array type exists, the constraint reduces to <em>false</em>.  Otherwise:<span class="assertion-id"> [jsr335-18.2.3-10-E3]</span></span>
<ul><li> <span class="norm-static"> If neither <em>S'</em> nor <em>T'</em> is a primitive type, the constraint reduces to <em>⟨S' &lt;: T'⟩</em>.<span class="assertion-id"> [jsr335-18.2.3-10-E31]</span></span>
</li><li> <span class="norm-static"> Otherwise, the constraint reduces to <em>true</em> if <em>S'</em> and <em>T'</em> are the same primitive type, and <em>false</em> otherwise.<span class="assertion-id"> [jsr335-18.2.3-10-E32]</span></span>
</li></ul>
</li><li> <span class="norm-static"> If <em>T</em> is a type variable, there are three cases:<span class="assertion-id"> [jsr335-18.2.3-10-E4]</span></span>
<ul><li> <span class="norm-static"> If <em>S</em> is an intersection type of which <em>T</em> is an element, the constraint reduces to <em>true</em>.<span class="assertion-id"> [jsr335-18.2.3-10-E41]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>T</em> has a lower bound, <em>B</em>, the constraint reduces to <em>⟨S &lt;: B⟩</em>.<span class="assertion-id"> [jsr335-18.2.3-10-E42]</span></span>
</li><li> <span class="norm-static"> Otherwise, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.3-10-E43]</span></span>
</li></ul>
</li><li> <span class="norm-static"> If <em>T</em> is an intersection type, <em>I<sub>1</sub><code style="background-color:inherit;font-size:medium"> &amp; </code>...<code style="background-color:inherit;font-size:medium"> &amp; </code>I<sub>n</sub></em>, the constraint reduces to the following new constraints: for all <em>i</em>, <em>1 ≤ i ≤ n</em>, <em>⟨S &lt;: I<sub>i</sub>⟩</em>.<span class="assertion-id"> [jsr335-18.2.3-10-E5]</span></span>
</li></ul>
</li></ul>
<p><span class="norm-static">
A constraint formula of the form <em>⟨S &lt;= T⟩</em>, where <em>S</em> and <em>T</em> are type arguments (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.5.1" class="external text" rel="nofollow">4.5.1</a>), is reduced as follows:<span class="assertion-id"> [jsr335-18.2.3-20]</span></span>
</p>
<ul><li> <span class="norm-static"> If <em>T</em> is a type:<span class="assertion-id"> [jsr335-18.2.3-20-A]</span></span>
<ul><li> <span class="norm-static"> If <em>S</em> is a type, the constraint reduces to <em>⟨S = T⟩</em>.<span class="assertion-id"> [jsr335-18.2.3-20-A1]</span></span>
</li><li> <span class="norm-static"> If <em>S</em> is a wildcard, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.3-20-A2]</span></span>
</li></ul>
</li><li> <span class="norm-static"> If <em>T</em> is a wildcard of the form <em><code style="background-color:inherit;font-size:medium">?</code></em>, the constraint reduces to <em>true</em>.<span class="assertion-id"> [jsr335-18.2.3-20-B]</span></span>
</li><li> <span class="norm-static"> If <em>T</em> is a wildcard of the form <em><code style="background-color:inherit;font-size:medium">? extends </code>T'</em>:<span class="assertion-id"> [jsr335-18.2.3-20-C]</span></span>
<ul><li> <span class="norm-static"> If <em>S</em> is a type, the constraint reduces to <em>⟨S &lt;: T'⟩</em>.<span class="assertion-id"> [jsr335-18.2.3-20-C1]</span></span>
</li><li> <span class="norm-static"> If <em>S</em> is a wildcard of the form <em><code style="background-color:inherit;font-size:medium">?</code></em>, the constraint reduces to <em>⟨<code style="background-color:inherit;font-size:medium">Object</code> &lt;: T'⟩</em>.<span class="assertion-id"> [jsr335-18.2.3-20-C4]</span></span>
</li><li> <span class="norm-static"> If <em>S</em> is a wildcard of the form <em><code style="background-color:inherit;font-size:medium">? extends </code>S'</em>, the constraint reduces to <em>⟨S' &lt;: T'⟩</em>.<span class="assertion-id"> [jsr335-18.2.3-20-C2]</span></span>
</li><li> <span class="norm-static"> If <em>S</em> is a wildcard of the form <em><code style="background-color:inherit;font-size:medium">? super </code>S'</em>, the constraint reduces to <em>⟨<code style="background-color:inherit;font-size:medium">Object</code> = T'⟩</em>.<span class="assertion-id"> [jsr335-18.2.3-20-C3]</span></span>
</li></ul>
</li><li> <span class="norm-static"> If <em>T</em> is a wildcard of the form <em><code style="background-color:inherit;font-size:medium">? super </code>T'</em>:<span class="assertion-id"> [jsr335-18.2.3-20-D]</span></span>
<ul><li> <span class="norm-static"> If <em>S</em> is a type, the constraint reduces to <em>⟨T' &lt;: S⟩</em>.<span class="assertion-id"> [jsr335-18.2.3-20-D1]</span></span>
</li><li> <span class="norm-static"> If <em>S</em> is a wildcard of the form <em><code style="background-color:inherit;font-size:medium">? super </code>S'</em>, the constraint reduces to <em>⟨T' &lt;: S'⟩</em>.<span class="assertion-id"> [jsr335-18.2.3-20-D2]</span></span>
</li><li> <span class="norm-static"> Otherwise, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.3-20-D3]</span></span>
</li></ul>
</li></ul>
<div id="G18.2.4"></div>
<h3> <span class="mw-headline" id="18.2.4_Type_Equality_Constraints_.5BNew.5D"> 18.2.4 Type Equality Constraints [New] </span></h3>
<p><span class="norm-static">
A constraint formula of the form <em>⟨S = T⟩</em>, where <em>S</em> and <em>T</em> are types, is reduced as follows:<span class="assertion-id"> [jsr335-18.2.4-10]</span></span>
</p>
<ul><li> <span class="norm-static"> If <em>S</em> and <em>T</em> are proper types, the constraint reduces to <em>true</em> if <em>S</em> is the same as <em>T</em> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.3.4" class="external text" rel="nofollow">4.3.4</a>), and <em>false</em> otherwise.<span class="assertion-id"> [jsr335-18.2.4-10-A]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>S</em> is an inference variable, <em>α</em>, the constraint reduces to the bound <em>α = T</em>.<span class="assertion-id"> [jsr335-18.2.4-10-B]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>T</em> is an inference variable, <em>α</em>, the constraint reduces to the bound <em>S = α</em>.<span class="assertion-id"> [jsr335-18.2.4-10-C]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>S</em> and <em>T</em> are class or interface types with the same erasure, where <em>S</em> has type arguments <em>B<sub>1</sub>, ..., B<sub>n</sub></em> and <em>T</em> has type arguments <em>A<sub>1</sub>, ..., A<sub>n</sub></em>, the constraint reduces to the following new constraints: for all <em>i</em>, <em>1 ≤ i ≤ n</em>, <em>⟨B<sub>i</sub> = A<sub>i</sub>⟩</em>.<span class="assertion-id"> [jsr335-18.2.4-10-D]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>S</em> and <em>T</em> are array types, <em>S'<code style="background-color:inherit;font-size:medium">[]</code></em> and <em>T'<code style="background-color:inherit;font-size:medium">[]</code></em>, the constraint reduces to <em>⟨S' = T'⟩</em>.<span class="assertion-id"> [jsr335-18.2.4-10-E]</span></span>
</li><li> <span class="norm-static"> Otherwise, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.4-10-G]</span></span>
</li></ul>
<p><span class="norm-static">
A constraint formula of the form <em>⟨S = T⟩</em>, where <em>S</em> and <em>T</em> are type arguments (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.5.1" class="external text" rel="nofollow">4.5.1</a>), is reduced as follows:<span class="assertion-id"> [jsr335-18.2.4-20]</span></span>
</p>
<ul><li> <span class="norm-static"> If <em>S</em> and <em>T</em> are types, the constraint is reduced as described above.<span class="assertion-id"> [jsr335-18.2.4-20-A]</span></span>
</li><li> <span class="norm-static"> If <em>S</em> has the form <em><code style="background-color:inherit;font-size:medium">?</code></em> and <em>T</em> has the form <em><code style="background-color:inherit;font-size:medium">?</code></em>, the constraint reduces to <em>true</em>.<span class="assertion-id"> [jsr335-18.2.4-20-B]</span></span>
</li><li> <span class="norm-static"> If <em>S</em> has the form <em><code style="background-color:inherit;font-size:medium">?</code></em> and <em>T</em> has the form <em><code style="background-color:inherit;font-size:medium">? extends </code>T'</em>, the constraint reduces to <em>⟨<code style="background-color:inherit;font-size:medium">Object</code> = T'⟩</em>.<span class="assertion-id"> [jsr335-18.2.4-20-F]</span></span>
</li><li> <span class="norm-static"> If <em>S</em> has the form <em><code style="background-color:inherit;font-size:medium">? extends </code>S'</em> and <em>T</em> has the form <em><code style="background-color:inherit;font-size:medium">?</code></em>, the constraint reduces to <em>⟨S' = <code style="background-color:inherit;font-size:medium">Object</code>⟩</em>.<span class="assertion-id"> [jsr335-18.2.4-20-G]</span></span>
</li><li> <span class="norm-static"> If <em>S</em> has the form <em><code style="background-color:inherit;font-size:medium">? extends </code>S'</em> and <em>T</em> has the form <em><code style="background-color:inherit;font-size:medium">? extends </code>T'</em>, the constraint reduces to <em>⟨S' = T'⟩</em>.<span class="assertion-id"> [jsr335-18.2.4-20-C]</span></span>
</li><li> <span class="norm-static"> If <em>S</em> has the form <em><code style="background-color:inherit;font-size:medium">? super </code>S'</em> and <em>T</em> has the form <em><code style="background-color:inherit;font-size:medium">? super </code>T'</em>, the constraint reduces to <em>⟨S' = T'⟩</em>.<span class="assertion-id"> [jsr335-18.2.4-20-D]</span></span>
</li><li> <span class="norm-static"> Otherwise, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.4-20-E]</span></span>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
Note that we do not address intersection types here, because it is impossible for reduction to encounter an intersection type that is not a proper type.</div></blockquote>
<div id="G18.2.5"></div>
<h3> <span class="mw-headline" id="18.2.5_Checked_Exception_Constraints_.5BNew.5D"> 18.2.5 Checked Exception Constraints [New] </span></h3>
<p><span class="norm-static">
A constraint formula of the form <em>LambdaExpression &rarr;<sub><code style="background-color:inherit;font-size:medium">throws</code></sub> T</em> is reduced as follows:<span class="assertion-id"> [jsr335-18.2.5-14]</span></span>
</p>
<ul><li> <span class="norm-static"> If <em>T</em> is not a functional interface type, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.5-14-A]</span></span>
</li><li> <span class="norm-static"> Otherwise, a target function type for the expression must be determined, as described in <a href="#E15.27.3" title="Lambda E" class="mw-redirect">15.27.3</a>.  If no valid function type can be found, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.5-14-B]</span></span>
</li><li> <span class="norm-static"> Otherwise, if the lambda expression is implicitly-typed and one or more of the function type's parameter types is not a proper type, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.5-14-C]</span></span>
</li><li> <span class="norm-static"> Otherwise, if the function type's return type is neither <code style="background-color:inherit;font-size:medium">void</code> nor a proper type, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.5-14-C2]</span></span>
</li><li> <span class="norm-static"> Otherwise, let <em>E<sub>1</sub>, ..., E<sub>n</sub></em> be the types in the function type's <code style="background-color:inherit;font-size:medium">throws</code> clause that are <i>not</i> proper types.  If the <em>LambdaExpression</em> is implicitly-typed, let the expression's parameter types be the function type's parameter types; if the lambda body is a poly expression or a block containing a poly result expression, let the targeted return type by the function type's return type.  Then let <em>E'<sub>1</sub>, ..., E'<sub>m</sub></em> be the checked exceptions that the lambda body can throw (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-11.html#jls-11.2" class="external text" rel="nofollow">11.2</a>).<span class="assertion-id"> [jsr335-18.2.5-14-D]</span></span>
</li><li> <span class="norm-static"> Then there are two cases:<span class="assertion-id"> [jsr335-18.2.5-14-E]</span></span>
<ul><li> <span class="norm-static"> If <em>n = 0</em> (the function type's <code style="background-color:inherit;font-size:medium">throws</code> clause consists only of proper types), then if there exists some <em>i</em> (<em>1 ≤ i ≤ m</em>) such that <em>E'<sub>i</sub></em> is not a subtype of any proper type in the <code style="background-color:inherit;font-size:medium">throws</code> clause, the constraint reduces to <em>false</em>; otherwise, the constraint reduces to <em>true</em>.<span class="assertion-id"> [jsr335-18.2.5-14-E1]</span></span>
</li><li> <span class="norm-static"> If <em>n &gt; 0</em>, the constraint reduces to a set of subtyping constraints: for all <em>i</em> (<em>1 ≤ i ≤ m</em>), if <em>E'<sub>i</sub></em> is not a subtype of any proper type in the <code style="background-color:inherit;font-size:medium">throws</code> clause, then the constraints include, for all <em>j</em> (<em>1 ≤ j ≤ n</em>), ⟨E'<sub>i</sub> &lt;: E<sub>j</sub>⟩.  In addition, for all <em>j</em> (<em>1 ≤ j ≤ n</em>), the constraint also reduces to the bound <em><code style="background-color:inherit;font-size:medium">throws</code> E<sub>j</sub></em>.<span class="assertion-id"> [jsr335-18.2.5-14-E2]</span></span>
</li></ul>
</li></ul>
<p><span class="norm-static">
A constraint formula of the form <em>MethodReference &rarr;<sub><code style="background-color:inherit;font-size:medium">throws</code></sub> T</em> is reduced as follows:<span class="assertion-id"> [jsr335-18.2.5-15]</span></span>
</p>
<ul><li> <span class="norm-static"> If <em>T</em> is not a functional interface type, or if <em>T</em> is a functional interface type but does not have a function type, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.5-15-A]</span></span>
</li><li> <span class="norm-static"> Otherwise, if the method reference is inexact and either i) one or more of the function type's parameter types is not a proper type, or ii) the function type's result is neither <code style="background-color:inherit;font-size:medium">void</code> nor a proper type, the constraint reduces to <em>false</em>.<span class="assertion-id"> [jsr335-18.2.5-15-C]</span></span>
</li><li> <span class="norm-static"> Otherwise, let <em>E<sub>1</sub>, ..., E<sub>n</sub></em> be the types in the function type's <code style="background-color:inherit;font-size:medium">throws</code> clause that are <i>not</i> proper types; and let <em>E'<sub>1</sub>, ..., E'<sub>m</sub></em> be the checked exceptions in the <code style="background-color:inherit;font-size:medium">throws</code> clause of the invocation type of the method reference's compile-time declaration (<a href="#E15.13.2" title="Lambda E" class="mw-redirect">15.13.2</a>) (derived based on the target function type's parameter types and return type).<span class="assertion-id"> [jsr335-18.2.5-15-D]</span></span>
</li><li> <span class="norm-static"> Then there are two cases:<span class="assertion-id"> [jsr335-18.2.5-15-E]</span></span>
<ul><li> <span class="norm-static"> If <em>n = 0</em> (the function type's <code style="background-color:inherit;font-size:medium">throws</code> clause consists only of proper types), then if there exists some <em>i</em> (<em>1 ≤ i ≤ m</em>) such that <em>E'<sub>i</sub></em> is not a subtype of any proper type in the <code style="background-color:inherit;font-size:medium">throws</code> clause, the constraint reduces to <em>false</em>; otherwise, the constraint reduces to <em>true</em>.<span class="assertion-id"> [jsr335-18.2.5-15-E1]</span></span>
</li><li> <span class="norm-static"> If <em>n &gt; 0</em>, the constraint reduces to a set of subtyping constraints: for all <em>i</em> (<em>1 ≤ i ≤ m</em>), if <em>E'<sub>i</sub></em> is not a subtype of any proper type in the <code style="background-color:inherit;font-size:medium">throws</code> clause, then the constraints include, for all <em>j</em> (<em>1 ≤ j ≤ n</em>), ⟨E'<sub>i</sub> &lt;: E<sub>j</sub>⟩.  In addition, for all <em>j</em> (<em>1 ≤ j ≤ n</em>), the constraint also reduces to the bound <em><code style="background-color:inherit;font-size:medium">throws</code> E<sub>j</sub></em>.<span class="assertion-id"> [jsr335-18.2.5-15-E2]</span></span>
</li></ul>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> Constraints on checked exceptions are handled separately from constraints on return types, because return type compatibility influences applicability of methods (<a href="#G18.5.1" title="Lambda G" class="mw-redirect">18.5.1</a>), while exceptions only influence the invocation type after overload resolution is complete (<a href="#G18.5.2" title="Lambda G" class="mw-redirect">18.5.2</a>).  This could be simplified by including exception compatibility in the definition of lambda expression compatibility (<a href="#E15.27.3" title="Lambda E" class="mw-redirect">15.27.3</a>), but this would lead to possibly-surprising cases in which exceptions that can be thrown by an explicitly-typed lambda body change overload resolution.
</div></li>
<li style="margin-bottom:12px;"><div> The exceptions thrown by a lambda body cannot be determined until i) the parameter types of the lambda are known, and ii) the target type of result expressions in the body is known.  (The second requirement is to account for generic method invocations in which, for example, the same type parameter appears in the return type and the <code style="background-color:inherit;font-size:medium">throws</code> clause.)  Hence, we require both of these, as derived from the target type <em>T</em>, to be proper types.
<p>One consequence is that lambda expressions returned from <i>other</i> lambda expressions cannot generate constraints from their thrown exceptions.  These constraints can only be generated from top-level lambda expressions.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> The handling of the case in which more than one inference variable appears in a function type's <code style="background-color:inherit;font-size:medium">throws</code> clause is not completeness-preserving.  Either variable may, on its own, satisfy the constraint that each checked exception be declared, but we can't be sure which one is intended.  So, for predictability, we constrain them both.
</div></li></ol></div></blockquote>
<div id="G18.3"></div>
<h3> <span class="mw-headline" id="18.3_Incorporation_.5BNew.5D"> 18.3 Incorporation [New] </span></h3>
<p><span class="norm-static">
Whenever a bound set contains two or more bounds, it is possible that new bounds can be inferred based on the assertions of the original bounds.  As bound sets are constructed and grown during inference, new bounds are <i>incorporated</i> by identifying complementary pairs of bounds and inferring further information in this way.<span class="assertion-id"> [jsr335-18.3-10]</span></span>
</p><p><span class="norm-static">
Specifically, for any pair of bounds in a bound set matching one of the following rules, a new constraint formula is inferred.  In the rules, <em>S</em> and <em>T</em> are inference variables or types, and <em>U</em> is a proper type.  For conciseness, a bound of the form <em>α = T</em> may also match a bound of the form <em>T = α</em>.<span class="assertion-id"> [jsr335-18.3-12]</span></span>
</p>
<ul><li> <span class="norm-static"> <em>α = S</em> and <em>α = T</em> imply <em>⟨S = T⟩</em><span class="assertion-id"> [jsr335-18.3-12-A]</span></span>
</li><li> <span class="norm-static"> <em>α = S</em> and <em>α &lt;: T</em> imply <em>⟨S &lt;: T⟩</em><span class="assertion-id"> [jsr335-18.3-12-B]</span></span>
</li><li> <span class="norm-static"> <em>α = S</em> and <em>T &lt;: α</em> imply <em>⟨T &lt;: S⟩</em><span class="assertion-id"> [jsr335-18.3-12-C]</span></span>
</li><li> <span class="norm-static"> <em>S &lt;: α</em> and <em>α &lt;: T</em> imply <em>⟨S &lt;: T⟩</em><span class="assertion-id"> [jsr335-18.3-12-D]</span></span>
</li><li> <span class="norm-static"> <em>α = U</em> and <em>S = T</em> imply <em>⟨S[α:=U] = T[α:=U]⟩</em><span class="assertion-id"> [jsr335-18.3-12-E]</span></span>
</li><li> <span class="norm-static"> <em>α = U</em> and <em>S &lt;: T</em> imply <em>⟨S[α:=U] &lt;: T[α:=U]⟩</em><span class="assertion-id"> [jsr335-18.3-12-F]</span></span>
</li></ul>
<p><span class="norm-static">
If two bounds have the form <em>α &lt;: S</em> and <em>α &lt;: T</em>, and if for some generic class or interface, <em>G</em>, there exists a supertype (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.10" class="external text" rel="nofollow">4.10</a>) of <em>S</em> of the form <em>G<code style="background-color:inherit;font-size:medium">&lt;</code>S<sub>1</sub>, ..., S<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em> and a supertype of <em>T</em> of the form <em>G<code style="background-color:inherit;font-size:medium">&lt;</code>T<sub>1</sub>, ..., T<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em>, then for all <em>i</em>, <em>1 ≤ i ≤ n</em>, if <em>S<sub>i</sub></em> and <em>T<sub>i</sub></em> are types (not wildcards), the constraint <em>⟨S<sub>i</sub> = T<sub>i</sub>⟩</em> is implied.<span class="assertion-id"> [jsr335-18.3-14]</span></span>
</p><p><span class="norm-static">
Additionally, when a bound set contains a bound of the form <em>G<code style="background-color:inherit;font-size:medium">&lt;</code>α<sub>1</sub>, ..., α<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code> = capture(G<code style="background-color:inherit;font-size:medium">&lt;</code>A<sub>1</sub>, ..., A<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code>)</em>, further bounds or constraints may be inferred.  Let <em>P<sub>1</sub></em>, ..., <em>P<sub>n</sub></em> represent the type parameters of <em>G</em>, <em>B<sub>1</sub></em>, ..., <em>B<sub>n</sub></em> represent the bounds (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.4" class="external text" rel="nofollow">4.4</a>) of these type parameters, and <em>θ</em> represent the substitution <em>[P<sub>1</sub>:=α<sub>1</sub>, ..., P<sub>n</sub>:=α<sub>n</sub>]</em>.  Let <em>R</em> be a type that is <i>not</i> an inference variable (but is not necessarily a proper type).  Then for all <em>i</em> (<em>1 ≤ i ≤ n</em>):<span class="assertion-id"> [jsr335-18.3-20]</span></span>
</p>
<ul><li> <span class="norm-static"> A set of bounds on <em>α<sub>1</sub>, ..., α<sub>n</sub></em>, constructed from the declared bounds of <em>P<sub>1</sub>, ..., P<sub>n</sub></em> as described in <a href="#G18.1.3" title="Lambda G" class="mw-redirect">18.1.3</a>, is immediately implied.<span class="assertion-id"> [jsr335-18.3-20-A]</span></span>
</li><li> <span class="norm-static"> If <em>A<sub>i</sub></em> is a wildcard of the form <code style="background-color:inherit;font-size:medium">?</code>:<span class="assertion-id"> [jsr335-18.3-20-B]</span></span>
<ul><li> <span class="norm-static"> <em>α<sub>i</sub> = R</em> implies <em>false</em><span class="assertion-id"> [jsr335-18.3-20-B1]</span></span>
</li><li> <span class="norm-static"> <em>α<sub>i</sub> &lt;: R</em> implies <em>⟨B<sub>i</sub> θ &lt;: R⟩</em><span class="assertion-id"> [jsr335-18.3-20-B2]</span></span>
</li><li> <span class="norm-static"> <em>R &lt;: α<sub>i</sub></em> implies <em>false</em><span class="assertion-id"> [jsr335-18.3-20-B3]</span></span>
</li></ul>
</li><li> <span class="norm-static"> If <em>A<sub>i</sub></em> is a wildcard of the form <code style="background-color:inherit;font-size:medium">? extends </code><em>T</em>:<span class="assertion-id"> [jsr335-18.3-20-C]</span></span>
<ul><li> <span class="norm-static"> <em>α<sub>i</sub> = R</em> implies <em>false</em><span class="assertion-id"> [jsr335-18.3-20-C1]</span></span>
</li><li> <span class="norm-static"> If <em>B<sub>i</sub></em> is <code style="background-color:inherit;font-size:medium">Object</code>, <em>α<sub>i</sub> &lt;: R</em> implies <em>⟨T &lt;: R⟩</em><span class="assertion-id"> [jsr335-18.3-20-C2]</span></span>
</li><li> <span class="norm-static"> If <em>T</em> is <code style="background-color:inherit;font-size:medium">Object</code>, <em>α<sub>i</sub> &lt;: R</em> implies <em>⟨B<sub>i</sub> θ &lt;: R⟩</em><span class="assertion-id"> [jsr335-18.3-20-C2]</span></span>
</li><li> <span class="norm-static"> <em>R &lt;: α<sub>i</sub></em> implies <em>false</em><span class="assertion-id"> [jsr335-18.3-20-C3]</span></span>
</li></ul>
</li><li> <span class="norm-static"> If <em>A<sub>i</sub></em> is a wildcard of the form <code style="background-color:inherit;font-size:medium">? super </code><em>T</em>:<span class="assertion-id"> [jsr335-18.3-20-D]</span></span>
<ul><li> <span class="norm-static"> <em>α<sub>i</sub> = R</em> implies <em>false</em><span class="assertion-id"> [jsr335-18.3-20-D1]</span></span>
</li><li> <span class="norm-static"> <em>α<sub>i</sub> &lt;: R</em> implies <em>⟨B<sub>i</sub> θ &lt;: R⟩</em><span class="assertion-id"> [jsr335-18.3-20-D2]</span></span>
</li><li> <span class="norm-static"> <em>R &lt;: α<sub>i</sub></em> implies <em>⟨R &lt;: T⟩</em><span class="assertion-id"> [jsr335-18.3-20-D3]</span></span>
</li></ul>
</li><li> <span class="norm-static"> If <em>A<sub>i</sub></em> is not a wildcard, the bound <em>α<sub>i</sub> = A<sub>i</sub></em> is immediately implied.<span class="assertion-id"> [jsr335-18.3-20-E]</span></span>
</li></ul>
<p><span class="norm-static">
The resulting constraint formulas are then reduced, and any new bounds are added to the bound set.  This may trigger further incorporation; ultimately, the set will reach a fixed point and no further bounds can be inferred.<span class="assertion-id"> [jsr335-18.3-14]</span></span>
</p><p>A bound set that is fully incorporated, if it does not contain the bound <em>false</em>, has the following properties:
</p>
<ul><li> For each combination of a proper lower bound <em>L</em> and a proper upper bound <em>U</em> of an inference variable, <em>L &lt;: U</em>.
</li><li> If every inference variable mentioned by a bound has an instantiation, the bound is satisfied by the corresponding substitution.
</li><li> Given a dependency <em>α = β</em>, every bound of <em>α</em> matches a bound of <em>β</em>, and vice versa.
</li><li> Given a dependency <em>α &lt;: β</em>, every lower bound of <em>α</em> is a lower bound of <em>β</em>, and every upper bound of <em>β</em> is an upper bound of <em>α</em>.
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p><p>The assertion that incorporation reaches a fixed point oversimplifies the matter slightly.  Building on the work of Kennedy and Pierce, <i><a href="http://research.microsoft.com/apps/pubs/default.aspx?id=64041" class="external text" rel="nofollow">On Decidability of Nominal Subtyping with Variance</a></i>, this property can be proven by making the argument that the set of types that may appear in the bound set is finite.  The argument relies on two assumptions:
</p>
<ul><li> New capture variables are not generated when reducing subtyping constraints (<a href="#G18.2.3" title="Lambda G" class="mw-redirect">18.2.3</a>).
</li><li> Expansive inheritance paths are not pursued.
</li></ul>
<p>The specification does not currently guarantee these properties (it is vague about the handling of wildcards when reducing subtyping constraints, and does not detect expansive inheritance paths), but is likely to do so in a future version.
</p>
(Notably, this is not a new problem: the existing subtyping algorithm is similarly at risk of non-termination.)</div></blockquote>
<div id="G18.4"></div>
<h3> <span class="mw-headline" id="18.4_Resolution_.5BNew.5D"> 18.4 Resolution [New] </span></h3>
<p><span class="norm-static">
Given a bound set that does not contain the bound <em>false</em>, a subset of the inference variables mentioned by the bound set may be <i>resolved</i>.  This means that a satisfactory instantiation may be added to the set for each inference variable, until all the requested variables have instantiations.  Dependencies in the bound set may require that the variables be resolved in a particular order, or that additional variables be resolved.<span class="assertion-id"> [jsr335-18.4-10]</span></span>
</p><p><span class="norm-static">
Consider a bound of one of the following forms, where <em>T</em> is either an inference variable <em>β</em> or a type that mentions <em>β</em>:<span class="assertion-id"> [jsr335-18.4-22]</span></span>
</p>
<ul><li> <span class="norm-static"> <em>α = T</em><span class="assertion-id"> [jsr335-18.4-22-A]</span></span>
</li><li> <span class="norm-static"> <em>α &lt;: T</em><span class="assertion-id"> [jsr335-18.4-22-B]</span></span>
</li><li> <span class="norm-static"> <em>T = α</em><span class="assertion-id"> [jsr335-18.4-22-C]</span></span>
</li><li> <span class="norm-static"> <em>T &lt;: α</em><span class="assertion-id"> [jsr335-18.4-22-D]</span></span>
</li></ul>
<p><span class="norm-static">
Given such a bound, if <em>α</em> appears on the left-hand side of another bound of the form <em>G<code style="background-color:inherit;font-size:medium">&lt;</code>..., α, ...<code style="background-color:inherit;font-size:medium">&gt;</code> = capture(G<code style="background-color:inherit;font-size:medium">&lt;</code>...<code style="background-color:inherit;font-size:medium">&gt;</code>)</em>, then <em>β</em> <i>depends on the resolution of</i> <em>α</em>.  Otherwise, <em>α</em> depends on the resolution of <em>β</em>.<span class="assertion-id"> [jsr335-18.4-22]</span></span>
</p><p><span class="norm-static">
An inference variable <em>α</em> appearing on the left-hand side of a bound of the form <em>G<code style="background-color:inherit;font-size:medium">&lt;</code>..., α, ...<code style="background-color:inherit;font-size:medium">&gt;</code> = capture(G<code style="background-color:inherit;font-size:medium">&lt;</code>...<code style="background-color:inherit;font-size:medium">&gt;</code>)</em> depends on the resolution of every other inference variable mentioned in this bound (on both sides of the <em>=</em> sign).<span class="assertion-id"> [jsr335-18.4-20]</span></span>
</p><p><span class="norm-static">
An inference variable <em>α</em> also depends on the resolution of itself, as well as the resolution of an inference variable <em>β</em> if there exists an inference variable <em>γ</em> such that <em>α</em> depends on the resolution of <em>γ</em> and <em>γ</em> depends on the resolution of <em>β</em>.<span class="assertion-id"> [jsr335-18.4-24]</span></span>
</p><p><span class="norm-static">
Given a set of inference variables to resolve, let <em>V</em> be the union of this set and all variables upon which the resolution of at least one variable in this set depends.<span class="assertion-id"> [jsr335-18.4-30]</span></span>
</p><p><span class="norm-static">
If every variable in <em>V</em> has an instantiation, then the resolution procedure terminates.  Otherwise, let <em>{ α<sub>1</sub>, ..., α<sub>n</sub> }</em> be a non-empty subset of uninstantiated variables in <em>V</em> such that i) for all <em>i</em>, <em>1 ≤ i ≤ n</em>, if <em>α<sub>i</sub></em> depends on the resolution of a variable <em>β</em>, then either <em>β</em> has an instantiation or there is some <em>j</em> such that <em>β = α<sub>j</sub></em>; and ii) there exists no non-empty proper subset of <em>{ α<sub>1</sub>, ..., α<sub>n</sub> }</em> with this property.<span class="assertion-id"> [jsr335-18.4-32]</span></span>
</p><p><span class="norm-static">
Then resolution proceeds by generating an instantiation for each of <em>α<sub>1</sub>, ..., α<sub>n</sub></em>.<span class="assertion-id"> [jsr335-18.4-34]</span></span>
</p><p><span class="norm-static">
If, for all <em>i</em> (<em>1 ≤ i ≤ n</em>), the bound set does not contain a bound of the form <em>G<code style="background-color:inherit;font-size:medium">&lt;</code>..., α<sub>i</sub>, ...<code style="background-color:inherit;font-size:medium">&gt;</code> = capture(G<code style="background-color:inherit;font-size:medium">&lt;</code>...<code style="background-color:inherit;font-size:medium">&gt;</code>)</em>, we first define candidate instantiations, <em>T<sub>1</sub></em>, ..., <em>T<sub>n</sub></em>.  For all <em>i</em> (<em>1 ≤ i ≤ n</em>), define <em>T<sub>i</sub></em> as follows:<span class="assertion-id"> [jsr335-18.4-40]</span></span>
</p>
<ul><li> <span class="norm-static"> If <em>α<sub>i</sub></em> has one or more <i>proper</i> lower bounds, <em>L<sub>1</sub>, ..., L<sub>k</sub></em>, then <em>T<sub>i</sub> = lub(L<sub>1</sub>, ..., L<sub>k</sub>)</em> (<a href="#G4.10.4" title="Lambda G" class="mw-redirect">4.10.4</a>).<span class="assertion-id"> [jsr335-18.4-40-A]</span></span>
</li><li> <span class="norm-static"> Otherwise, if the bound set contains <em><code style="background-color:inherit;font-size:medium">throws</code> α<sub>i</sub></em>, and the proper upper bounds of <em>α<sub>i</sub></em> are, at most, <code style="background-color:inherit;font-size:medium">Exception</code>, <code style="background-color:inherit;font-size:medium">Throwable</code>, and <code style="background-color:inherit;font-size:medium">Object</code>, then <em>T<sub>i</sub> = <code style="background-color:inherit;font-size:medium">RuntimeException</code></em>.<span class="assertion-id"> [jsr335-18.4-40-B]</span></span>
</li><li> <span class="norm-static"> Otherwise, where <em>α<sub>i</sub></em> has <i>proper</i> upper bounds <em>U<sub>1</sub>, ..., U<sub>k</sub></em>, <em>T<sub>i</sub> = glb(U<sub>1</sub>, ..., U<sub>k</sub>)</em>.<span class="assertion-id"> [jsr335-18.4-40-C]</span></span>
</li></ul>
<p><span class="norm-static">
If incorporating the bounds <em>α<sub>1</sub> = T<sub>1</sub>, ..., α<sub>n</sub> = T<sub>n</sub></em> with the current bound set produces a set that does not include <em>false</em>, then this is the new bound set; resolution proceeds by selecting a new set of variables to instantiate (if necessary), as described above.<span class="assertion-id"> [jsr335-18.4-42]</span></span>
</p><p><span class="norm-static">
Otherwise, a second attempt is made to instantiate <em>{ α<sub>1</sub>, ..., α<sub>n</sub> }</em>, as follows:<span class="assertion-id"> [jsr335-18.4-50]</span></span>
</p>
<ul><li> <span class="norm-static"> Let <em>Z<sub>1</sub>, ..., Z<sub>n</sub></em> be fresh type variables, and <em>θ</em> be the substitution <em>[α<sub>1</sub>:=Z<sub>1</sub>, ..., α<sub>n</sub>:=Z<sub>n</sub>]</em>.<span class="assertion-id"> [jsr335-18.4-50-A]</span></span>
</li><li> <span class="norm-static"> For all <em>i</em>, (<em>1 ≤ i ≤ n</em>), if <em>α<sub>i</sub></em> has one or more <i>proper</i> lower bounds, <em>L<sub>1</sub>, ..., L<sub>k</sub></em>, then define the lower bound of <em>Z<sub>i</sub></em> as <em>lub(L<sub>1</sub>, ..., L<sub>k</sub>)</em>; if not, then <em>Z<sub>i</sub></em> has no lower bound.<span class="assertion-id"> [jsr335-18.4-50-B]</span></span>
</li><li> <span class="norm-static"> For all <em>i</em>, (<em>1 ≤ i ≤ n</em>), where <em>α<sub>i</sub></em> has upper bounds <em>U<sub>1</sub>, ..., U<sub>k</sub></em>, define the upper bound of <em>Z<sub>i</sub></em> as <em>glb(U<sub>1</sub>θ, ..., U<sub>k</sub>θ)</em>.<span class="assertion-id"> [jsr335-18.4-50-C]</span></span>
</li></ul>
<p><span class="norm-static">
If the resulting type variables <em>Z<sub>1</sub>, ..., Z<sub>n</sub></em> do not have well-formed bounds (that is, a lower bound is not a subtype of an upper bound), then resolution fails.  Otherwise, the new bound set is produced by <i>removing</i> all bounds of the form <em>G<code style="background-color:inherit;font-size:medium">&lt;</code>..., α<sub>i</sub>, ...<code style="background-color:inherit;font-size:medium">&gt;</code> = capture(G<code style="background-color:inherit;font-size:medium">&lt;</code>...<code style="background-color:inherit;font-size:medium">&gt;</code>)</em> (for all <em>i</em>, <em>1 ≤ i ≤ n</em>) and incorporating <em>α<sub>1</sub> = Z<sub>1</sub>, ..., α<sub>n</sub> = Z<sub>n</sub></em>.  If the result contains the bound <em>false</em>, resolution fails.  Otherwise, resolution proceeds by selecting a new set of variables to instantiate (if necessary), as described above.<span class="assertion-id"> [jsr335-18.4-52]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
The first attempt at instantiating an inference variable derives the instantiation from that variable's bounds.  Sometimes, however, complex dependencies mean that the result is not within the variable's bounds.  In case of failure, a second attempt is performed, analogous to capture conversion (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.10" class="external text" rel="nofollow">5.1.10</a>): fresh type variables are introduced, with bounds derived from the bounds of the inference variables.  (Note that the lower bounds of these "capture" variables are computed using only proper types: this is important in order to avoid attempts to perform typing computations on uninstantiated type variables.)</div></blockquote>
<div id="G18.5"></div>
<h3> <span class="mw-headline" id="18.5_Uses_of_Inference_.5BNew.5D"> 18.5 Uses of Inference [New] </span></h3>
<p>Using the inference processes defined above, the following analyses are performed at compile-time.
</p>
<div id="G18.5.1"></div>
<h3> <span class="mw-headline" id="18.5.1_Invocation_Applicability_Inference_.5BNew.5D"> 18.5.1 Invocation Applicability Inference [New] </span></h3>
<p><span class="norm-static">
Given a method invocation that provides no explicit type arguments, the following process, modeled after the applicability rules in <a href="#F15.12.2.2" title="Lambda F" class="mw-redirect">15.12.2.2</a>, <a href="#F15.12.2.3" title="Lambda F" class="mw-redirect">15.12.2.3</a>, &amp; <a href="#F15.12.2.4" title="Lambda F" class="mw-redirect">15.12.2.4</a>, determines whether a potentially-applicable generic method <em>m</em> is applicable:<span class="assertion-id"> [jsr335-18.5.1-10]</span></span>
</p>
<ul><li> <span class="norm-static"> Where <em>P<sub>1</sub>, ..., P<sub>p</sub></em> (<em>p ≥ 1</em>) are the type parameters of <em>m</em>, let <em>α<sub>1</sub>, ..., α<sub>p</sub></em> be inference variables, and let <em>θ</em> be the substitution <em>[P<sub>1</sub>:=α<sub>1</sub>, ..., P<sub>p</sub>:=α<sub>p</sub>]</em>.<span class="assertion-id"> [jsr335-18.5.1-10-A]</span></span>
</li><li> <span class="norm-static"> An initial bound set <em>B<sub>0</sub></em> is constructed from the declared bounds of <em>P<sub>1</sub>, ..., P<sub>p</sub></em>, as described in <a href="#G18.1.3" title="Lambda G" class="mw-redirect">18.1.3</a>.<span class="assertion-id"> [jsr335-18.5.1-10-B]</span></span>
</li><li> <span class="norm-static"> For all <em>i</em> (<em>1 ≤ i ≤ p</em>), if <em>P<sub>i</sub></em> appears in the <code style="background-color:inherit;font-size:medium">throws</code> clause of <em>m</em>, then the bound <em><code style="background-color:inherit;font-size:medium">throws</code> α<sub>i</sub></em> is incorporated with <em>B<sub>0</sub></em>, producing the set <em>B<sub>1</sub></em>.<span class="assertion-id"> [jsr335-18.5.1-10-F]</span></span>
</li><li> <span class="norm-static"> Let <em>F<sub>1</sub>, ..., F<sub>n</sub></em> be the types of the formal parameters of <em>m</em>, and let <em>e<sub>1</sub>, ..., e<sub>k</sub></em> be the actual argument expressions of the invocation.  These are used to construct a set of constraint formulas; the contents of this set depends on the type of applicability being tested:<span class="assertion-id"> [jsr335-18.5.1-10-C]</span></span>
<ul><li> <span class="norm-static"> To test for <i>applicability by strict invocation</i>: if <em>k ≠ n</em>, or if there exists an <em>i</em> (<em>1 ≤ i ≤ n</em>) such that either i) e<sub>i</sub> is a standalone expression of a primitive type but F<sub>i</sub> is a reference type, or ii) F<sub>i</sub> is a primitive type but e<sub>i</sub> is not a standalone expression of a primitive type; then the method is not applicable and there is no need to proceed with inference.  Otherwise, the initial constraint formula set includes, for all <em>i</em> (<em>1 ≤ i ≤ k</em>), if <em>e<sub>i</sub></em> is pertinent to applicability (<a href="#F15.12.2.2" title="Lambda F" class="mw-redirect">15.12.2.2</a>), <em>⟨e<sub>i</sub> &rarr; F<sub>i</sub> θ⟩</em>.<span class="assertion-id"> [jsr335-18.5.1-10-C1]</span></span>
</li><li> <span class="norm-static"> To test for <i>applicability by loose invocation</i>: if <em>k ≠ n</em>, the method is not applicable and there is no need to proceed with inference.  Otherwise, the initial constraint formula set includes, for all <em>i</em> (<em>1 ≤ i ≤ k</em>), if <em>e<sub>i</sub></em> is pertinent to applicability, <em>⟨e<sub>i</sub> &rarr; F<sub>i</sub> θ⟩</em>.<span class="assertion-id"> [jsr335-18.5.1-10-C2]</span></span>
</li><li> <span class="norm-static"> To test for <i>applicability by variable-arity invocation</i>: Let <em>F'<sub>1</sub>, ..., F'<sub>k</sub></em> be the first <em>k</em> variable-arity parameter types of <em>m</em> (<a href="#F15.12.2.4" title="Lambda F" class="mw-redirect">15.12.2.4</a>).  The initial constraint formula set includes, for all <em>i</em> (<em>1 ≤ i ≤ k</em>), if <em>e<sub>i</sub></em> is pertinent to applicability, <em>⟨e<sub>i</sub> &rarr; F'<sub>i</sub> θ⟩</em>.<span class="assertion-id"> [jsr335-18.5.1-10-C3]</span></span>
</li></ul>
</li><li> <span class="norm-static"> The constraint formula set is reduced (<a href="#G18.2" title="Lambda G" class="mw-redirect">18.2</a>) and the resulting bounds are incorporated with <em>B<sub>1</sub></em> (<a href="#G18.3" title="Lambda G" class="mw-redirect">18.3</a>) to produce a bound set <em>B<sub>2</sub></em>.<span class="assertion-id"> [jsr335-18.5.1-10-D]</span></span>
</li><li> <span class="norm-static"> Finally, the method <em>m</em> is applicable if a resolution of all inference variables in <em>B<sub>2</sub></em> can be found following the process in <a href="#G18.4" title="Lambda G" class="mw-redirect">18.4</a>.<span class="assertion-id"> [jsr335-18.5.1-10-E]</span></span>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p><p>Consider the following method invocation and assignment:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">List&lt;Number&gt; ln = Arrays.asList(1, 2.0);</pre>
<p>A most-specific applicable method for the invocation must be identified as described in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">15.12</a>.  The only potentially-applicable method (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.1" class="external text" rel="nofollow">15.12.2.1</a>) is declared as follows:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">public static &lt;T&gt; List&lt;T&gt; asList(T... a)</pre>
<p>Trivially (because of its arity), this method is neither applicable by strict invocation (<a href="#F15.12.2.2" title="Lambda F" class="mw-redirect">15.12.2.2</a>) nor applicable by loose invocation (<a href="#F15.12.2.3" title="Lambda F" class="mw-redirect">15.12.2.3</a>).  But since there are no other candidates, in a third phase the method is checked for applicability by variable-arity invocation.
</p><p>The initial bound set, <em>B</em>, is a trivial upper bound for a single inference variable, <em>α</em>:
</p>
<blockquote><em>{ α &lt;: <code style="background-color:inherit;font-size:medium">Object</code> }</em></blockquote>
<p>The initial constraint formula set is as follows:
</p>
<blockquote><em>{ ⟨<code style="background-color:inherit;font-size:medium">1</code> &rarr; α⟩, ⟨<code style="background-color:inherit;font-size:medium">2.0</code> &rarr; α⟩ }</em></blockquote>
<p>These are reduced to a new bound set, <em>B<sub>1</sub></em>:
</p>
<blockquote><em>{ α &lt;: <code style="background-color:inherit;font-size:medium">Object</code>, <code style="background-color:inherit;font-size:medium">Integer</code> &lt;: α, <code style="background-color:inherit;font-size:medium">Double</code> &lt;: α }</em></blockquote>
<p>Then, to test whether the method is applicable, we attempt to resolve these bounds.  We succeed, producing the rather complex instantiation
</p>
<blockquote><em>α = <code style="background-color:inherit;font-size:medium">Number &amp; Comparable&lt;? extends Number &amp; Comparable&lt;?&gt;&gt;</code></em></blockquote>
We have thus demonstrated that the method is applicable; since no other candidates exist, it is the most-specific applicable method.  The <i>type</i> of the method invocation, and its compatibility with the target type in the assignment, is not determined until further inference can occur, as described in the next section.</div></blockquote>
<div id="G18.5.2"></div>
<h3> <span class="mw-headline" id="18.5.2_Invocation_Type_Inference_.5BNew.5D"> 18.5.2 Invocation Type Inference [New] </span></h3>
<p><span class="norm-static">
Consider a method invocation that provides no explicit type arguments, and a corresponding most-specific applicable generic method <em>m</em>.  The following process is used to infer the invocation type (<a href="#F15.12.2.6" title="Lambda F" class="mw-redirect">15.12.2.6</a>) of the chosen method.<span class="assertion-id"> [jsr335-18.5.2-10]</span></span>
</p>
<ul><li> <span class="norm-static"> Let <em>θ</em> be the substitution <em>[P<sub>1</sub>:=α<sub>1</sub>, ..., P<sub>p</sub>:=α<sub>p</sub>]</em> defined in <a href="#G18.5.1" title="Lambda G" class="mw-redirect">18.5.1</a>, used to replace the type parameters of <em>m</em> with inference variables.<span class="assertion-id"> [jsr335-18.5.2-10-A]</span></span>
</li><li> <span class="norm-static"> Let <em>B<sub>2</sub></em> be the bound set produced by reduction in order to demonstrate that <em>m</em> is applicable in <a href="#G18.5.1" title="Lambda G" class="mw-redirect">18.5.1</a>. (While, as a final step in <a href="#G18.5.1" title="Lambda G" class="mw-redirect">18.5.1</a>, it was necessary to demonstrate that the inference variables in <em>B<sub>2</sub></em> could be resolved in order to establish applicability, an instantiation produced by this resolution step is not considered part of <em>B<sub>2</sub></em>.)<span class="assertion-id"> [jsr335-18.5.2-10-B]</span></span>
</li><li> <span class="norm-static"> If the invocation is a poly expression, let <em>R</em> be the return type of <em>m</em>, and let <em>T</em> be the invocation's target type.  Then one of the following cases applies, producing a new bound set, <em>B<sub>3</sub></em>:<span class="assertion-id"> [jsr335-18.5.2-10-C2]</span></span>
<ul><li> <span class="norm-static"> If unchecked conversion was necessary for the method to be applicable in <a href="#G18.5.1" title="Lambda G" class="mw-redirect">18.5.1</a>, then, where <em>|R|</em> is the erasure (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.6" class="external text" rel="nofollow">4.6</a>) of <em>R</em>, the constraint formula <em>⟨|R| &rarr; T⟩</em> is reduced and incorporated with <em>B<sub>2</sub></em>.<span class="assertion-id"> [jsr335-18.5.2-10-C18]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>R θ</em> is a parameterized type, <em>G<code style="background-color:inherit;font-size:medium">&lt;</code>A<sub>1</sub>, ..., A<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em>, and one of <em>A<sub>1</sub></em>, ..., <em>A<sub>n</sub></em> is a wildcard, then, for fresh inference variables <em>β<sub>1</sub></em>, ..., <em>β<sub>n</sub></em>, the constraint formula <em>⟨G<code style="background-color:inherit;font-size:medium">&lt;</code>β<sub>1</sub>, ..., β<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code> &rarr; T⟩</em> is reduced and incorporated, along with the bound <em>G<code style="background-color:inherit;font-size:medium">&lt;</code>β<sub>1</sub>, ..., β<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code> = capture(G<code style="background-color:inherit;font-size:medium">&lt;</code>A<sub>1</sub>, ..., A<sub>n</sub><code style="background-color:inherit;font-size:medium">&gt;</code>)</em>, with <em>B<sub>2</sub></em>.<span class="assertion-id"> [jsr335-18.5.2-10-C14]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>R θ</em> is an inference variable <em>α</em>, and one of the following conditions are true, then <em>α</em> is resolved in <em>B<sub>2</sub></em>, and where the capture of the resulting instantiation of <em>α</em> is <em>U</em>, the constraint formula <em>⟨U &rarr; T⟩</em> is reduced and incorporated.<span class="assertion-id"> [jsr335-18.5.2-10-C15]</span></span>
<ul><li> <span class="norm-static"> <em>T</em> is a reference type, but is not a wildcard-parameterized type, and either i) <em>B<sub>2</sub></em> contains a bound of one of the forms <em>α = S</em> or <em>S &lt;: α</em>, where <em>S</em> is a wildcard-parameterized type, or ii) <em>B<sub>2</sub></em> contains two bounds of the forms <em>S<sub>1</sub> &lt;: α</em> and <em>S<sub>2</sub> &lt;: α</em>, where <em>S<sub>1</sub></em> and <em>S<sub>2</sub></em> have supertypes (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.10" class="external text" rel="nofollow">4.10</a>) that are two different parameterizations of the same generic class or interface.<span class="assertion-id"> [jsr335-18.5.2-10-C16]</span></span>
</li><li> <span class="norm-static"> <em>T</em> is a parameterization of a generic class or interface, <em>G</em>, and <em>B<sub>2</sub></em> contains a bound of one of the forms <em>α = S</em> or <em>S &lt;: α</em>, where there exists no type of the form <em>G<code style="background-color:inherit;font-size:medium">&lt;</code>...<code style="background-color:inherit;font-size:medium">&gt;</code></em> that is a supertype of <em>S</em>, but the raw type <em>G</em> is a supertype of <em>S</em>.<span class="assertion-id"> [jsr335-18.5.2-10-C17]</span></span>
</li><li> <span class="norm-static"> <em>T</em> is a primitive type, and one of the primitive wrapper classes mentioned in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.7" class="external text" rel="nofollow">5.1.7</a> is an instantiation, upper bound, or lower bound for <em>α</em> in <em>B<sub>2</sub></em>.<span class="assertion-id"> [jsr335-18.5.2-10-C12]</span></span>
</li></ul>
</li><li> <span class="norm-static"> Otherwise, the constraint formula <em>⟨R θ &rarr; T⟩</em> is reduced and incorporated with <em>B<sub>2</sub></em>.<span class="assertion-id"> [jsr335-18.5.2-10-C13]</span></span>
</li></ul>
</li><li> <span class="norm-static"> If the invocation is not a poly expression, <em>B<sub>3</sub></em> is the same as <em>B<sub>2</sub></em>.<span class="assertion-id"> [jsr335-18.5.2-10-C2-1]</span></span>
</li><li> <span class="norm-static"> Let <em>e<sub>1</sub>, ..., e<sub>k</sub></em> be the actual argument expressions of the invocation; if <em>m</em> is applicable by strict or loose invocation, let <em>F<sub>1</sub>, ..., F<sub>k</sub></em> be the types of the formal parameters of <em>m</em>, and if <em>m</em> is instead applicable by variable-arity invocation, let <em>F<sub>1</sub>, ..., F<sub>k</sub></em> the first <em>k</em> variable-arity parameter types of <em>m</em> (<a href="#F15.12.2.4" title="Lambda F" class="mw-redirect">15.12.2.4</a>).  A set, <em>C</em>, of additional constraint formulas is constructed as follows:<span class="assertion-id"> [jsr335-18.5.2-10-G]</span></span>
<ul><li> <span class="norm-static"> For all <em>i</em> (<em>1 ≤ i ≤ k</em>), if <em>e<sub>i</sub></em> is <i>not</i> pertinent to applicability, the set contains <em>⟨e<sub>i</sub> &rarr; F<sub>i</sub> θ⟩</em>.<span class="assertion-id"> [jsr335-18.5.2-10-G1]</span></span>
</li><li> <span class="norm-static"> For all <em>i</em> (<em>1 ≤ i ≤ k</em>), additional constraints may be included, according to the form of <em>e<sub>i</sub></em>:<span class="assertion-id"> [jsr335-18.5.2-10-G2]</span></span>
<ul><li> <span class="norm-static"> If the expression is a <em>LambdaExpression</em>, the set contains <em>⟨LambdaExpression &rarr;<sub><code style="background-color:inherit;font-size:medium">throws</code></sub> F<sub>i</sub> θ⟩</em>.<span class="assertion-id"> [jsr335-18.5.2-10-G21]</span></span>
</li><li> <span class="norm-static"> If the expression is a <em>MethodReference</em>, the set contains <em>⟨MethodReference &rarr;<sub><code style="background-color:inherit;font-size:medium">throws</code></sub> F<sub>i</sub> θ⟩</em>.<span class="assertion-id"> [jsr335-18.5.2-10-G22]</span></span>
</li><li> <span class="norm-static"> If the expression is a poly class instance creation expression (<a href="#D15.9" title="Lambda D" class="mw-redirect">15.9</a>) or a poly method invocation expression (<a href="#D15.12" title="Lambda D" class="mw-redirect">15.12</a>), the set contains all constraint formulas that would appear in the set <em>C</em> when determining the poly expression's invocation type.<span class="assertion-id"> [jsr335-18.5.2-10-G25]</span></span>
</li><li> <span class="norm-static"> If the expression is a parenthesized expression, these rules are applied recursively to the contained expression.<span class="assertion-id"> [jsr335-18.5.2-10-G23]</span></span>
</li><li> <span class="norm-static"> If the expression is a conditional expression, these rules are applied recursively to the second and third operands.<span class="assertion-id"> [jsr335-18.5.2-10-G24]</span></span>
</li></ul>
</li></ul>
</li><li> <span class="norm-static"> While <em>C</em> is not empty, the following process is repeated, accumulating new bounds into a "current" bound set and ultimately producing a new bound set, <em>B<sub>4</sub></em> (the initial value of the current bound set is <em>B<sub>3</sub></em>):<span class="assertion-id"> [jsr335-18.5.2-10-H]</span></span>
<ul><li> <span class="norm-static"> A subset of constraints is selected, satisfying the property that, for each constraint, no input variable depends on an output variable of another constraint in <em>C</em> (<i>input variable</i> and <i>output variable</i> are defined below; dependencies between inference variable are defined in <a href="#G18.4" title="Lambda G" class="mw-redirect">18.4</a>).  If this subset is empty, then there is a cycle (or cycles) in the graph of dependencies between constraints, and we instead select a single constraint that i) participates in a dependency cycle (or cycles), ii) does not depend on any constraints outside of the cycle (or cycles), iii) has the form <em>⟨Expression &rarr; T⟩</em>, if any such constraints satisfy the previous two requirements, and iv) contains an expression that appears to the left of the expression of every other constraint satisfying the previous three requirements.<span class="assertion-id"> [jsr335-18.5.2-10-H1]</span></span>
</li><li> <span class="norm-static"> The selected constraints are removed from <em>C</em>.<span class="assertion-id"> [jsr335-18.5.2-10-H2]</span></span>
</li><li> <span class="norm-static"> The union of the input variables of all the selected constraints, <em>α<sub>1</sub>, ..., α<sub>m</sub></em>, is resolved.<span class="assertion-id"> [jsr335-18.5.2-10-H3]</span></span>
</li><li> <span class="norm-static"> Where <em>T<sub>1</sub>, ..., T<sub>m</sub></em> are the instantiations of <em>α<sub>1</sub>, ..., α<sub>m</sub></em>, the substitution <em>[α<sub>1</sub>:=T<sub>1</sub>, ..., α<sub>m</sub>:=T<sub>m</sub>]</em> is applied to each constraint.<span class="assertion-id"> [jsr335-18.5.2-10-H4]</span></span>
</li><li> <span class="norm-static"> The constraints resulting from substitution are reduced and incorporated with the current bound set.<span class="assertion-id"> [jsr335-18.5.2-10-H5]</span></span>
</li></ul>
</li><li> <span class="norm-static"> The inference variables in <em>B<sub>4</sub></em> are resolved, following the process in <a href="#G18.4" title="Lambda G" class="mw-redirect">18.4</a>.  Where this results in instantiations <em>T<sub>1</sub>, ..., T<sub>p</sub></em> for inference variables <em>α<sub>1</sub>, ..., α<sub>p</sub></em>, let <em>θ'</em> be the substitution <em>[P<sub>1</sub>:=T<sub>1</sub>, ..., P<sub>p</sub>:=T<sub>p</sub>]</em>.  It is a compile-time error if no resolution of the inference variables in <em>B<sub>4</sub></em> can be found.<span class="assertion-id"> [jsr335-18.5.2-10-E]</span></span>
</li><li> <span class="norm-static"> Then apply <em>θ'</em> to the type of <em>m</em>.  If unchecked conversion was not necessary for the method to be applicable in <a href="#G18.5.1" title="Lambda G" class="mw-redirect">18.5.1</a>, then this is the invocation type of <em>m</em>; if unchecked conversion <i>was</i> necessary, then this substitution provides the parameter types of the invocation type, while the return type and thrown types are given by the erasure of <em>m</em>'s type (without applying <em>θ'</em>).<span class="assertion-id"> [jsr335-18.5.2-10-F]</span></span>
</li></ul>
<p><span class="norm-static">
Invocation type inference may require carefully sequencing the reduction of constraint formulas of the forms <em>⟨Expression &rarr; T⟩</em>, <em>⟨LambdaExpression &rarr;<sub><code style="background-color:inherit;font-size:medium">throws</code></sub> T⟩</em>, and <em>⟨MethodReference &rarr;<sub><code style="background-color:inherit;font-size:medium">throws</code></sub> T⟩</em>.  To facilitate this sequencing, the <i>input variables</i> of these constraints are defined as follows:<span class="assertion-id"> [jsr335-18.5.2-20]</span></span>
</p>
<ul><li> <span class="norm-static"> For <em>⟨LambdaExpression &rarr; T⟩</em>:<span class="assertion-id"> [jsr335-18.5.2-20-A]</span></span>
<ul><li> <span class="norm-static"> If <em>T</em> is an inference variable, it is the (only) input variable.<span class="assertion-id"> [jsr335-18.5.2-20-A1]</span></span>
</li><li> <span class="norm-static"> If <em>T</em> is a functional interface type, and a function type can be derived, as described in <a href="#E15.27.3" title="Lambda E" class="mw-redirect">15.27.3</a>, the input variables include i) if the lambda expression is implicitly-typed (<a href="#B15.27.1" title="Lambda B" class="mw-redirect">15.27.1</a>), the inference variables mentioned by the function type's parameter types; and ii) if the function type's return type, <em>R</em>, is not <code style="background-color:inherit;font-size:medium">void</code>, then for each result expression, <em>Expression'</em>, in the lambda body (or for the body itself if it is an expression), the input variables of <em>⟨Expression' &rarr; R⟩</em>.<span class="assertion-id"> [jsr335-18.5.2-20-A2]</span></span>
</li><li> <span class="norm-static"> Otherwise, there are no input variables.<span class="assertion-id"> [jsr335-18.5.2-20-A3]</span></span>
</li></ul>
</li><li> <span class="norm-static"> For <em>⟨LambdaExpression &rarr;<sub><code style="background-color:inherit;font-size:medium">throws</code></sub> T⟩</em>:<span class="assertion-id"> [jsr335-18.5.2-20-B]</span></span>
<ul><li> <span class="norm-static"> If <em>T</em> is an inference variable, it is the (only) input variable.<span class="assertion-id"> [jsr335-18.5.2-20-B1]</span></span>
</li><li> <span class="norm-static"> If <em>T</em> is a functional interface type, and a function type can be derived, as described in <a href="#E15.27.3" title="Lambda E" class="mw-redirect">15.27.3</a>, the input variables include i) if the lambda expression is implicitly-typed (<a href="#B15.27.1" title="Lambda B" class="mw-redirect">15.27.1</a>), the inference variables mentioned by the function type's parameter types; and ii) the inference variables mentioned by the function type's return type.<span class="assertion-id"> [jsr335-18.5.2-20-B2]</span></span>
</li><li> <span class="norm-static"> Otherwise, there are no input variables.<span class="assertion-id"> [jsr335-18.5.2-20-B3]</span></span>
</li></ul>
</li><li> <span class="norm-static"> For <em>⟨MethodReference &rarr; T⟩</em>:<span class="assertion-id"> [jsr335-18.5.2-20-C]</span></span>
<ul><li> <span class="norm-static"> If <em>T</em> is an inference variable, it is the (only) input variable.<span class="assertion-id"> [jsr335-18.5.2-20-C1]</span></span>
</li><li> <span class="norm-static"> If <em>T</em> is a functional interface type with a function type, and if the method reference is inexact (<a href="#E15.13.1" title="Lambda E" class="mw-redirect">15.13.1</a>), the input variables are the inference variables mentioned by the function type's parameter types.<span class="assertion-id"> [jsr335-18.5.2-20-C2]</span></span>
</li><li> <span class="norm-static"> Otherwise, there are no input variables.<span class="assertion-id"> [jsr335-18.5.2-20-C3]</span></span>
</li></ul>
</li><li> <span class="norm-static"> For <em>⟨MethodReference &rarr;<sub><code style="background-color:inherit;font-size:medium">throws</code></sub> T⟩</em>:<span class="assertion-id"> [jsr335-18.5.2-20-D]</span></span>
<ul><li> <span class="norm-static"> If <em>T</em> is an inference variable, it is the (only) input variable.<span class="assertion-id"> [jsr335-18.5.2-20-D1]</span></span>
</li><li> <span class="norm-static"> If <em>T</em> is a functional interface type with a function type, and if the method reference is inexact (<a href="#E15.13.1" title="Lambda E" class="mw-redirect">15.13.1</a>), the input variables are the inference variables mentioned by the function type's parameter types and the function type's return type.<span class="assertion-id"> [jsr335-18.5.2-20-D2]</span></span>
</li><li> <span class="norm-static"> Otherwise, there are no input variables.<span class="assertion-id"> [jsr335-18.5.2-20-D3]</span></span>
</li></ul>
</li><li> <span class="norm-static"> For <em>⟨ParenthesizedExpression &rarr; T⟩</em>: Where <em>Expression'</em> is the contained expression, the input variables are the input variables of <em>⟨Expression' &rarr; T⟩</em>.<span class="assertion-id"> [jsr335-18.5.2-20-E]</span></span>
</li><li> <span class="norm-static"> For <em>⟨ConditionalExpression &rarr; T⟩</em>: Where the expression has the form <em>Expression<sub>1</sub> <code style="background-color:inherit;font-size:medium">?</code> Expression<sub>2</sub> <code style="background-color:inherit;font-size:medium">:</code> Expression<sub>3</sub></em>, the input variables are the input variables of <em>⟨Expression<sub>2</sub> &rarr; T⟩</em> and <em>⟨Expression<sub>3</sub> &rarr; T⟩</em>.<span class="assertion-id"> [jsr335-18.5.2-20-F]</span></span>
</li><li> <span class="norm-static"> For all other constraint formulas, there are no input variables.<span class="assertion-id"> [jsr335-18.5.2-20-G]</span></span>
</li></ul>
<p><span class="norm-static">
The <i>output variables</i> of these constraints are all inference variables mentioned by the type on the right-hand side of the constraint, <em>T</em>, that are not input variables.<span class="assertion-id"> [jsr335-18.5.2-22]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> It is important to note that two "rounds" of inference are involved in finding the type of a method invocation.  This is necessary to allow a target type to influence the type of the invocation <i>without</i> allowing it to influence the choice of an applicable method.  The first round produces a bound set and tests that a resolution exists, but does not commit to that resolution.  The second round reduces additional constraints and then performs a second resolution, this time "for real."
<p>The distinction between these two rounds of inference was confused in previous iterations of the JLS (compare the discussion of inference in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.2" class="external text" rel="nofollow">15.12.2.2</a> vs. <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.6" class="external text" rel="nofollow">15.12.2.6</a>; also see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.8" class="external text" rel="nofollow">15.12.2.8</a>, which makes ambiguous use of the term "now").
</p>
</div></li>
<li style="margin-bottom:12px;"><div> Let's revisit the example from the previous section:
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">List&lt;Number&gt; ln = Arrays.asList(1, 2.0);</pre>
<p>The most-specific applicable method is declared as follows:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">public static &lt;T&gt; List&lt;T&gt; asList(T... a)</pre>
<p>In order to complete type-checking of the method invocation, we must determine whether it is compatible with its target type, <code style="background-color:inherit;font-size:medium">List&lt;Number&gt;</code>.
</p><p>The bound set used to demonstrate applicability in the previous section, <em>B<sub>2</sub></em>, was:
</p>
<blockquote><em>{ α &lt;: <code style="background-color:inherit;font-size:medium">Object</code>, <code style="background-color:inherit;font-size:medium">Integer</code>&lt;: α , <code style="background-color:inherit;font-size:medium">Double</code> &lt;: α }</em></blockquote>
<p>The new constraint formula set is as follows:
</p>
<blockquote><em>{ ⟨<code style="background-color:inherit;font-size:medium">List&lt;α&gt;</code> &rarr; <code style="background-color:inherit;font-size:medium">List&lt;Number&gt;</code>⟩ }</em></blockquote>
<p>This compatibility constraint produces an equality bound for <em>α</em>, which is included in the new bound set, <em>B<sub>3</sub></em>:
</p>
<blockquote><em>{ α &lt;: <code style="background-color:inherit;font-size:medium">Object</code>, <code style="background-color:inherit;font-size:medium">Integer</code>&lt;: α , <code style="background-color:inherit;font-size:medium">Double</code> &lt;: α, α = <code style="background-color:inherit;font-size:medium">Number</code> }</em></blockquote>
<p>These bounds are trivially resolved:
</p>
<blockquote><em>α = <code style="background-color:inherit;font-size:medium">Number</code></em></blockquote>
<p>Finally, we perform a substitution on the declared return type of <code style="background-color:inherit;font-size:medium">asList</code> to determine that the invocation expression has type <code style="background-color:inherit;font-size:medium">List&lt;Number&gt;</code>; clearly, this is compatible with the target type.
</p><p>Note that this strategy for inference is different than JLS 7, which would have instantiated <em>α</em> based on its lower bounds (before even considering the invocation's target type), as we did in the previous section.  This would result in a type error, since the resulting type is not a subtype of <code style="background-color:inherit;font-size:medium">List&lt;Number&gt;</code>.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> The use of capture when comparing a method result type to its target type is new, and allows for more precise inference.
</div></li>
<li style="margin-bottom:12px;"><div> Under various special circumstances, based on the bounds appearing in <em>B<sub>2</sub></em>, we eagerly resolve an inference variable that appears as the return type of the invocation.  This is to avoid unfortunate situations in which the usual constraint, <em>⟨R θ &rarr; T⟩</em>, is not completeness-preserving.  It is, unfortunately, possible that by eagerly resolving the variable, we are unable to make use of bounds that would be inferred later.  It is also possible that, in some cases, bounds that will later be inferred from the invocation arguments (such as implicitly-typed lambda expressions) would have caused a different outcome if they had been present in <em>B<sub>2</sub></em>.  Despite these limitations, the strategy allows for reasonable outcomes in typical use cases, and preserves backwards-compatibility with the JLS 7 algorithm.
</div></li></ol></div></blockquote>
<div id="G18.5.3"></div>
<h3> <span class="mw-headline" id="18.5.3_Functional_Interface_Parameterization_Inference_.5BNew.5D"> 18.5.3 Functional Interface Parameterization Inference [New] </span></h3>
<p><span class="norm-static">
Where a lambda expression with explicit parameter types <em>P<sub>1</sub>, ..., P<sub>n</sub></em> targets a wildcard-parameterized functional interface, <em>F<code style="background-color:inherit;font-size:medium">&lt;</code>A<sub>1</sub>, ..., A<sub>m</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em>, a parameterization of <em>F</em> may be derived as the ground target type of the expression, according to the following process.<span class="assertion-id"> [jsr335-18.5.3-20]</span></span>
</p>
<ul><li> <span class="norm-static"> Let <em>Q<sub>1</sub>, ..., Q<sub>k</sub></em> be the parameter types of the function type of <em>F<code style="background-color:inherit;font-size:medium">&lt;</code>α<sub>1</sub>, ..., α<sub>m</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em>, where <em>α<sub>1</sub>, ..., α<sub>m</sub></em> are new inference variables.  If <em>n ≠ k</em>, no valid parameterization exists.<span class="assertion-id"> [jsr335-18.5.3-20-B]</span></span>
</li><li> <span class="norm-static"> Otherwise, a set of constraint formulas is formed with, for all <em>i</em> (<em>1 ≤ i ≤ n</em>), <em>⟨P<sub>i</sub> = Q<sub>i</sub>⟩</em>.<span class="assertion-id"> [jsr335-18.5.3-20-C]</span></span>
</li><li> <span class="norm-static"> This constraint formula set is reduced to form the bound set <em>B</em>.  If <em>B</em> contains the bound <em>false</em>, no valid parameterization exists.<span class="assertion-id"> [jsr335-18.5.3-20-D]</span></span>
</li><li> <span class="norm-static"> Otherwise, a new parameterization of the functional interface, <em>F<code style="background-color:inherit;font-size:medium">&lt;</code>A'<sub>1</sub>, ..., A'<sub>m</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em>, is constructed as follows, for <em>1 ≤ i ≤ m</em>:<span class="assertion-id"> [jsr335-18.5.3-20-E]</span></span>
<ul><li> <span class="norm-static"> If <em>B</em> contains an instantiation, <em>T</em>, for <em>α<sub>i</sub></em>, then <em>A'<sub>i</sub> = T</em>.<span class="assertion-id"> [jsr335-18.5.3-20-E1]</span></span>
</li><li> <span class="norm-static"> Otherwise, <em>A'<sub>i</sub> = A<sub>i</sub></em>.<span class="assertion-id"> [jsr335-18.5.3-20-E2]</span></span>
</li></ul>
</li><li> <span class="norm-static"> If <em>F<code style="background-color:inherit;font-size:medium">&lt;</code>A'<sub>1</sub>, ..., A'<sub>m</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em> is not a well-formed type (that is, the type arguments are not within their bounds), or if <em>F<code style="background-color:inherit;font-size:medium">&lt;</code>A'<sub>1</sub>, ..., A'<sub>m</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em> is not a subtype of <em>F<code style="background-color:inherit;font-size:medium">&lt;</code>A<sub>1</sub>, ..., A<sub>m</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em>, no valid parameterization exists.<span class="assertion-id"> [jsr335-18.5.3-20-F]</span></span>
</li><li> <span class="norm-static"> Otherwise, the inferred parameterization is either <em>F<code style="background-color:inherit;font-size:medium">&lt;</code>A'<sub>1</sub>, ..., A'<sub>m</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em>, if all the type arguments are types, or the non-wildcard parameterization (<a href="#A9.8" title="Lambda A" class="mw-redirect">9.8</a>) of <em>F<code style="background-color:inherit;font-size:medium">&lt;</code>A'<sub>1</sub>, ..., A'<sub>m</sub><code style="background-color:inherit;font-size:medium">&gt;</code></em> if one or more type arguments are still wildcards.<span class="assertion-id"> [jsr335-18.5.3-20-F1]</span></span>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> In order to determine the function type of a wildcard-parameterized functional interface, we have to "instantiate" the wildcard type arguments with specific types.  The "default" approach is to simply replace the wildcards with their bounds, as described in <a href="#A9.8" title="Lambda A" class="mw-redirect">9.8</a>.  But this produces spurious errors in cases in which a lambda expression has explicit parameter types that do <i>not</i> correspond to the wildcard bounds.  For example:
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">Predicate&lt;? super Integer&gt; p = (Number n) -&gt; n.equals(23);</pre>
<p>The lambda expression in this example is a <code style="background-color:inherit;font-size:medium">Predicate&lt;Number&gt;</code>, which is a subtype of <code style="background-color:inherit;font-size:medium">Predicate&lt;? super Integer&gt;</code> but not <code style="background-color:inherit;font-size:medium">
Predicate&lt;Integer&gt;</code>.  The analysis in this section is used to infer that <code style="background-color:inherit;font-size:medium">Number</code> is an appropriate choice for the type argument to <code style="background-color:inherit;font-size:medium">Predicate</code>.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> The analysis here, while described in terms of general type inference, is intentionally quite simple.  The only constraints are equality constraints, which means that reduction amounts to simple pattern matching.
<p>A more powerful strategy might also infer constraints from the body of the lambda expression.  But, given possible interactions with inference for surrounding and/or nested generic method invocations, this would introduce a lot of extra complexity.
</p>
</div></li></ol></div></blockquote>
<div id="G18.5.4"></div>
<h3> <span class="mw-headline" id="18.5.4_More_Specific_Method_Inference_.5BNew.5D"> 18.5.4 More Specific Method Inference [New] </span></h3>
<p><span class="norm-static">
When testing that one applicable method is <i>more specific</i> than another (<a href="#F15.12.2.5" title="Lambda F" class="mw-redirect">15.12.2.5</a>), where the second method is generic, it is necessary to test whether some instantiation of the second method's type parameters can be inferred to make the first method more specific than the second.<span class="assertion-id"> [jsr335-18.5.4-10]</span></span>
</p><p><span class="norm-static">
Let <em>m<sub>1</sub></em> be the first method and <em>m<sub>2</sub></em> be the second.  Let <em>exp<sub>1</sub>, ..., exp<sub>k</sub></em> be the argument expressions of the corresponding invocation.<span class="assertion-id"> [jsr335-18.5.4-12]</span></span>
</p><p><span class="norm-static">
Where <em>m<sub>2</sub></em> has type parameters <em>P<sub>1</sub>, ..., P<sub>p</sub></em>, let <em>α<sub>1</sub>, ..., α<sub>p</sub></em> be inference variables.  Let <em>θ</em> be the substitution <em>[P<sub>1</sub>:=α<sub>1</sub>, ..., P<sub>p</sub>:=α<sub>p</sub>]</em>.<span class="assertion-id"> [jsr335-18.5.4-14]</span></span>
</p><p><span class="norm-static">
If <em>m<sub>1</sub></em> and <em>m<sub>2</sub></em> are applicable by strict or loose invocation (<a href="#F15.12.2.2" title="Lambda F" class="mw-redirect">15.12.2.2</a>, <a href="#F15.12.2.3" title="Lambda F" class="mw-redirect">15.12.2.3</a>), then let <em>S<sub>1</sub>, ..., S<sub>k</sub></em> be the parameter types of <em>m<sub>1</sub></em>, and let <em>T<sub>1</sub>, ..., T<sub>k</sub></em> be the result of <em>θ</em> applied to the parameter types of <em>m<sub>2</sub></em>.  If <em>m<sub>1</sub></em> and <em>m<sub>2</sub></em> are applicable by variable arity invocation (<a href="#F15.12.2.4" title="Lambda F" class="mw-redirect">15.12.2.4</a>), then let <em>S<sub>1</sub>, ..., S<sub>k</sub></em> be the first <em>k</em> variable-arity parameter types of <em>m<sub>1</sub></em>, and let <em>T<sub>1</sub>, ..., T<sub>k</sub></em> be the result of <em>θ</em> applied to the first <em>k</em> variable-arity parameter types of <em>m<sub>2</sub></em>.<span class="assertion-id"> [jsr335-18.5.4-16]</span></span>
</p><p>Note that no substitution is applied to <em>S<sub>1</sub>, ..., S<sub>k</sub></em>; even if <em>m<sub>1</sub></em> is generic, the type parameters of <em>m<sub>1</sub></em> are treated as type variables, not inference variables.
</p><p><span class="norm-static">
First, an initial bound set <em>B</em> is constructed from the declared bounds of <em>P<sub>1</sub>, ..., P<sub>p</sub></em>, as described in <a href="#G18.1.3" title="Lambda G" class="mw-redirect">18.1.3</a>.<span class="assertion-id"> [jsr335-18.5.4-20]</span></span>
</p><p><span class="norm-static">
Second, for all <em>i</em>, <em>1 ≤ i ≤ k</em>, a set of constraint formulas or bounds is generated.<span class="assertion-id"> [jsr335-18.5.4-30]</span></span>
</p><p><span class="norm-static">
If <em>S<sub>i</sub></em> and <em>T<sub>i</sub></em> are proper types, the result is <em>true</em> if <em>S<sub>i</sub></em> is more specific than <em>T<sub>i</sub></em> for <em>exp<sub>i</sub></em> (<a href="#F15.12.2.5" title="Lambda F" class="mw-redirect">15.12.2.5</a>), and <em>false</em> otherwise.<span class="assertion-id"> [jsr335-18.5.4-32]</span></span>
</p><p><span class="norm-static">
Otherwise, if <em>S<sub>i</sub></em> is a functional interface type and <em>T<sub>i</sub></em> is a parameterization of functional interface, <em>I</em>, and none of the following is true:<span class="assertion-id"> [jsr335-18.5.4-33]</span></span>
</p>
<ul><li> <span class="norm-static"> <em>S<sub>i</sub></em> is a superinterface of <em>I</em>, or a parameterization of a superinterface of <em>I</em>.<span class="assertion-id"> [jsr335-18.5.4-33-A]</span></span>
</li><li> <span class="norm-static"> <em>S<sub>i</sub></em> is subinterface of <em>I</em>, or a parameterization of a subinterface of <em>I</em>.<span class="assertion-id"> [jsr335-18.5.4-33-B]</span></span>
</li><li> <span class="norm-static"> <em>S<sub>i</sub></em> is an intersection type and each element of the intersection is a superinterface of <em>I</em>, or a parameterization of a superinterface of <em>I</em>.<span class="assertion-id"> [jsr335-18.5.4-33-C]</span></span>
</li><li> <span class="norm-static"> <em>S<sub>i</sub></em> is an intersection type and some element of the intersection is a subinterface of <em>I</em>, or a parameterization of a subinterface of <em>I</em>.<span class="assertion-id"> [jsr335-18.5.4-33-D]</span></span>
</li></ul>
<p><span class="norm-static">
Then let <em>U<sub>1</sub>, ..., U<sub>k</sub></em> and <em>R<sub>1</sub></em> be the parameter types and return type, respectively, of the function type of <i>the capture of</i> <em>S<sub>i</sub></em>, and let <em>V<sub>1</sub>, ..., V<sub>k</sub></em> and <em>R<sub>2</sub></em> be the parameter types and return type, respectively, of the function type of <em>T<sub>i</sub></em>.  The following constraints or bounds are generated:<span class="assertion-id"> [jsr335-18.5.4-34]</span></span>
</p>
<ul><li> <span class="norm-static"> If <em>exp<sub>i</sub></em> is an explicitly-typed lambda expression:<span class="assertion-id"> [jsr335-18.5.4-34-A]</span></span>
<ul><li> <span class="norm-static"> If <em>R<sub>2</sub></em> is <code style="background-color:inherit;font-size:medium">void</code>, <em>true</em>.<span class="assertion-id"> [jsr335-18.5.4-34-A1]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>R<sub>1</sub></em> and <em>R<sub>2</sub></em> are functional interface types, and neither interface is a subinterface of the other, then these rules are applied recursively to <em>R<sub>1</sub></em> and <em>R<sub>2</sub></em>, for each result expression in <em>exp<sub>i</sub></em>.<span class="assertion-id"> [jsr335-18.5.4-34-A2]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>R<sub>1</sub></em> is a primitive type and <em>R<sub>2</sub></em> is not, and each result expression is a standalone expression (<a href="#D15.2" title="Lambda D" class="mw-redirect">15.2</a>) of a primitive type, <em>true</em>.<span class="assertion-id"> [jsr335-18.5.4-34-A3]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>R<sub>2</sub></em> is a primitive type and <em>R<sub>1</sub></em> is not, and each result expression is either a standalone expression of a reference type or a poly expression, <em>true</em>.<span class="assertion-id"> [jsr335-18.5.4-34-A4]</span></span>
</li><li> <span class="norm-static"> Otherwise, <em>⟨R<sub>1</sub> &lt;: R<sub>2</sub>⟩</em>.<span class="assertion-id"> [jsr335-18.5.4-34-A5]</span></span>
</li></ul>
</li><li> <span class="norm-static"> If <em>exp<sub>i</sub></em> is an exact method reference:<span class="assertion-id"> [jsr335-18.5.4-34-B]</span></span>
<ul><li> <span class="norm-static"> For all <em>j</em>, <em>1 ≤ j ≤ k</em>, <em>⟨U<sub>j</sub> = V<sub>j</sub>⟩</em>.<span class="assertion-id"> [jsr335-18.5.4-34-B5]</span></span>
</li><li> <span class="norm-static"> If <em>R<sub>2</sub></em> is <code style="background-color:inherit;font-size:medium">void</code>, <em>true</em>.<span class="assertion-id"> [jsr335-18.5.4-34-B1]</span></span>
</li><li> <span class="norm-static"> Otherwise, if <em>R<sub>1</sub></em> is a primitive type and <em>R<sub>2</sub></em> is not, and the compile-time declaration for the method reference has a primitive return type, <em>true</em>.<span class="assertion-id"> [jsr335-18.5.4-34-B2]</span></span>
</li><li> <span class="norm-static"> Otherwise if <em>R<sub>2</sub></em> is a primitive type and <em>R<sub>1</sub></em> is not, and the compile-time declaration for the method reference has a reference return type, <em>true</em>.<span class="assertion-id"> [jsr335-18.5.4-34-B3]</span></span>
</li><li> <span class="norm-static"> Otherwise, <em>⟨R<sub>1</sub> &lt;: R<sub>2</sub>⟩</em>.<span class="assertion-id"> [jsr335-18.5.4-34-B4]</span></span>
</li></ul>
</li><li> <span class="norm-static"> If <em>exp<sub>i</sub></em> is a parenthesized expression, these rules are applied recursively to the contained expression.<span class="assertion-id"> [jsr335-18.5.4-34-C]</span></span>
</li><li> <span class="norm-static"> If <em>exp<sub>i</sub></em> is a conditional expression, these rules are applied recursively to each of the second and third operands.<span class="assertion-id"> [jsr335-18.5.4-34-D]</span></span>
</li><li> <span class="norm-static"> Otherwise, <em>false</em>.<span class="assertion-id"> [jsr335-18.5.4-34-E]</span></span>
</li></ul>
<p><span class="norm-static">
Otherwise, the constraint <em>⟨S<sub>i</sub> &lt;: T<sub>i</sub>⟩</em> is generated.<span class="assertion-id"> [jsr335-18.5.4-36]</span></span>
</p><p><span class="norm-static">
Third, if <em>m<sub>2</sub></em> is applicable by variable arity invocation and has <em>k+1</em> parameters, then where <em>S<sub>k+1</sub></em> is the <em>k+1</em>th variable-arity parameter type of <em>m<sub>1</sub></em> and <em>T<sub>k+1</sub></em> is <em>θ</em> applied to the <em>k+1</em>th variable-arity parameter type of <em>m<sub>2</sub></em>, the constraint <em>⟨S<sub>k+1</sub> &lt;: T<sub>k+1</sub>⟩</em> is generated.<span class="assertion-id"> [jsr335-18.5.4-40]</span></span>
</p><p><span class="norm-static">
Fourth, the generated bounds and constraint formulas are reduced and incorporated with <em>B</em> to produce a bound set <em>B'</em>.<span class="assertion-id"> [jsr335-18.5.4-50]</span></span>
</p><p><span class="norm-static">
If <em>B'</em> does not contain the bound <em>false</em>, and the inference variables in <em>B'</em> can be resolved, then <em>m<sub>1</sub></em> is more specific than <em>m<sub>2</sub></em>.  Otherwise, <em>m<sub>1</sub></em> is <i>not</i> more specific than <em>m<sub>2</sub></em>.<span class="assertion-id"> [jsr335-18.5.4-52]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
The use of inference to compare methods during the more-specific test is not new, but it has been "lifted" out of <a href="#F15.12.2.5" title="Lambda F" class="mw-redirect">15.12.2.5</a> into this new section.  The special treatment of functional interfaces is new, mirroring the changes to <a href="#F15.12.2.5" title="Lambda F" class="mw-redirect">15.12.2.5</a> for non-generic methods.</div></blockquote>
<div id="G4.10.4"></div>
<h3> <span class="mw-headline" id="4.10.4_Least_Upper_Bound_of_Reference_Types_.5BNew.5D"> 4.10.4 Least Upper Bound of Reference Types [New] </span></h3>
<p><span class="norm-static">
The <i>least upper bound</i>, or <em>lub</em>, of a set of reference types is a shared supertype that is more specific than any other shared supertype (that is, no other shared supertype is a subtype of the least upper bound).  This type, <em>lub(U<sub>1</sub>, ..., U<sub>k</sub>)</em>, is determined as follows.<span class="assertion-id"> [jsr335-4.10.4-10]</span></span>
</p><p><span class="norm-static">
If <em>k = 1</em>, then the <em>lub</em> is the type itself: <em>lub(U) = U</em>.<span class="assertion-id"> [jsr335-4.10.4-20]</span></span>
</p><p><span class="norm-static">
Otherwise, for each <em>U<sub>i</sub></em> (<em>1 ≤ i ≤ k</em>), we write <em>ST(U<sub>i</sub>)</em> for the set of supertypes of <em>U<sub>i</sub></em>, and define the erased supertype set of <em>U<sub>i</sub></em>:<span class="assertion-id"> [jls-15.12.2.7-430]</span></span>
</p><p><span class="norm-static">
<em>EST(U<sub>i</sub>) = { V | W in ST(U<sub>i</sub>) and V = |W| } </em> where <em>|W|</em> is the erasure of <em>W</em>.<span class="assertion-id"> [jls-15.12.2.7-440]</span></span>
</p><p>The reason for computing the set of erased supertypes is to deal with situations where the set of types includes several distinct invocations of a generic type declaration.
</p><p>For example, given <code style="background-color:inherit;font-size:medium">List&lt;String&gt;</code> and <code style="background-color:inherit;font-size:medium">List&lt;Object&gt;</code>, simply intersecting the sets <em>ST(<code style="background-color:inherit;font-size:medium">List&lt;String&gt;</code>) = { <code style="background-color:inherit;font-size:medium">List&lt;String&gt;</code>, <code style="background-color:inherit;font-size:medium">Collection&lt;String&gt;</code>, <code style="background-color:inherit;font-size:medium">Object</code> } </em> and <em>ST(<code style="background-color:inherit;font-size:medium">List&lt;Object&gt;</code>) = { <code style="background-color:inherit;font-size:medium">List&lt;Object&gt;</code>, <code style="background-color:inherit;font-size:medium">Collection&lt;Object&gt;</code>, <code style="background-color:inherit;font-size:medium">Object</code> } </em> would yield a set <em>{ <code style="background-color:inherit;font-size:medium">Object</code> } </em>, and we would have lost track of the fact that <em>T</em> can safely be assumed to be a <code style="background-color:inherit;font-size:medium">List</code>.
</p><p>In contrast, intersecting <em>EST(<code style="background-color:inherit;font-size:medium">List&lt;String&gt;</code>) = { <code style="background-color:inherit;font-size:medium">List</code>, <code style="background-color:inherit;font-size:medium">Collection</code>, <code style="background-color:inherit;font-size:medium">Object</code> } </em> and <em>EST(<code style="background-color:inherit;font-size:medium">List&lt;Object&gt;</code>) = { <code style="background-color:inherit;font-size:medium">List</code>, <code style="background-color:inherit;font-size:medium">Collection</code>, <code style="background-color:inherit;font-size:medium">Object</code> } </em> yields <em>{ <code style="background-color:inherit;font-size:medium">List</code>, <code style="background-color:inherit;font-size:medium">Collection</code>, <code style="background-color:inherit;font-size:medium">Object</code> } </em>, which will eventually enable us to produce <code style="background-color:inherit;font-size:medium">List&lt;?&gt;</code> as described below.
</p><p><span class="norm-static">
The erased candidate set for a set of types, <em>EC</em>, is the intersection of all the sets <em>EST(U<sub>i</sub>)</em> for each <em>U<sub>i</sub></em> in <em>U<sub>1</sub>, ..., U<sub>k</sub></em>.<span class="assertion-id"> [jls-15.12.2.7-450]</span></span>
</p><p><span class="norm-static">
The minimal erased candidate set for <em>U<sub>1</sub>, ..., U<sub>k</sub></em> is:<span class="assertion-id"> [jls-15.12.2.7-460]</span></span>
</p><p><span class="norm-static">
<em>MEC = { V | V in EC, and for all W ≠ V in EC, it is not the case that W &lt;: V } </em><span class="assertion-id"> [jls-15.12.2.7-470]</span></span>
</p><p>Because we are seeking to infer more precise types, we wish to filter out any candidates that are supertypes of other candidates.  This is what computing <em>MEC</em> accomplishes.
</p><p>In our running example, we had <em>EC = { <code style="background-color:inherit;font-size:medium">List</code>, <code style="background-color:inherit;font-size:medium">Collection</code>, <code style="background-color:inherit;font-size:medium">Object</code> } </em>, and now <em>MEC = { <code style="background-color:inherit;font-size:medium">List</code> } </em>.
</p><p>The next step will be to recover type arguments for the erased types in <em>MEC</em>.
</p><p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The definition of the <em>lci</em> and <em>lcta</em> functions from <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.7" class="external text" rel="nofollow">15.12.2.7</a> in JLS 7 should be inserted here.</div></blockquote>
<p>...
</p><p>Finally, we define the least upper bound based on all the elements of the minimal erased candidate set of <em>U<sub>1</sub>, ..., U<sub>k</sub></em>.  If any of these elements are generic, we use the <em>CandidateInvocation</em> function to recover the type argument information.
</p><p><span class="norm-static">
Define <em>Candidate(W) = CandidateInvocation(W)</em> if <em>W</em> is generic, <em>W</em> otherwise.<span class="assertion-id"> [jls-15.12.2.7-530]</span></span>
</p><p><span class="norm-static">
Then <em>lub(U<sub>1</sub>, ..., U<sub>k</sub>)</em> is <em>Candidate(W<sub>1</sub>) <code style="background-color:inherit;font-size:medium">&amp;</code> ... <code style="background-color:inherit;font-size:medium">&amp;</code> Candidate(W<sub>r</sub>)</em>, where <em>W<sub>i</sub></em> (<em>1 ≤ i ≤ r</em>) are the elements of <em>MEC</em>.<span class="assertion-id"> [jls-15.12.2.7-540]</span></span>
</p><p><span class="norm-static">
Strictly speaking, the <em>lub</em> function defined here only approximates a <i>least</i> upper bound.  Formally, there may exist some other type <em>T</em> such that all of <em>U<sub>1</sub>, ..., U<sub>k</sub></em> are subtypes of <em>T</em> and <em>T</em> is a subtype of <em>lub(U<sub>1</sub>, ..., U<sub>k</sub>)</em>.  However, a Java compiler's implementation of <em>lub</em> must be consistent with the above definition.<span class="assertion-id"> [jsr335-4.10.4-90]</span></span>
</p><p><span class="norm-static">
It is possible that the <em>lub</em> computation yields an infinite type.  This is permissible, and a Java compiler must recognize such situations and represent them appropriately using cyclic data structures.<span class="assertion-id"> [jls-15.12.2.7-600]</span></span>
</p><p>The possibility of an infinite type stems from the recursive calls to <em>lub</em>.  Readers familiar with recursive types should note that an infinite type is not the same as a recursive type.
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
This section is almost entirely lifted from <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.7" class="external text" rel="nofollow">15.12.2.7</a>, with only minor changes to eliminate references to type inference (such as the inference variable <em>T<sub>j</sub></em>).</div></blockquote>
<div id="G15.12.2.7"></div>
<h3> <span class="mw-headline" id="15.12.2.7_Inferring_Type_Arguments_Based_on_Actual_Arguments_.5BModified.5D"> 15.12.2.7 Inferring Type Arguments Based on Actual Arguments [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.7" class="external text" rel="nofollow">JLS 15.12.2.7</a></small>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>This section is deleted; it has been replaced by Chapter 18, principally <a href="#G18.2" title="Lambda G" class="mw-redirect">18.2</a> and <a href="#G18.5.1" title="Lambda G" class="mw-redirect">18.5.1</a>.</div></blockquote>
<div id="G15.12.2.8"></div>
<h3> <span class="mw-headline" id="15.12.2.8_Inferring_Unresolved_Type_Arguments_.5BModified.5D"> 15.12.2.8 Inferring Unresolved Type Arguments [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.8" class="external text" rel="nofollow">JLS 15.12.2.8</a></small>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>This section is deleted; it has been replaced by Chapter 18, principally <a href="#G18.3" title="Lambda G" class="mw-redirect">18.3</a>, <a href="#G18.4" title="Lambda G" class="mw-redirect">18.4</a>, and <a href="#G18.5.2" title="Lambda G" class="mw-redirect">18.5.2</a>.</div></blockquote>



<a id="top"></a>
	
	<a id="H"/><h1 id="firstHeading" class="firstHeading">Lambda Specification, Part H: Default Methods</h1>
									<p><small>
Navigation: <a href="#overview" title="Lambda Specification" class="mw-redirect">Overview</a>&nbsp;- <a href="#A" title="Lambda A" class="mw-redirect">Part A</a>&nbsp;- <a href="#B" title="Lambda B" class="mw-redirect">Part B</a>&nbsp;- <a href="#C" title="Lambda C" class="mw-redirect">Part C</a>&nbsp;- <a href="#D" title="Lambda D" class="mw-redirect">Part D</a>&nbsp;- <a href="#E" title="Lambda E" class="mw-redirect">Part E</a>&nbsp;- <a href="#F" title="Lambda F" class="mw-redirect">Part F</a>&nbsp;- <a href="#G" title="Lambda G" class="mw-redirect">Part G</a>&nbsp;- <a href="#H" title="Lambda H" class="mw-redirect">Part H</a>&nbsp;- <a href="#J" title="Lambda J" class="mw-redirect">Part J</a>
<br />
Sections: <a href="#H9">9</a>&nbsp;- <a href="#H9.1.1.2">9.1.1.2</a>&nbsp;- <a href="#H9.1.4">9.1.4</a>&nbsp;- <a href="#H9.2">9.2</a>&nbsp;- <a href="#H9.4">9.4</a>&nbsp;- <a href="#H9.4.1">9.4.1</a>&nbsp;- <a href="#H9.4.3">9.4.3</a>&nbsp;- <a href="#H9.6">9.6</a>&nbsp;- <a href="#H9.6.1">9.6.1</a>&nbsp;- <a href="#H8.1.1.1">8.1.1.1</a>&nbsp;- <a href="#H8.1.3">8.1.3</a>&nbsp;- <a href="#H8.1.5">8.1.5</a>&nbsp;- <a href="#H8.4.3.1">8.4.3.1</a>&nbsp;- <a href="#H8.4.8">8.4.8</a>&nbsp;- <a href="#H8.4.8.1">8.4.8.1</a>&nbsp;- <a href="#H8.4.8.2">8.4.8.2</a>&nbsp;- <a href="#H8.4.8.4">8.4.8.4</a>&nbsp;- <a href="#H8.8.7.1">8.8.7.1</a>&nbsp;- <a href="#H15.8">15.8</a>&nbsp;- <a href="#H15.8.3">15.8.3</a>&nbsp;- <a href="#H15.8.4">15.8.4</a>&nbsp;- <a href="#H15.11.2">15.11.2</a>&nbsp;- <a href="#H15.12">15.12</a>&nbsp;- <a href="#H15.12.1">15.12.1</a>&nbsp;- <a href="#H15.12.2.5">15.12.2.5</a>&nbsp;- <a href="#H15.12.3">15.12.3</a>&nbsp;- <a href="#H15.12.4.1">15.12.4.1</a>&nbsp;- <a href="#H15.12.4.4">15.12.4.4</a>&nbsp;- <a href="#H6">6</a>
<br />
Version 0.9.3.  Copyright © 2014 Oracle America, Inc.  <a href="#Legal_Notice" title="Lambda Specification" class="mw-redirect">Legal Notice</a>.
</small>
</p>
<h3> <span class="mw-headline" id="Summary"> Summary </span></h3>
<p>A <i>default method</i> is a method that is declared in an interface with the modifier <code style="background-color:inherit;font-size:medium">default</code>.  Its body provides a default implementation for any class that implements the interface without overriding the method.  This allows new functionality to be added to existing (and perhaps already widely-distributed) interfaces.  More generally, it provides a mechanism for multiple inheritance of behavior.
</p><p>An interface may also declare <code style="background-color:inherit;font-size:medium">static</code> methods, which work in much the same way as <code style="background-color:inherit;font-size:medium">static</code> methods in classes, except that they are not inherited.  Often, an interface is the most appropriate place to declare methods that produce or manipulate objects of the interface type.
</p><p>An interface method that is neither <code style="background-color:inherit;font-size:medium">default</code> nor <code style="background-color:inherit;font-size:medium">static</code> is implicitly <code style="background-color:inherit;font-size:medium">abstract</code>.
</p><p>An interface <em>I</em> inherits from its direct superinterfaces all <code style="background-color:inherit;font-size:medium">abstract</code> and default methods that are members of a superinterface, not overridden by a declaration in <em>I</em>, and not already overridden by another method in a superinterface of <em>I</em>.
</p><p>Similarly, a class <em>C</em> inherits from its direct superclass and direct superinterfaces all <code style="background-color:inherit;font-size:medium">abstract</code> and default methods that are members of a supertype, not overridden by a declaration in <em>C</em> <i>nor</i> a concrete method inherited from the superclass of <em>C</em>, and not already overridden by another method in a supertype of <em>C</em>.
</p><p>Notably, this implies that a method inherited from a superclass of <em>C</em> can override a default or <code style="background-color:inherit;font-size:medium">abstract</code> method in a superinterface of <em>C</em>.  We say the superclass method overrides the superinterface method <i>from <em>C</em></i>.  In contrast, an inherited interface method never overrides any methods other than those already overridden at its declaration site.
</p><p>It is a compile-time error if <em>I</em> or <em>C</em> inherits a default method whose signature is override-equivalent with another method inherited by <em>I</em>. This is the case whether the other method is <code style="background-color:inherit;font-size:medium">abstract</code> or not.
</p><p>This error condition can be avoided by declaring a new method that overrides, and thus prevents the inheritance of, all conflicting methods.
</p><p>An overridden default method can be accessed by using a method invocation expression of the form <code style="background-color:inherit;font-size:medium"><em>InterfaceName</em>.super.<em>m</em>()</code>.  The named interface must be a direct superinterface of the type declaration immediately enclosing the expression.
</p><p>A <code style="background-color:inherit;font-size:medium">this</code> expression may appear in a default method body; its type is the type of the enclosing interface.  Similarly, an anonymous or local class may be declared in a default method body, so the enclosing instance of an inner class may have an interface type.
</p><p>To avoid confusion with the <code style="background-color:inherit;font-size:medium">default</code> modifier, the access level given implicitly to unmodified declarations in classes is now referred to as <i>package</i> access rather than <i>default</i> access.
</p>
<div id="H9"></div>
<h3> <span class="mw-headline" id="9_Interfaces_.5BModified.5D"> 9 Interfaces [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9" class="external text" rel="nofollow">JLS 9</a></small>
</p><p>An interface declaration introduces a new reference type whose members are classes, interfaces, constants, and <del>abstract</del> methods.  This type has no <del>implementation</del> <u>instance variables, and typically declares one or more <code style="background-color:inherit;font-size:medium">abstract</code> methods;</u> otherwise unrelated classes can implement <u>the interface</u> by providing implementations for its abstract methods.  <u>Interfaces may not be directly instantiated.</u>
</p><p>...
</p><p>An interface may be declared to be a <i>direct extension</i> of one or more other interfaces, meaning that it <del>implicitly specifies</del> <u>inherits</u> all the member types, <del>abstract</del> <u>instance</u> methods, and constants of the interfaces it extends, except for any <u>members that it may override or hide.</u>
</p><p>A class may be declared to <i>directly implement</i> one or more interfaces, meaning that any instance of the class implements all the <code style="background-color:inherit;font-size:medium">abstract</code> methods specified by the interface or interfaces.  A class necessarily implements all the interfaces that its direct superclasses and direct superinterfaces do.  This (multiple) interface inheritance allows objects to support (multiple) common behaviors without sharing <del>any implementation</del> <u>a superclass</u>.
</p><p>...
</p>
<div id="H9.1.1.2"></div>
<h3> <span class="mw-headline" id="9.1.1.2_strictfp_Interfaces_.5BModified.5D"> 9.1.1.2 <code style="background-color:inherit;font-size:medium">strictfp</code> Interfaces [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.1.1.2" class="external text" rel="nofollow">JLS 9.1.1.2</a></small>
</p><p><span class="norm-dynamic">
The effect of the <code style="background-color:inherit;font-size:medium">strictfp</code> modifier is to make all <code style="background-color:inherit;font-size:medium">float</code> or <code style="background-color:inherit;font-size:medium">double</code> expressions within the interface declaration be explicitly FP-strict (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.4" class="external text" rel="nofollow">15.4</a>).<span class="assertion-id"> [jls-9.1.1.2-100]</span></span>
</p><p><span class="norm-static">
This implies that <u>all methods declared in the interface, and</u> all nested types declared in the interface, are implicitly <code style="background-color:inherit;font-size:medium">strictfp</code>.<span class="assertion-id"> [jls-9.1.1.2-110]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The previous sentence mimics <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.1.3" class="external text" rel="nofollow">8.1.1.3</a>.</div></blockquote>
<div id="H9.1.4"></div>
<h3> <span class="mw-headline" id="9.1.4_Interface_Body_and_Member_Declarations_.5BModified.5D"> 9.1.4 Interface Body and Member Declarations [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.1.4" class="external text" rel="nofollow">JLS 9.1.4</a></small>
</p><p>...
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
InterfaceMemberDeclaration:
  ConstantDeclaration
  <del>AbstractMethodDeclaration</del>
  <u>InterfaceMethodDeclaration</u>
  ClassDeclaration
  InterfaceDeclaration
  ';'
</pre>
<p>...
</p>
<div id="H9.2"></div>
<h3> <span class="mw-headline" id="9.2_Interface_Members_.5BModified.5D"> 9.2 Interface Members [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.2" class="external text" rel="nofollow">JLS 9.2</a></small>
</p><p><span class="norm-static">
The members of an interface are:<span class="assertion-id"> [jls-9.2-100]</span></span>
</p>
<ul>
<li><span class="norm-static"> Those members declared in the interface.<span class="assertion-id"> [jls-9.2-100-A]</span></span></li>
<li><span class="norm-static"> Those members inherited from direct superinterfaces.<span class="assertion-id"> [jls-9.2-100-B]</span></span></li>
<li><span class="norm-static"> If an interface has no direct superinterfaces, then the interface implicitly declares a <code style="background-color:inherit;font-size:medium">public abstract</code> member method <em>m</em> with signature <em>s</em>, return type <em>r</em>, and <code style="background-color:inherit;font-size:medium">throws</code> clause <em>t</em> corresponding to each <code style="background-color:inherit;font-size:medium">public</code> instance method <em>m</em> with signature <em>s</em>, return type <em>r</em>, and <code style="background-color:inherit;font-size:medium">throws</code> clause <em>t</em> declared in <code style="background-color:inherit;font-size:medium">Object</code>, unless <u>an <code style="background-color:inherit;font-size:medium">abstract</code></u> method with the same signature, same return type, and a compatible <code style="background-color:inherit;font-size:medium">throws</code> clause is explicitly declared by the interface.<span class="assertion-id"> [jls-9.2-100-C]</span></span>

<p><span class="norm-error"> It is a compile-time error if the interface explicitly declares such a method <em>m</em> in the case where <em>m</em> is declared to be <code style="background-color:inherit;font-size:medium">final</code> in <code style="background-color:inherit;font-size:medium">Object</code>.<span class="assertion-id"> [jls-9.2-100-C.1]</span></span></p>
<p><span class="norm-error"> It follows that <u>it</u> is a compile-time error if the interface declares a method with a signature that is override-equivalent (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.2" class="external text" rel="nofollow">8.4.2</a>) to a <code style="background-color:inherit;font-size:medium">public</code> method of <code style="background-color:inherit;font-size:medium">Object</code>, but has a different return type, <del>or</del> <u>has an</u> incompatible <code style="background-color:inherit;font-size:medium">throws</code> clause, <u>or is not <code style="background-color:inherit;font-size:medium">abstract</code></u>.<span class="assertion-id"> [jls-9.2-100-C.2]</span></span></p>
</li></ul>
<p><span class="norm-static">
The interface inherits, from the interfaces it extends, all members of those interfaces, except for fields, classes, and interfaces that it hides, <del>and</del> <u><code style="background-color:inherit;font-size:medium">abstract</code> or default</u> methods that it overrides, <u>and <code style="background-color:inherit;font-size:medium">static</code> methods</u>.<span class="assertion-id"> [jls-9.2-110]</span></span>
</p><p>Fields, methods, and member types of an interface type may have the same name, since they are used in different contexts and are disambiguated by different lookup procedures (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.5" class="external text" rel="nofollow">6.5</a>).  However, this is discouraged as a matter of style.
</p>
<div id="H9.4"></div>
<h3> <span class="mw-headline" id="9.4_Abstract_Method_Declarations_.5BModified.5D"> 9.4 <del>Abstract</del> Method Declarations [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.4" class="external text" rel="nofollow">JLS 9.4</a></small>
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
<u>InterfaceMethodDeclaration</u>:
  <u>InterfaceMethodModifiers<sub>opt</sub></u> TypeParameters<sub>opt</sub> Result
                      MethodDeclarator Throws<sub>opt</sub> <u>MethodBody</u>

<u>InterfaceMethodModifiers</u>:
  <u>InterfaceMethodModifier</u>
  <u>InterfaceMethodModifiers InterfaceMethodModifier</u>

<u>InterfaceMethodModifier</u>: one of
  Annotation 'public' 'abstract' <u>'default' 'static' 'strictfp'</u>
</pre>
<p><u>The following is repeated from <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.7" class="external text" rel="nofollow">8.4.7</a> to make the presentation here clearer:</u>
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
<u>MethodBody</u>:
  <u>Block</u>
  <u>';'</u>
</pre>
<p><span class="norm-error">
If an annotation <em>a</em> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.7" class="external text" rel="nofollow">9.7</a>) on a method declaration corresponds to an annotation type <em>T</em> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.6" class="external text" rel="nofollow">9.6</a>) and <em>T</em> has a (meta-)annotation <em>m</em> that corresponds to <code style="background-color:inherit;font-size:medium">java.lang.annotation.Target</code>, then <em>m</em> must have an element whose value is <code style="background-color:inherit;font-size:medium">java.lang.annotation.ElementType.METHOD</code>, or a compile-time error occurs.<span class="assertion-id"> [jls-9.4-110]</span></span>
</p><p><span class="norm-static">
Every method declaration in the body of an interface is implicitly <code style="background-color:inherit;font-size:medium">public</code> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6" class="external text" rel="nofollow">6.6</a>).<span class="assertion-id"> [jls-9.4-120]</span></span>
</p><p>It is permitted, but discouraged as a matter of style, to redundantly specify the <code style="background-color:inherit;font-size:medium">public</code> <del>and/or <code style="background-color:inherit;font-size:medium">abstract</code></del> modifier for a method declared in an interface.
</p><p><span class="norm-static">
<u>A <i>default method</i> is a method that is declared in an interface with the <code style="background-color:inherit;font-size:medium">default</code> modifier; its body is always represented by a block.  It provides a default implementation for any class that implements the interface without overriding the method.  Default methods are distinct from <i>concrete</i> methods (<a href="#H8.4.3.1" title="Lambda H" class="mw-redirect">8.4.3.1</a>), which are declared in classes.</u><span class="assertion-id"> [jsr335-9.4-125]</span></span>
</p><p><span class="norm-static">
<u>An interface can declare <code style="background-color:inherit;font-size:medium">static</code> methods, which are invoked without reference to a particular object.</u><span class="assertion-id"> [jsr335-9.4-127]</span></span>
</p><p><span class="norm-error">
<u>It is a compile-time error to use the name of a type parameter of any surrounding declaration in the header or body of a <code style="background-color:inherit;font-size:medium">static</code> method.</u><span class="assertion-id"> [jsr335-9.4-128]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The previous sentence mimics <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.3.2" class="external text" rel="nofollow">8.4.3.2</a>.</div></blockquote>
<p><span class="norm-static">
<u>An interface method lacking a <code style="background-color:inherit;font-size:medium">default</code> modifier or a <code style="background-color:inherit;font-size:medium">static</code> modifier</u> is implicitly <code style="background-color:inherit;font-size:medium">abstract</code>, so its body is always represented by a semicolon, not a block.  <u>The declaration may optionally include the <code style="background-color:inherit;font-size:medium">abstract</code> keyword.</u><span class="assertion-id"> [jls-9.4-130]</span></span>
</p><p><span class="norm-dynamic">
<u>The effect of the <code style="background-color:inherit;font-size:medium">strictfp</code> modifier is to make all <code style="background-color:inherit;font-size:medium">float</code> or <code style="background-color:inherit;font-size:medium">double</code> expressions within the method body be explicitly FP-strict (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.4" class="external text" rel="nofollow">15.4</a>).</u><span class="assertion-id"> [jsr335-9.4-135]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The previous sentence mimics <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.3.5" class="external text" rel="nofollow">8.4.3.5</a>.</div></blockquote>
<p><span class="norm-error">
It is a compile-time error if the same modifier appears more than once on a method declared in an interface.<span class="assertion-id"> [jls-9.4-200]</span></span>
</p><p><span class="norm-error">
<u>It is a compile-time error if a method is declared with more than one of the modifiers <code style="background-color:inherit;font-size:medium">abstract</code>, <code style="background-color:inherit;font-size:medium">default</code>, or <code style="background-color:inherit;font-size:medium">static</code>.</u><span class="assertion-id"> [jsr335-9.4-202]</span></span>
</p><p><span class="norm-error">
<u>It is a compile-time error if an abstract method declaration contains the keyword <code style="background-color:inherit;font-size:medium">strictfp</code>.</u><span class="assertion-id"> [jsr335-9.4-205]</span></span>
</p><p><span class="norm-error">
It is a compile-time error if a method declared in an interface is declared <u><code style="background-color:inherit;font-size:medium">native</code>, <code style="background-color:inherit;font-size:medium">synchronized</code>, or <code style="background-color:inherit;font-size:medium">final</code></u> <del>because <code style="background-color:inherit;font-size:medium">static</code> methods cannot be <code style="background-color:inherit;font-size:medium">abstract</code></del>.<span class="assertion-id"> [jls-9.4-210]</span></span>
</p><p><del><span class="norm-error">It is a compile-time error if a method declared in an interface is <code style="background-color:inherit;font-size:medium">strictfp</code> or <code style="background-color:inherit;font-size:medium">native</code> or <code style="background-color:inherit;font-size:medium">synchronized</code> because those keywords describe implementation properties rather than interface properties.<span class="assertion-id"> [jls-9.4-220]</span></span></del>
</p><p><del>However, a method declared in an interface may be implemented by a method that is declared <code style="background-color:inherit;font-size:medium">strictfp</code> or <code style="background-color:inherit;font-size:medium">native</code> or <code style="background-color:inherit;font-size:medium">synchronized</code> in a class that implements the interface.</del>
</p><p><del><span class="norm-error">It is a compile-time error if a method declared in an interface is declared <code style="background-color:inherit;font-size:medium">final</code>.<span class="assertion-id"> [jls-9.4-240]</span></span></del>
</p><p><del>However, a method declared in an interface may be implemented by a method that is declared <code style="background-color:inherit;font-size:medium">final</code> in a class that implements the interface.</del>
</p><p><span class="norm-error">
It is a compile-time error for the body of an interface to declare, explicitly or implicitly, two methods with override-equivalent signatures (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.2" class="external text" rel="nofollow">8.4.2</a>).<span class="assertion-id"> [jls-9.4-260]</span></span>
</p><p>However, an interface may inherit several <u>abstract</u> methods with such signatures (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.4.1" class="external text" rel="nofollow">9.4.1</a>).
</p><p><span class="norm-static">
A method in an interface may be generic.  The rules for type parameters of a generic method in an interface are the same as for a generic method in a class.<span class="assertion-id"> [jls-9.4-300]</span></span>
</p>
<div id="H9.4.1"></div>
<h3> <span class="mw-headline" id="9.4.1_Inheritance_and_Overriding_.5BModified.5D"> 9.4.1 Inheritance and Overriding [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.4.1" class="external text" rel="nofollow">JLS 9.4.1</a></small>
</p><p><span class="norm-static">
An interface <u><em>I</em></u> <i>inherits</i> from its direct superinterfaces all <u><code style="background-color:inherit;font-size:medium">abstract</code> and default</u> methods <u><em>m</em> for which all of the following are true:</u><span class="assertion-id"> [jls-9.4.1-100]</span></span>
</p>
<ul><li> <span class="norm-static"> <u><em>m</em> is a member of a direct superinterface, <em>J</em>, of <em>I</em>.</u><span class="assertion-id"> [jsr335-9.4.1-100-A]</span></span>
</li><li> <span class="norm-static"> <u>No non-<code style="background-color:inherit;font-size:medium">static</code> method declared in <em>I</em> has a signature that is a subsignature (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.2" class="external text" rel="nofollow">8.4.2</a>) of the signature of <em>m</em>.</u><span class="assertion-id"> [jsr335-9.4.1-100-B]</span></span>
</li><li> <span class="norm-static"> <u>There exists no method <em>m'</em> that is a member of a direct superinterface, <em>J'</em>, of <em>I</em> (<em>m</em> distinct from <em>m'</em>, <em>J</em> distinct from <em>J'</em>), such that <em>m'</em> overrides the declaration of <em>m</em> from <em>J'</em>.</u><span class="assertion-id"> [jsr335-9.4.1-100-C]</span></span>
</li></ul>
<p><span class="norm-static">
<u>An interface does not inherit <code style="background-color:inherit;font-size:medium">static</code> methods from its superinterfaces.</u><span class="assertion-id"> [jsr335-9.4.1-15]</span></span>
</p><p><span class="norm-static">
An instance method <em>m<sub>1</sub></em><u>,</u> declared <u>or inherited by</u> an interface <em>I</em><u>,</u> <i>overrides <u>from <em>I</em></u></i> another instance method, <em>m<sub>2</sub></em>, declared in interface <em>J</em><u>,</u> iff both of the following are true:<span class="assertion-id"> [jls-9.4.1.1-100]</span></span>
</p>
<ul><li> <span class="norm-static"> <em>I</em> is a subinterface of <em>J</em>.<span class="assertion-id"> [jls-9.4.1.1-100-A]</span></span>
</li><li> <span class="norm-static"> The signature of <em>m<sub>1</sub></em> is a subsignature (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.2" class="external text" rel="nofollow">8.4.2</a>) of the signature of <em>m<sub>2</sub></em>.<span class="assertion-id"> [jls-9.4.1.1-100-B]</span></span>
</li></ul>
<p><u>An overridden default method can be accessed by using a method invocation expression (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">15.12</a>) that contains the keyword <code style="background-color:inherit;font-size:medium">super</code> qualified by a superinterface name.</u>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The previous sentence mimics <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.8.1" class="external text" rel="nofollow">8.4.8.1</a>.</div></blockquote>
<p><span class="norm-error">
<u>It is a compile-time error if an interface declares a <code style="background-color:inherit;font-size:medium">static</code> method whose signature is a subsignature of an instance method inherited from a superinterface.</u><span class="assertion-id"> [jsr335-9.4.1-10]</span></span>
</p><p><span class="norm-error">
If a method declaration <em>d<sub>1</sub></em> with return type <em>R<sub>1</sub></em> overrides <del>or hides</del> the declaration of another method <em>d<sub>2</sub></em> with return type <em>R<sub>2</sub></em>, then <em>d<sub>1</sub></em> must be return-type-substitutable (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.5" class="external text" rel="nofollow">8.4.5</a>) for <em>d<sub>2</sub></em>, or a compile-time error occurs.<span class="assertion-id"> [jls-9.4.1.2-100]</span></span>
</p><p><span class="norm-error">
Furthermore, if <em>R<sub>1</sub></em> is not a subtype of <em>R<sub>2</sub></em>, a compile-time unchecked warning occurs.<span class="assertion-id"> [jls-9.4.1.2-110]</span></span>
</p><p><span class="norm-error">
Moreover, a method declaration must not have a <code style="background-color:inherit;font-size:medium">throws</code> clause that conflicts (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.6" class="external text" rel="nofollow">8.4.6</a>) with that of any method that it overrides; otherwise, a compile-time error occurs.<span class="assertion-id"> [jls-9.4.1.2-200]</span></span>
</p><p><u>The presence or absence of the <code style="background-color:inherit;font-size:medium">strictfp</code> modifier has absolutely no effect on the rules for overriding methods.  For example, it is permitted for a method that is not FP-strict to override an FP-strict method and it is permitted for an FP-strict method to override a method that is not FP-strict.</u>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The previous paragraph mimics <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.8.1" class="external text" rel="nofollow">8.4.8.1</a>.</div></blockquote>
<p>...
</p><p>It is possible for an interface to inherit several methods with override-equivalent signatures (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.2" class="external text" rel="nofollow">8.4.2</a>).
</p><p><span class="norm-error">
<u>It is a compile-time error if an interface <em>I</em> inherits a default method whose signature is override-equivalent with another method inherited by <em>I</em>.  This is the case whether the other method is <code style="background-color:inherit;font-size:medium">abstract</code> or <code style="background-color:inherit;font-size:medium">default</code>.</u><span class="assertion-id"> [jsr335-9.4.1-50]</span></span>
</p><p><span class="norm-static">
<u>Otherwise, all the inherited methods are <code style="background-color:inherit;font-size:medium">abstract</code>, and</u> the interface is considered to inherit all the methods.<span class="assertion-id"> [jls-9.4.1.3-100]</span></span>
</p><p><span class="norm-error">
However, one of the inherited methods must be return-type-substitutable for every other inherited method; otherwise, a compile-time error occurs.  (The <code style="background-color:inherit;font-size:medium">throws</code> clauses do not cause errors in this case.)<span class="assertion-id"> [jls-9.4.1.3-110]</span></span>
</p><p><u>These error conditions can be avoided by declaring a new method that overrides, and thus prevents the inheritance of, all conflicting methods.</u>
</p><p>There might be several paths by which the same method declaration is inherited from an interface.  This fact causes no difficulty and never, of itself, results in a compile-time error.
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The example stating that "methods declared in interfaces are <code style="background-color:inherit;font-size:medium">abstract</code> and thus contain no implementation" should be removed and replaced to include examples of default methods overriding abstract methods and vice versa.</div></blockquote>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div>
<p>The third clause in the inheritance definition prevents a subinterface from re-inheriting a method that has already been overridden by another of its superinterfaces.
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
interface I {
  default String name() { return &quot;unnamed&quot;; }
}
interface J extends I {
  default String name() { return getClass().getName(); }
}
interface K extends I {}

interface Child extends J, K {}
</pre>
<p>The interface <code style="background-color:inherit;font-size:medium">Child</code> above inherits <code style="background-color:inherit;font-size:medium">J.name</code> from <code style="background-color:inherit;font-size:medium">J</code> but not <code style="background-color:inherit;font-size:medium">I.name</code> from <code style="background-color:inherit;font-size:medium">K</code>, because <code style="background-color:inherit;font-size:medium">I.name</code> has already been overridden by <code style="background-color:inherit;font-size:medium">J</code>.
</p>
</div></li>
<li style="margin-bottom:12px;"><div>
<p>Naturally, when two different default methods with matching signatures are inherited by a subinterface, there is a behavioral conflict; we actively detect this conflict and notify the developer with an error, rather than waiting for the problem to arise when a concrete class is compiled.
</p><p>Similarly, when an abstract and a default method with matching signatures are inherited, we produce an error.  In this case, it would be possible to give priority to one or the other—perhaps we would assume that the default method provides a reasonable implementation for the abstract method, too.  But this is risky, since other than the coincidental name and signature, we have no reason to believe that the default method behaves consistently with the abstract method's contract—the default method may not have even existed when the subinterface was originally developed.  It is safer in this situation to ask the user to actively assert that the default implementation is appropriate (via an overriding declaration).
</p><p>In contrast, the longstanding behavior for inherited concrete instance methods in classes is that they override abstract methods declared in interfaces (<a href="#H8.4.8" title="Lambda H" class="mw-redirect">see 8.4.8</a>).  The same argument about potential contract violation applies here, but in this case there is an inherent imbalance between classes and interfaces.  We prefer, in order to preserve the independent nature of class hierarchies, to minimize class-interface clashes by simply giving priority to concrete instance methods.
</p>
</div></li></ol></div></blockquote>
<div id="H9.4.3"></div>
<h3> <span class="mw-headline" id="9.4.3_Interface_Method_Body_.5BNew.5D"> 9.4.3 Interface Method Body [New] </span></h3>
<p>A default method has a block body.  This block of code provides an implementation of the method in the event that a class implements the interface but does not provide its own implementation of the method.
</p><p>A static method also has a block body, which provides the implementation of the method.
</p><p><span class="norm-error">
It is a compile-time error if an interface method declaration is <code style="background-color:inherit;font-size:medium">abstract</code> (explicitly or implicitly) and has a block for its body.<span class="assertion-id"> [jsr335-9.4.3-10]</span></span>
</p><p><span class="norm-error">
It is a compile-time error if an interface method declaration is <code style="background-color:inherit;font-size:medium">default</code> or <code style="background-color:inherit;font-size:medium">static</code> and has a semicolon for its body.<span class="assertion-id"> [jsr335-9.4.3-12]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The above mimic <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.7" class="external text" rel="nofollow">8.4.7</a>.</div></blockquote>
<p><span class="norm-error">
It is a compile-time error if a default method is override-equivalent with a non-<code style="background-color:inherit;font-size:medium">private</code> method of the class <code style="background-color:inherit;font-size:medium">Object</code>, because any class implementing the interface will inherit its own implementation of the method.<span class="assertion-id"> [jsr335-9.4.3-20]</span></span>
</p><p><span class="norm-error">
It is a compile-time error for the body of a <code style="background-color:inherit;font-size:medium">static</code> method to attempt to reference the current object using the keyword <code style="background-color:inherit;font-size:medium">this</code> or the keyword <code style="background-color:inherit;font-size:medium">super</code>.<span class="assertion-id"> [jsr335-9.4.3-22]</span></span>
</p><p><span class="norm-error">
If a method is declared <code style="background-color:inherit;font-size:medium">void</code>, then its body must not contain any <code style="background-color:inherit;font-size:medium">return</code> statement (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.17" class="external text" rel="nofollow">14.17</a>) that has an <em>Expression</em>, or a compile-time error occurs.<span class="assertion-id"> [jsr335-9.4.3-30]</span></span>
</p><p><span class="norm-error">
If a method is declared to have a return type, then every <code style="background-color:inherit;font-size:medium">return</code> statement (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.17" class="external text" rel="nofollow">14.17</a>) in its body must have an <em>Expression</em>, or a compile-time error occurs.<span class="assertion-id"> [jsr335-9.4.3-40]</span></span>
</p><p><span class="norm-error">
If a method is declared to have a return type, then a compile-time error occurs if the body of the method can complete normally (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.1" class="external text" rel="nofollow">14.1</a>).<span class="assertion-id"> [jsr335-9.4.3-50]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The previous three sentences mimic <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.7" class="external text" rel="nofollow">8.4.7</a>.</div></blockquote>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p><p>The prohibition against declaring one of the <code style="background-color:inherit;font-size:medium">Object</code> methods as a default method may be surprising.  There are, after all, cases like <code style="background-color:inherit;font-size:medium">java.util.List</code> in which the behavior of <code style="background-color:inherit;font-size:medium">toString</code> and <code style="background-color:inherit;font-size:medium">equals</code> are precisely defined.  The motivation becomes clearer, however, when some broader design decisions are well-understood:
</p>
<ul><li> First, methods inherited from a superclass are allowed to override methods inherited from superinterfaces.  So every implementing class would automatically override an interface's <code style="background-color:inherit;font-size:medium">toString</code> default.  This is Java's longstanding behavior, and it's not something we wish to change with the design of default methods, because that would conflict with the goal of allowing interfaces to unobtrusively evolve, only providing default behavior when the class, through its normal hierarchy, doesn't already have it.
</li><li> Second, interfaces do <i>not</i> inherit from <code style="background-color:inherit;font-size:medium">Object</code>, even though they implicitly declare many of the same methods (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.2" class="external text" rel="nofollow">9.2</a>).  So there is no common ancestor for <code style="background-color:inherit;font-size:medium">toString</code> declared in <code style="background-color:inherit;font-size:medium">Object</code> and <code style="background-color:inherit;font-size:medium">toString</code> declared in an interface; at best, if both were candidates for inheritance by a class, they would conflict.  Working around this problem would require awkward commingling of the class and interface inheritance trees.
</li><li> Third, use cases for declaring <code style="background-color:inherit;font-size:medium">Object</code> methods in interfaces typically assume a linear interface hierarchy; the feature does not generalize very well to multiple inheritance scenarios.
</li><li> Fourth, the <code style="background-color:inherit;font-size:medium">Object</code> methods are so fundamental that it seems dangerous to allow an arbitrary superinterface to silently add a default method that changes their behavior.
</li></ul>
<p>The interface is free, however, to define another method that provides behavior useful for classes that override the <code style="background-color:inherit;font-size:medium">Object</code> methods.  For example, the <code style="background-color:inherit;font-size:medium">java.util.List</code> interface could declare a <code style="background-color:inherit;font-size:medium">elementString</code> method that produces the string described by the contract of <code style="background-color:inherit;font-size:medium">toString</code>; implementors could then simply delegate to this method.
</p>
For further discussion, see <a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008435.html" class="external free" rel="nofollow">http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008435.html</a>.</div></blockquote>
<div id="H9.6"></div>
<h3> <span class="mw-headline" id="9.6_Annotation_Types_.5BModified.5D"> 9.6 Annotation Types [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.6" class="external text" rel="nofollow">JLS 9.6</a></small>
</p><p>...
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
AnnotationTypeDeclaration:
  InterfaceModifiers<sub>opt</sub> '@' 'interface' Identifier AnnotationTypeBody

AnnotationTypeBody:
  '{' AnnotationType<del>Element</del><u>Member</u>Declarations<sub>opt</sub> '}'

AnnotationType<del>Element</del><u>Member</u>Declarations:
  AnnotationType<del>Element</del><u>Member</u>Declaration
  AnnotationType<del>Element</del><u>Member</u>Declarations AnnotationType<del>Element</del><u>Member</u>Declaration
</pre>
<p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
The renamings and restructurings in this and the next section are simply for clarification.</div></blockquote>
<div id="H9.6.1"></div>
<h3> <span class="mw-headline" id="9.6.1_Annotation_Type_Elements_.5BModified.5D"> 9.6.1 Annotation Type Elements [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.6.1" class="external text" rel="nofollow">JLS 9.6.1</a></small>
</p><p>...
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
AnnotationType<del>Element</del><u>Member</u>Declaration:
  <u>AnnotationTypeElementDeclaration</u>
  ConstantDeclaration
  ClassDeclaration
  InterfaceDeclaration
  <del>EnumDeclaration</del>
  <del>AnnotationTypeDeclaration</del>
  ';'
  
<u>AnnotationTypeElementDeclaration:</u>
  <del>AbstractMethodModifiers<sub>opt</sub></del> <u>AnnotationTypeElementModifiers<sub>opt</sub></u>
              Type Identifier '(' ')' Dims<sub>opt</sub> DefaultValue<sub>opt</sub> ';'

<u>AnnotationTypeElementModifiers:</u>
  <u>AnnotationTypeElementModifier</u>
  <u>AnnotationTypeElementModifiers AnnotationTypeElementModifier</u>
  
<u>AnnotationTypeElementModifier: one of</u>
  <u>Annotation 'public' 'abstract'</u>
  
DefaultValue:
  'default' ElementValue
</pre>
<p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div>
<p>A few changes are made here for clarification, but the only substantial change is to introduce the production <code style="background-color:inherit;font-size:medium">AnnotationTypeElementModifiers</code> to replace <code style="background-color:inherit;font-size:medium">AbstractMethodModifiers</code> (now renamed <code style="background-color:inherit;font-size:medium">InterfaceMethodModifiers</code>).  This is to avoid allowing the new interface method modifiers on annotation type element declarations.
</p>
</div></li>
<li style="margin-bottom:12px;"><div>
<p>While we've expanded the variety of methods that can be declared in interfaces in general (including <code style="background-color:inherit;font-size:medium">static</code> methods and <code style="background-color:inherit;font-size:medium">default</code> methods), to avoid confusion we prefer <i>not</i> to expand the variety of methods that can be declared in annotation types.
</p><p>Note that is is still possible, however, for an annotation type to inherit a default method from its implicit superinterface, <code style="background-color:inherit;font-size:medium">Annotation</code> (though no such default method exists currently).
</p>
</div></li></ol></div></blockquote>
<div id="H8.1.1.1"></div>
<h3> <span class="mw-headline" id="8.1.1.1_abstract_Classes_.5BModified.5D"> 8.1.1.1 <code style="background-color:inherit;font-size:medium">abstract</code> Classes [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.1.1" class="external text" rel="nofollow">JLS 8.1.1.1</a></small>
</p><p>An <code style="background-color:inherit;font-size:medium">abstract</code> class is a class that is incomplete, or to be considered incomplete.
</p><p><span class="norm-static">
Normal classes may have <code style="background-color:inherit;font-size:medium">abstract</code> methods (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.3.1" class="external text" rel="nofollow">8.4.3.1</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.4" class="external text" rel="nofollow">9.4</a>), that is, methods that are declared but not yet implemented, only if they are <code style="background-color:inherit;font-size:medium">abstract</code> classes.<span class="assertion-id"> [jls-8.1.1.1-110]</span></span>
</p><p><span class="norm-error">
If a normal class that is not <code style="background-color:inherit;font-size:medium">abstract</code> contains an <code style="background-color:inherit;font-size:medium">abstract</code> method, then a compile-time error occurs.<span class="assertion-id"> [jls-8.1.1.1-120]</span></span>
</p><p>...
</p><p><span class="norm-static">
A class <em>C</em> has <code style="background-color:inherit;font-size:medium">abstract</code> methods if <del>any</del> <u>either</u> of the following is true:<span class="assertion-id"> [jls-8.1.1.1-200]</span></span>
</p>
<ul><li> <span class="norm-static"> <u>Any of the member methods (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.2" class="external text" rel="nofollow">8.2</a>) of <em>C</em>—either declared or inherited—is <code style="background-color:inherit;font-size:medium">abstract</code>.</u><span class="assertion-id"> [jsr335-8.1.1.1-200-A]</span></span>
</li><li> <span class="norm-static"> Any of <em>C</em>'s superclasses has an <code style="background-color:inherit;font-size:medium">abstract</code> method <u>declared with package access, and there exists no method that overrides the <code style="background-color:inherit;font-size:medium">abstract</code> method from <em>C</em> or from a superclass of <em>C</em>.</u><span class="assertion-id"> [jsr335-8.1.1.1-200-B]</span></span>
</li></ul>
<p><span class="norm-error">
It is a compile-time error if an attempt is made to create an instance of an <code style="background-color:inherit;font-size:medium">abstract</code> class using a class instance creation expression (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9" class="external text" rel="nofollow">15.9</a>).<span class="assertion-id"> [jls-8.1.1.1-300]</span></span>
</p><p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
These changes are not meant to substantively change the definition of an abstract class, but rather to clarify the existing meaning.  We interpret the previous clause requiring that, for every abstract method, <em>C</em> "declares [or] inherits a method that implements it", to mean that the abstract method is overridden in <em>C</em> or in some supertype of <em>C</em> (and thus the abstract method would not be inherited by <em>C</em>).</div></blockquote>
<div id="H8.1.3"></div>
<h3> <span class="mw-headline" id="8.1.3_Inner_Classes_and_Enclosing_Instances_.5BModified.5D"> 8.1.3 Inner Classes and Enclosing Instances [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.3" class="external text" rel="nofollow">JLS 8.1.3</a></small>
</p><p>...
</p><p><span class="norm-static">
An inner class <em>C</em> is a <i>direct inner class of a class <u>or interface</u> <em>O</em></i> if <em>O</em> is the immediately lexically enclosing <del>class</del> <u>type declaration</u> of <em>C</em> and the declaration of <em>C</em> does not occur in a static context.<span class="assertion-id"> [jls-8.1.3-300]</span></span>
</p><p><span class="norm-static">
A class <em>C</em> is an <i>inner class of class <u>or interface</u> <em>O</em></i> if it is either a direct inner class of <em>O</em> or an inner class of an inner class of <em>O</em>.<span class="assertion-id"> [jls-8.1.3-310]</span></span>
</p><p><span class="norm-static">
A class <u>or interface</u> <em>O</em> is the <i>zeroth lexically enclosing <del>class</del> <u>type declaration</u></i> of itself.<span class="assertion-id"> [jls-8.1.3-320]</span></span>
</p><p><span class="norm-static">
A class <u>or interface</u> <em>O</em> is the <i>n'th lexically enclosing <del>class</del> <u>type declaration</u> of a class <em>C</em></i> if it is the immediately enclosing <del>class</del> <u>type declaration</u> of the <em>n-1</em>'th lexically enclosing <del>class</del> <u>type declaration</u> of <em>C</em>.<span class="assertion-id"> [jls-8.1.3-330]</span></span>
</p><p><span class="norm-static">
An instance <em>i</em> of a direct inner class <em>C</em> of a class <u>or interface</u> <em>O</em> is associated with an instance of <em>O</em>, known as the <i>immediately enclosing instance</i> of <em>i</em>.  The immediately enclosing instance of an object, if any, is determined when the object is created (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.2" class="external text" rel="nofollow">15.9.2</a>).<span class="assertion-id"> [jls-8.1.3-400]</span></span>
</p><p>...
</p><p><span class="norm-static">
For every superclass <em>S</em> of <em>C</em> which is itself a direct inner class of a class <u>or interface</u> <em>SO</em>, there is an instance of <em>SO</em> associated with <em>i</em>, known as the <i>immediately enclosing instance of <em>i</em> with respect to <em>S</em></i>.  The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement.<span class="assertion-id"> [jls-8.1.3-440]</span></span>
</p><p><span class="norm-static">
When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing class, the variable of the corresponding lexically enclosing instance is used.<span class="assertion-id"> [jls-8.1.3-500]</span></span>
</p><p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>Similar changes to the <i>lexically enclosing class</i> terminology should be made in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8.7.1" class="external text" rel="nofollow">8.8.7.1</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html#jls-13.1" class="external text" rel="nofollow">13.1</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.2" class="external text" rel="nofollow">15.9.2</a>.</div></blockquote>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p><p>It is unusual, but possible, for an enclosing type of an inner class to be an interface.  Such a class can only be declared inside of a default method body (<a href="#H9.4" title="Lambda H" class="mw-redirect">9.4</a>).  This includes, for example, the following cases:
</p>
<ul><li> An anonymous class declared in a default method body.
</li><li> A local class declared in a default method body.
</li><li> A member class of an anonymous class declared in a default method body.
</li></ul>
Note that only the outermost enclosing type declaration of an inner class can be an interface—all other enclosing type declarations are inner classes, and it is impossible to declare an "inner interface."</div></blockquote>
<div id="H8.1.5"></div>
<h3> <span class="mw-headline" id="8.1.5_Superinterfaces_.5BModified.5D"> 8.1.5 Superinterfaces [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.5" class="external text" rel="nofollow">JLS 8.1.5</a></small>
</p><p>...
</p><p><span class="norm-static">
Unless the class being declared is <code style="background-color:inherit;font-size:medium">abstract</code>, <u>all the abstract member methods</u> of each direct superinterface must be implemented <u>(<a href="#H8.4.8.1" title="Lambda H" class="mw-redirect">8.4.8.1</a>)</u> either by a declaration in this class or by an existing method declaration inherited from the direct superclass <u>or a direct superinterface</u>, because a class that is not abstract is not permitted to have abstract methods (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.1.1" class="external text" rel="nofollow">8.1.1.1</a>).<span class="assertion-id"> [jls-8.1.5-500]</span></span>
</p><p><u>Each default method (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.4.3" class="external text" rel="nofollow">9.4.3</a>) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body.</u>
</p><p><span class="norm-static">
It is permitted for a single method declaration in a class to implement methods of more than one superinterface.<span class="assertion-id"> [jls-8.1.5-510]</span></span>
</p><p>...
</p>
<div id="H8.4.3.1"></div>
<h3> <span class="mw-headline" id="8.4.3.1_abstract_Methods_.5BAddendum.5D"> 8.4.3.1 <code style="background-color:inherit;font-size:medium">abstract</code> Methods [Addendum] </span></h3>
<p><small>See <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.3.1" class="external text" rel="nofollow">JLS 8.4.3.1</a></small>
</p><p><span class="norm-static">
If a method declared by a class is not <code style="background-color:inherit;font-size:medium">abstract</code>, it may be referred to as a <i>concrete</i> method.<span class="assertion-id"> [jsr335-8.4.3.1-10]</span></span>
</p>
<div id="H8.4.8"></div>
<h3> <span class="mw-headline" id="8.4.8_Inheritance.2C_Overriding.2C_and_Hiding_.5BModified.5D"> 8.4.8 Inheritance, Overriding, and Hiding [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.8" class="external text" rel="nofollow">JLS 8.4.8</a></small>
</p><p><span class="norm-static">
A class <em>C</em> <i>inherits</i> from its direct superclass <del>and direct superinterfaces</del> all <u>concrete (both <code style="background-color:inherit;font-size:medium">static</code> and instance)</u> <del><code style="background-color:inherit;font-size:medium">abstract</code> and non-<code style="background-color:inherit;font-size:medium">abstract</code></del> methods <u><em>m</em></u> of the superclass <del>and superinterfaces</del> <u>for which all of the following are true:</u><span class="assertion-id"> [jls-8.4.8-100]</span></span>
</p>
<ul><li> <span class="norm-static"> <u><em>m</em> is a member of the direct superclass of <em>C</em>.</u><span class="assertion-id"> [jsr335-8.4.8-100-A]</span></span>
</li><li> <span class="norm-static"> <u><em>m</em> is</u> <code style="background-color:inherit;font-size:medium">public</code>, <code style="background-color:inherit;font-size:medium">protected</code>, or declared with <del>default</del> <u>package</u> access in the same package as <em>C</em>.<span class="assertion-id"> [jsr335-8.4.8-100-B]</span></span>
</li><li> <span class="norm-static"> <u>No method declared in <em>C</em> has a signature that is a subsignature (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.2" class="external text" rel="nofollow">8.4.2</a>) of the signature of <em>m</em>.</u><span class="assertion-id"> [jsr335-8.4.8-100-C]</span></span>
</li></ul>
<p><span class="norm-static">
<u>A class does not inherit <code style="background-color:inherit;font-size:medium">static</code> methods from its superinterfaces.</u><span class="assertion-id"> [jsr335-8.4.8-15]</span></span>
</p><p><span class="norm-static">
<u>A class <em>C</em> <i>inherits</i> from its direct superclass and direct superinterfaces all <code style="background-color:inherit;font-size:medium">abstract</code> and default (<a href="#H9.4" title="Lambda H" class="mw-redirect">9.4</a>) methods <em>m</em> for which all of the following are true:</u><span class="assertion-id"> [jsr335-8.4.8-20]</span></span>
</p>
<ul><li> <span class="norm-static"> <u><em>m</em> is a member of the direct superclass or a direct superinterface, <em>D</em>, of <em>C</em>.</u><span class="assertion-id"> [jsr335-8.4.8-20-A]</span></span>
</li><li> <span class="norm-static"> <u><em>m</em> is</u> <code style="background-color:inherit;font-size:medium">public</code>, <code style="background-color:inherit;font-size:medium">protected</code>, or declared with <del>default</del> <u>package</u> access in the same package as <em>C</em>.<span class="assertion-id"> [jsr335-8.4.8-20-E]</span></span>
</li><li> <span class="norm-static"> <u>No method declared in <em>C</em> has a signature that is a subsignature (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.2" class="external text" rel="nofollow">8.4.2</a>) of the signature of <em>m</em>.</u><span class="assertion-id"> [jsr335-8.4.8-20-B]</span></span>
</li><li> <span class="norm-static"> <u>No concrete method inherited by <em>C</em> from its direct superclass has a signature that is a subsignature of the signature of <em>m</em>.</u><span class="assertion-id"> [jsr335-8.4.8-20-C]</span></span>
</li><li> <span class="norm-static"> <u>There exists no method <em>m'</em> that is a member of the direct superclass or a direct superinterface, <em>D'</em>, of <em>C</em> (<em>m</em> distinct from <em>m'</em>, <em>D</em> distinct from <em>D'</em>), such that <em>m'</em> overrides the declaration of <em>m</em> from <em>D'</em>.</u><span class="assertion-id"> [jsr335-8.4.8-20-D]</span></span>
</li></ul>
<p><del><span class="norm-static">If the method not inherited is declared in a class, or the method not inherited is declared in an interface and the new declaration is <code style="background-color:inherit;font-size:medium">abstract</code>, then the new declaration is said to <i>override</i> it.<span class="assertion-id"> [jls-8.4.8-200]</span></span></del>
</p><p><del><span class="norm-static">If the method not inherited is <code style="background-color:inherit;font-size:medium">abstract</code> and the new declaration is not <code style="background-color:inherit;font-size:medium">abstract</code>, then the new declaration is said to <i>implement</i> it.<span class="assertion-id"> [jls-8.4.8-210]</span></span></del>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> This definition of inheritance achieves two goals:
<ul><li> Clarify that it is possible for an inherited concrete method to prevent the inheritance of an abstract or default method.  (Later we will assert that the concrete method overrides the abstract or default method "from <em>C</em>".)  This has always been the case (for abstract methods), but it has been poorly specified.
</li><li> Introduce, for classes, the rule that one supertype method can prevent the inheritance of another supertype method if the former  "already" overrides the latter.  This is the same as the rule for interfaces, and prevents conflicts in which multiple default methods are inherited, even though one implementation is clearly meant to supersede the other.
</li></ul>
</div></li>
<li style="margin-bottom:12px;"><div> The definitions of "override" and "implement" retracted here are inconsistent with those in the following section.  There doesn't seem to be a need to provide a separate definition here.
</div></li></ol></div></blockquote>
<div id="H8.4.8.1"></div>
<h3> <span class="mw-headline" id="8.4.8.1_Overriding_.28by_Instance_Methods.29_.5BModified.5D"> 8.4.8.1 Overriding (by Instance Methods) [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.8.1" class="external text" rel="nofollow">JLS 8.4.8.1</a></small>
</p><p><span class="norm-static">
An instance method <em>m<sub>1</sub></em>, declared <u>or inherited by</u> class <em>C</em>, <u><i>overrides from <em>C</em></i></u> another <del>instance</del> method <em>m<sub>2</sub></em>, declared in class <em>A</em>, iff all of the following are true:<span class="assertion-id"> [jls-8.4.8.1-100]</span></span>
</p>
<ul><li> <span class="norm-static"> <u><em>A</em> is a superclass of <em>C</em></u> <del><em>C</em> is a subclass of <em>A</em></del>.<span class="assertion-id"> [jls-8.4.8.1-100-A]</span></span>
</li><li> <span class="norm-static"> <u><em>C</em> does not inherit <em>m<sub>2</sub></em>.</u><span class="assertion-id"> [jsr335-8.4.8.1-100-D]</span></span>
</li><li> <span class="norm-static"> The signature of <em>m<sub>1</sub></em> is a subsignature (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.2" class="external text" rel="nofollow">8.4.2</a>) of the signature of <em>m<sub>2</sub></em>.<span class="assertion-id"> [jls-8.4.8.1-100-B]</span></span>
</li><li> <span class="norm-static"> <u>One of</u> <del>Either</del>:<span class="assertion-id"> [jls-8.4.8.1-100-C]</span></span>
<ul><li> <span class="norm-static"> <em>m<sub>2</sub></em> is <code style="background-color:inherit;font-size:medium">public</code>.<span class="assertion-id"> [jls-8.4.8.1-100-C-1]</span></span>
</li><li> <span class="norm-static"> <u><em>m<sub>2</sub></em> is</u> <code style="background-color:inherit;font-size:medium">protected</code>.<span class="assertion-id"> [jsr335-8.4.8.1-100-C-3]</span></span>
</li><li> <span class="norm-static"> <u><em>m<sub>2</sub></em> is</u> declared with <u>package</u> <del>default</del> access in the same package as <em>C</em>, <u>and either <em>C</em> declares <em>m<sub>1</sub></em> or <em>m<sub>2</sub></em> is a member of the direct superclass of <em>C</em></u>.<span class="assertion-id"> [jsr335-8.4.8.1-100-C-4]</span></span>
</li><li> <span class="norm-static"> <u><em>m<sub>2</sub></em> is declared with package access and <em>m<sub>1</sub></em> overrides <em>m<sub>2</sub></em> from some superclass of <em>C</em>.</u><span class="assertion-id"> [jsr335-8.4.8.1-100-C-5]</span></span>
</li><li> <span class="norm-static"> <u><em>m<sub>2</sub></em> is declared with package access</u> and <em>m<sub>1</sub></em> overrides a method <em>m<sub>3</sub></em> <u>from <em>C</em></u> (<em>m<sub>3</sub></em> distinct from <em>m<sub>1</sub></em>, <em>m<sub>3</sub></em> distinct from <em>m<sub>2</sub></em>), such that <em>m<sub>3</sub></em> overrides <em>m<sub>2</sub></em> <u>from some superclass of <em>C</em></u>.<span class="assertion-id"> [jls-8.4.8.1-100-C-2]</span></span>
</li></ul>
</li></ul>
<p><span class="norm-static">
<u>An instance method <em>m<sub>1</sub></em>, declared or inherited by class <em>C</em>, <i>overrides from <em>C</em></i> another method <em>m<sub>2</sub></em>, declared in an interface <em>I</em>, iff all of the following are true:</u><span class="assertion-id"> [jsr335-8.4.8.1-20]</span></span>
</p>
<ul><li> <span class="norm-static"> <u><em>I</em> is a superinterface of <em>C</em>.</u><span class="assertion-id"> [jsr335-8.4.8.1-20-A]</span></span>
</li><li> <span class="norm-static"> <u><em>m<sub>2</sub></em> is an <code style="background-color:inherit;font-size:medium">abstract</code> or default method.</u><span class="assertion-id"> [jsr335-8.4.8.1-20-C]</span></span>
</li><li> <span class="norm-static"> <u>The signature of <em>m<sub>1</sub></em> is a subsignature (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.2" class="external text" rel="nofollow">8.4.2</a>) of the signature of <em>m<sub>2</sub></em>.</u><span class="assertion-id"> [jsr335-8.4.8.1-20-B]</span></span>
</li></ul>
<p><span class="norm-static">
<u>If a non-<code style="background-color:inherit;font-size:medium">abstract</code> method <em>m<sub>1</sub></em> overrides an <code style="background-color:inherit;font-size:medium">abstract</code> method <em>m<sub>2</sub></em> from a class <em>C</em></u>, then <em>m<sub>1</sub></em> is said to <i>implement</i> <u><em>m<sub>2</sub></em> <i>from <em>C</em></i></u>.<span class="assertion-id"> [jsr335-8.4.8.1-30]</span></span>
</p><p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> Previously, the overriding relationship between a method declared in a class and a method declared in an interface was unspecified.  That has been fixed.
</div></li>
<li style="margin-bottom:12px;"><div> Most of the other changes here are to extend the notion of overriding to handle methods that override another from some subclass of their declaring class.  This can happen in two ways:
<ul><li> A concrete instance method in a generic superclass can, under certain parameterizations, have the same signature as an abstract method in that class.  In this case, the concrete method is inherited and the abstract method is not (as described above).  The inherited method should then be considered to override its abstract peer <i>from <em>C</em></i>.  (This scenario is complicated by package access: if <em>C</em> is in a different package, then <em>m<sub>2</sub></em> would not have been inherited anyway, and should not be considered overridden.)
</li><li> An inherited superclass method can override a superinterface method.  (Happily, package access is not a concern here.)
</li></ul>
</div></li></ol></div></blockquote>
<div id="H8.4.8.2"></div>
<h3> <span class="mw-headline" id="8.4.8.2_Hiding_.28by_Class_Methods.29_.5BModified.5D"> 8.4.8.2 Hiding (by Class Methods) [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.8.2" class="external text" rel="nofollow">JLS 8.4.8.2</a></small>
</p><p><span class="norm-static">
If a class <u><em>C</em></u> declares <u>or inherits</u> a <code style="background-color:inherit;font-size:medium">static</code> method <em>m</em>, then <del>the declaration</del> <em>m</em> is said to <i>hide <u>in <em>C</em></u></i> any method <em>m'</em>, where the signature of <em>m</em> is a subsignature (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.2" class="external text" rel="nofollow">8.4.2</a>) of the signature of <em>m'</em>, in the superclasses and superinterfaces of <del>the class</del> <u><em>C</em></u> that would otherwise be accessible to code in <del>the class</del> <u><em>C</em></u>.<span class="assertion-id"> [jls-8.4.8.2-100]</span></span>
</p><p><span class="norm-error">
It is a compile-time error if a <code style="background-color:inherit;font-size:medium">static</code> method hides an instance method.<span class="assertion-id"> [jls-8.4.8.2-110]</span></span>
</p><p>...
</p>
<div id="H8.4.8.4"></div>
<h3> <span class="mw-headline" id="8.4.8.4_Inheriting_Methods_with_Override-Equivalent_Signatures_.5BModified.5D"> 8.4.8.4 Inheriting Methods with Override-Equivalent Signatures [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.8.4" class="external text" rel="nofollow">JLS 8.4.8.4</a></small>
</p><p>It is possible for a class to inherit multiple methods with override-equivalent signatures (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.2" class="external text" rel="nofollow">8.4.2</a>).
</p><p><span class="norm-error">
It is a compile-time error if a class <em>C</em> inherits a concrete method whose signature is <del>a subsignature of</del> <u>override-equivalent with</u> another <del>concrete</del> method inherited by <em>C</em>.  <del>This can happen if a superclass is generic, and it has two methods that were distinct in the generic declaration, but have the same signature in the particular invocation used.</del><span class="assertion-id"> [jls-8.4.8.4-110]</span></span>
</p><p><span class="norm-error">
<u>It is a compile-time error if a class <em>C</em> inherits a default method whose signature is override-equivalent with another method inherited by <em>C</em>, unless there exists an <code style="background-color:inherit;font-size:medium">abstract</code> method declared in a superclass of <em>C</em> and inherited by <em>C</em> that is override-equivalent with the two methods.</u><span class="assertion-id"> [jls-8.4.8.4-112]</span></span>
</p><p><u>Note that this exception does not apply if all override-equivalent <code style="background-color:inherit;font-size:medium">abstract</code> methods inherited by <em>C</em> were declared in interfaces.</u>
</p><p><del><span class="norm-static">Otherwise, there are two possible cases:<span class="assertion-id"> [jls-8.4.8.4-120]</span></span></del>
</p><p><del><span class="norm-static">If one of the inherited methods is not <code style="background-color:inherit;font-size:medium">abstract</code>, ...<span class="assertion-id"> [jls-8.4.8.4-120-A]</span></span></del>
</p><p><span class="norm-static">
<del>If all the inherited methods are <code style="background-color:inherit;font-size:medium">abstract</code></del> <u>Otherwise, the set of override-equivalent methods consists of at least one <code style="background-color:inherit;font-size:medium">abstract</code> method and zero or more default methods;</u> then the class is necessarily an <code style="background-color:inherit;font-size:medium">abstract</code> class and is considered to inherit all the <del><code style="background-color:inherit;font-size:medium">abstract</code></del> methods.<span class="assertion-id"> [jls-8.4.8.4-120-B]</span></span>
</p><p><span class="norm-error">
One of the inherited methods must be return-type-substitutable for every other inherited method; otherwise, a compile-time error occurs.  (The <code style="background-color:inherit;font-size:medium">throws</code> clauses do not cause errors in this case.)<span class="assertion-id"> [jls-8.4.8.4-120-B.1]</span></span>
</p><p><u>These error conditions can be avoided by declaring a new method that overrides, and thus prevents the inheritance of, all conflicting methods.</u>
</p><p>There might be several paths by which the same method declaration <del>might be</del> <u>is</u> inherited from an interface.  This fact causes no difficulty and never, of itself, results in a compile-time error.
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> This is a dramatic simplification of this section, because the special rule allowing a concrete inherited method to "override" an abstract inherited method was eliminated in favor of a more accurate definition of inheritance (<a href="#H8.4.8" title="Lambda H" class="mw-redirect">8.4.8</a>).  The special rules for this scenario are no longer necessary, because they are covered by the usual rules for overriding (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.8.3" class="external text" rel="nofollow">8.4.8.3</a>).
<p>This section is now small enough that it may be preferable to merge it with another section.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> An exception to the strict default-abstract and default-default conflict rules is made when an <code style="background-color:inherit;font-size:medium">abstract</code> method is declared in a superclass: this assertion of abstract-ness coming from the superclass hierarchy essentially trumps the default, making the default method act as if it were abstract.  However, the abstract superclass method does not override the default method(s), because interfaces are still allowed to refine the <i>signature</i> of the abstract method coming from the class hierarchy.
</div></li></ol></div></blockquote>
<div id="H15.8"></div>
<h3> <span class="mw-headline" id="15.8_Primary_Expressions_.5BModified.5D"> 15.8 Primary Expressions [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.8" class="external text" rel="nofollow">JLS 15.8</a></small>
</p><p>...
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
PrimaryNoNewArray:
  Literal
  Type '.' 'class'
  'void' '.' 'class'
  'this'
  <del>ClassName</del> <u>TypeName</u> '.' 'this'
  ...
</pre>
<p>...
</p>
<div id="H15.8.3"></div>
<h3> <span class="mw-headline" id="15.8.3_this_.5BModified.5D"> 15.8.3 <code style="background-color:inherit;font-size:medium">this</code> [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.8.3" class="external text" rel="nofollow">JLS 15.8.3</a></small>
</p><p><span class="norm-error">
The keyword <code style="background-color:inherit;font-size:medium">this</code> may be used only in the body of an instance method, <u>default method</u>, instance initializer, or constructor, or in the initializer of an instance variable of a class.  If it appears anywhere else, a compile-time error occurs.<span class="assertion-id"> [jls-15.8.3-100]</span></span>
</p><p><span class="norm-dynamic">
When used as a primary expression, the keyword <code style="background-color:inherit;font-size:medium">this</code> denotes a value that is a reference to the object for which the instance <u>or default</u> method was invoked (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">15.12</a>), or to the object being constructed.<span class="assertion-id"> [jls-15.8.3-200]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>Additional text about lambda expressions was added here in Part B, <a href="#B15.8.3" title="Lambda B" class="mw-redirect">15.8.3</a>.</div></blockquote>
<p><span class="norm-static">
The type of <code style="background-color:inherit;font-size:medium">this</code> is the class <u>or interface type <em>T</em></u> within which the keyword <code style="background-color:inherit;font-size:medium">this</code> occurs.<span class="assertion-id"> [jls-15.8.3-210]</span></span>
</p><p><span class="norm-dynamic">
At run-time, the class of the actual object referred to may be <u><em>T</em>, if it is a class type, or a class that is a subtype of <em>T</em></u>.<span class="assertion-id"> [jls-15.8.3-220]</span></span>
</p><p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
Default methods provide the unique ability to access <code style="background-color:inherit;font-size:medium">this</code> inside of an interface.  (All other interface members are either abstract methods or <code style="background-color:inherit;font-size:medium">static</code>.  As a result, it is possible for <code style="background-color:inherit;font-size:medium">this</code> to have an interface type.</div></blockquote>
<div id="H15.8.4"></div>
<h3> <span class="mw-headline" id="15.8.4_Qualified_this_.5BModified.5D"> 15.8.4 Qualified <code style="background-color:inherit;font-size:medium">this</code> [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.8.4" class="external text" rel="nofollow">JLS 15.8.4</a></small>
</p><p>Any lexically enclosing instance (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.3" class="external text" rel="nofollow">8.1.3</a>) can be referred to by explicitly qualifying the keyword <code style="background-color:inherit;font-size:medium">this</code>.
</p><p><span class="norm-static">
Let <del><em>C</em></del> <u><em>T</em></u> be the <del>class</del> <u>type</u> denoted by <del><em>ClassName</em></del> <u><em>TypeName</em></u>.  Let <em>n</em> be an integer such that <del><em>C</em></del> <u><em>T</em></u> is the <em>n</em>'th lexically enclosing <del>class</del> <u>type declaration</u> of the class <u>or interface</u> in which the qualified <code style="background-color:inherit;font-size:medium">this</code> expression appears.<span class="assertion-id"> [jls-15.8.4-110]</span></span>
</p><p><span class="norm-dynamic">
The value of an expression of the form <em><del>ClassName</del> <u>TypeName</u> <code style="background-color:inherit;font-size:medium">. this</code></em> is the <em>n</em>'th lexically enclosing instance of <code style="background-color:inherit;font-size:medium">this</code>.<span class="assertion-id"> [jls-15.8.4-120]</span></span>
</p><p><span class="norm-static">
The type of the expression is <del><em>C</em></del> <u><em>T</em></u>.<span class="assertion-id"> [jls-15.8.4-200]</span></span>
</p><p><span class="norm-error">
It is a compile-time error if the current class <u>or interface</u> is not an inner class of <del><em>C</em></del> <u><em>T</em></u> or <del><em>C</em></del> <u><em>T</em></u> itself.<span class="assertion-id"> [jls-15.8.4-210]</span></span>
</p>
<div id="H15.11.2"></div>
<h3> <span class="mw-headline" id="15.11.2_Accessing_Superclass_Members_using_super_.5BModified.5D"> 15.11.2 Accessing Superclass Members using <code style="background-color:inherit;font-size:medium">super</code> [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.11.2" class="external text" rel="nofollow">JLS 15.11.2</a></small>
</p><p>...
</p><p><span class="norm-error">
The forms using the keyword <code style="background-color:inherit;font-size:medium">super</code> are valid only in an instance method, instance initializer, constructor, or in the initializer of an instance variable of a class.  If they appear anywhere else, a compile-time error occurs.<span class="assertion-id"> [jls-15.11.2-200]</span></span>
</p><p>These are exactly the same situations in which the keyword <code style="background-color:inherit;font-size:medium">this</code> may be used <u>in a class declaration</u> (<a href="#H15.8.3" title="Lambda H" class="mw-redirect">15.8.3</a>).
</p><p>...
</p>
<div id="H15.12"></div>
<h3> <span class="mw-headline" id="15.12_Method_Invocation_Expressions_.5BModified.5D"> 15.12 Method Invocation Expressions [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">JLS 15.12</a></small>
</p><p>A method invocation expression is used to invoke a class or instance method.
</p>
<pre style="border:none;background-color:inherit;font-size:medium;">
MethodInvocation:
  MethodName '(' ArgumentList<sub>opt</sub> ')'
  Primary '.' NonWildTypeArguments<sub>opt</sub> Identifier '(' ArgumentList<sub>opt</sub> ')'
  'super' '.' NonWildTypeArguments<sub>opt</sub> Identifier '(' ArgumentList<sub>opt</sub> ')'
  <del>ClassName</del> <u>TypeName</u> '.' 'super' '.'
          NonWildTypeArguments<sub>opt</sub> Identifier '(' ArgumentList<sub>opt</sub> ')'
  TypeName '.' NonWildTypeArguments Identifier '(' ArgumentList<sub>opt</sub> ')'
</pre>
<p>...
</p>
<div id="H15.12.1"></div>
<h3> <span class="mw-headline" id="15.12.1_Compile-Time_Step_1:_Determine_Class_or_Interface_to_Search_.5BModified.5D"> 15.12.1 Compile-Time Step 1: Determine Class or Interface to Search [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.1" class="external text" rel="nofollow">JLS 15.12.1</a></small>
</p><p><span class="norm-static">
The first step in processing a method invocation at compile time is to figure out the name of the method to be invoked and which class or interface to check for definitions of methods of that name.  There are several cases to consider, depending on the form that precedes the left parenthesis, as follows.<span class="assertion-id"> [jls-15.12.1-100]</span></span>
</p>
<ul>
<li><span class="norm-static"> If the form is <em>MethodName</em>, then there are three subcases:<span class="assertion-id"> [jls-15.12.1-100-A]</span></span><ul>

<li><span class="norm-static"> If it is a simple name, that is, just an <em>Identifier</em>, then ...<span class="assertion-id"> [jls-15.12.1-100-A-1]</span></span></li>
<li><span class="norm-static"> If it is a qualified name of the form <em>TypeName <code style="background-color:inherit;font-size:medium">.</code> Identifier</em>, then the name of the method is the <em>Identifier</em> and the <del>class</del> <u>type</u> to search is the one named by the <em>TypeName</em>.<span class="assertion-id"> [jls-15.12.1-100-A-2]</span></span>

<p><del><span class="norm-error"> If <em>TypeName</em> is the name of an interface rather than a class, then a compile-time error occurs, because this form can invoke only <code style="background-color:inherit;font-size:medium">static</code> methods and interfaces have no <code style="background-color:inherit;font-size:medium">static</code> methods.<span class="assertion-id"> [jls-15.12.1-100-A-2.1]</span></span></del></p>
</li>
<li><span class="norm-static"> In all other cases, the qualified name has the form <em>FieldName <code style="background-color:inherit;font-size:medium">.</code> Identifier</em>. ...<span class="assertion-id"> [jls-15.12.1-100-A-3]</span></span></li>
</ul></li>
<li><span class="norm-static">If the form is <em>Primary <code style="background-color:inherit;font-size:medium">.</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, ...<span class="assertion-id"> [jls-15.12.1-100-B]</span></span></li>
<li><span class="norm-static">
If the form is <em><code style="background-color:inherit;font-size:medium">super</code> <code style="background-color:inherit;font-size:medium">.</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, then the name of the method is the <em>Identifier</em> and the class to be searched is the superclass of the class whose declaration contains the method invocation.<span class="assertion-id"> [jls-15.12.1-100-C]</span></span>

<p><span class="norm-error">
Let <em>T</em> be the type declaration immediately enclosing the method invocation.  It is a compile-time error if <em>T</em> is the class <code style="background-color:inherit;font-size:medium">Object</code> or <em>T</em> is an interface.<span class="assertion-id"> [jls-15.12.1-100-C.1]</span></span>
</p></li>
<li><span class="norm-static">
If the form is <em><del>ClassName</del> <u>TypeName</u> <code style="background-color:inherit;font-size:medium">.</code> <code style="background-color:inherit;font-size:medium">super</code> <code style="background-color:inherit;font-size:medium">.</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, then the name of the method is the <em>Identifier</em>.<span class="assertion-id"> [jls-15.12.1-100-D]</span></span>

<p><span class="norm-error">
<u>It is a compile-time error if <em>TypeName</em> denotes neither a class nor an interface.</u><span class="assertion-id"> [jsr335-15.12.1-100-Y]</span></span>
</p>
<p><span class="norm-static">
<u>If <em>TypeName</em> denotes a class, <em>C</em>, then</u> the class to be searched is the superclass of <u><em>C</em></u>.<span class="assertion-id"> [jls-15.12.1-100-D']</span></span>
</p>
<p><span class="norm-error">
It is a compile-time error if <em>C</em> is not a lexically enclosing class of the current class.<span class="assertion-id"> [jls-15.12.1-100-D.1]</span></span>
</p>
<p><span class="norm-error">
It is a compile-time error if <em>C</em> is the class <code style="background-color:inherit;font-size:medium">Object</code>.<span class="assertion-id"> [jls-15.12.1-100-D.2]</span></span>
</p>
<p><span class="norm-static">
<u>Otherwise, <em>TypeName</em> denotes the interface to be searched, <em>I</em>.</u><span class="assertion-id"> [jsr335-15.12.1-100-Z]</span></span>
</p>
<p><span class="norm-error">
<u>Let <em>T</em> be the type declaration immediately enclosing the method invocation.  It is a compile-time error if <em>I</em> is not a direct superinterface of <em>T</em>, or if there exists some other direct superclass or direct superinterface of <em>T</em>, <em>J</em>, such that <em>J</em> is a subtype of <em>I</em>.</u><span class="assertion-id"> [jsr335-15.12.1-100-Z1]</span></span>
</p>
<p><del><span class="norm-error"> Let <em>T</em> be the type declaration immediately enclosing the method invocation.  It is a compile-time error if <em>T</em> is the class <code style="background-color:inherit;font-size:medium">Object</code> or <em>T</em> is an interface.<span class="assertion-id"> [jls-15.12.1-100-D.3]</span></span></del></p></li>
<li><span class="norm-static">
If the form is <em>TypeName <code style="background-color:inherit;font-size:medium">.</code> NonWildTypeArguments Identifier</em>, then the name of the method is the <em>Identifier</em> and the <del>class</del> <u>type</u> to be searched is the <del>class <em>C</em> denoted</del> <u>enclosing class type or direct superinterface type referenced</u>  by <em>TypeName</em>.<span class="assertion-id"> [jls-15.12.1-100-E]</span></span>

<p><del><span class="norm-error"> If <em>TypeName</em> is the name of an interface rather than a class, then a compile-time error occurs, because this form can invoke only <code style="background-color:inherit;font-size:medium">static</code> methods and interfaces have no <code style="background-color:inherit;font-size:medium">static</code> methods.<span class="assertion-id"> [jls-15.12.1-100-E.1]</span></span></del></p></li>
</ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p><p>The <em>TypeName <code style="background-color:inherit;font-size:medium">.</code> <code style="background-color:inherit;font-size:medium">super</code></em> syntax is overloaded: traditionally, the name refers to a lexically enclosing class, and the target is the superclass of this class (i.e., as if the invocation were an unqualified <code style="background-color:inherit;font-size:medium">super</code> from the lexically enclosing class).
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
class Superclass { void foo() { System.out.println(&quot;Hi&quot;); } }

class Subclass1 extends Superclass {
  void foo() { throw new UnsupportedOperationException(); }
  Runnable tweak = new Runnable() {
    void run() {
      Subclass1.super.foo(); // gets the 'println' behavior
    }
  };
}
</pre>
<p>To support invocation of default methods in superinterfaces, the name may also refer to a direct superinterface of the current class or interface, and the target is that superinterface.
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
interface Superinterface { default void foo() { System.out.println(&quot;Hi&quot;); } }

class Subclass2 implements Superinterface {
  void foo() { throw new UnsupportedOperationException(); }
  void tweak() {
    Superinterface.super.foo(); // gets the 'println' behavior
  }
}
</pre>
<p>No syntax supports a combination of these forms—invoking a superinterface method of a lexically enclosing class (i.e., as if the invocation were of the form <em>Interface <code style="background-color:inherit;font-size:medium">.</code> <code style="background-color:inherit;font-size:medium">super</code></em> from the lexically enclosing class).
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
class Subclass3 implements Superinterface {
  void foo() { throw new UnsupportedOperationException(); }
  Runnable tweak = new Runnable() {
    void run() {
      Subclass3.Superinterface.super.foo(); // NOT SUPPORTED
    }
  };
}
</pre>
There is unlikely to be much need for such syntax; the workaround is to introduce a private method in the lexically enclosing class that performs the interface <code style="background-color:inherit;font-size:medium">super</code> call.</div></blockquote>
<div id="H15.12.2.5"></div>
<h3> <span class="mw-headline" id="15.12.2.5_Choosing_the_Most_Specific_Method_.5BModified.5D"> 15.12.2.5 Choosing the Most Specific Method [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.5" class="external text" rel="nofollow">JLS 15.12.2.5</a></small>
</p><p>...
</p><p><span class="norm-static">
It is possible that no method is the most specific, because there are two or more methods that are maximally specific.  In this case:<span class="assertion-id"> [jls-15.12.2.5-530]</span></span>
</p>
<ul><li> <span class="norm-static"> If all the maximally specific methods have override-equivalent signatures (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.2" class="external text" rel="nofollow">8.4.2</a>), then:<span class="assertion-id"> [jls-15.12.2.5-530-A]</span></span>
<ul><li> <span class="norm-static"> If exactly one of the maximally specific methods is <del>not declared <code style="background-color:inherit;font-size:medium">abstract</code></del> <u>concrete</u>, it is the most specific method.<span class="assertion-id"> [jls-15.12.2.5-530-A-1]</span></span>
</li><li> <span class="norm-static"> Otherwise, if all the maximally specific methods are <del>declared</del> <code style="background-color:inherit;font-size:medium">abstract</code> <u>or default</u>, and the signatures of all the maximally specific methods have the same erasure (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.6" class="external text" rel="nofollow">4.6</a>), then the most specific method is chosen arbitrarily among the subset of the maximally specific methods that have the most specific return type.<span class="assertion-id"> [jls-15.12.2.5-530-A-2]</span></span><p><span class="norm-static"> However, the most specific method is considered <u>i) to be <code style="background-color:inherit;font-size:medium">abstract</code>, and ii)</u> to throw a checked exception if and only if that exception or its erasure is declared in the <code style="background-color:inherit;font-size:medium">throws</code> clauses of each of the maximally specific methods.<span class="assertion-id"> [jls-15.12.2.5-530-A-2.1]</span></span></p>
</li></ul>
</li><li> <span class="norm-error"> Otherwise, we say the method invocation is <i>ambiguous</i>, and a compile-time error occurs.<span class="assertion-id"> [jls-15.12.2.5-530-B]</span></span>
</li></ul>
<div id="H15.12.3"></div>
<h3> <span class="mw-headline" id="15.12.3_Compile-Time_Step_3:_Is_the_Chosen_Method_Appropriate.3F_.5BModified.5D"> 15.12.3 Compile-Time Step 3: Is the Chosen Method Appropriate? [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.3" class="external text" rel="nofollow">JLS 15.12.3</a></small>
</p><p>...
</p><p><span class="norm-error">
<u>If the method invocation has, before the left parenthesis, the form <em>ExpressionName <code style="background-color:inherit;font-size:medium">.</code> NonWildTypeArguments<sub>opt</sub> Identifier</em> or <em>Primary <code style="background-color:inherit;font-size:medium">.</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, then the compile-time declaration must not be a <code style="background-color:inherit;font-size:medium">static</code> method declared in an interface, or a compile-time error occurs.</u><span class="assertion-id"> [jsr335-15.12.3-10]</span></span>
</p><p>...
</p><p><span class="norm-error">
If the method invocation has, before the left parenthesis, the form <em><del>ClassName</del> <u>TypeName</u> <code style="background-color:inherit;font-size:medium">.</code> <code style="background-color:inherit;font-size:medium">super</code> <code style="background-color:inherit;font-size:medium">.</code> NonWildTypeArguments<sub>opt</sub> Identifier</em>, then:<span class="assertion-id"> [jls-15.12.3-140]</span></span>
</p>
<ul><li> <span class="norm-error"> If the compile-time declaration is <code style="background-color:inherit;font-size:medium">abstract</code>, a compile-time error occurs.<span class="assertion-id"> [jls-15.12.3-140-A]</span></span>
</li><li> <span class="norm-error"> If the method invocation occurs in a static context, a compile-time error occurs.<span class="assertion-id"> [jls-15.12.3-140-B]</span></span>
</li><li> <del><span class="norm-error"> Otherwise, let <em>C</em> be the class denoted by <em>ClassName</em>.  If the invocation is not directly enclosed by <em>C</em> or an inner class of <em>C</em>, then a compile-time error occurs.<span class="assertion-id"> [jls-15.12.3-140-C]</span></span></del>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>The previous check is redundant: the same error is asserted in <a href="#H15.12.1" title="Lambda H" class="mw-redirect">15.12.1</a>.</div></blockquote>
<ul><li> <span class="norm-error"> <u>Otherwise, if the <em>TypeName</em> denotes an interface, let <em>T</em> be the type declaration immediately enclosing the method invocation.  A compile-time error occurs if there exists a method, distinct from the compile-time declaration, that overrides (<a href="#H9.4.1" title="Lambda H" class="mw-redirect">9.4.1</a>) the compile-time declaration from a direct superclass or direct superinterface of <em>T</em>.</u><span class="assertion-id"> [jsr335-15.12.3-140-D]</span></span>
</li></ul>
<p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
In the case that a superinterface overrides a method declared in a grandparent interface, this rule prevents the child from "skipping" the override by simply adding the grandparent to its list of direct superinterfaces.  The appropriate way to access functionality of a grandparent is through the direct superinterface, and only if that interface chooses to expose the desired behavior.  (Alternately, the developer is free to define his own additional superinterface that exposes the desired behavior with a <code style="background-color:inherit;font-size:medium">super</code> method invocation.)</div></blockquote>
<div id="H15.12.4.1"></div>
<h3> <span class="mw-headline" id="15.12.4.1_Compute_Target_Reference_.28If_Necessary.29_.5BModified.5D"> 15.12.4.1 Compute Target Reference (If Necessary) [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4.1" class="external text" rel="nofollow">JLS 15.12.4.1</a></small>
</p><p><span class="norm-dynamic">
There are several cases to consider, depending on which of the five productions for <em>MethodInvocation</em> (<a href="#H15.12" title="Lambda H" class="mw-redirect">15.12</a>) is involved:<span class="assertion-id"> [jls-15.12.4.1-100]</span></span>
</p><p>...
</p>
<ul><li> <span class="norm-dynamic"> If the fourth production for <em>MethodInvocation</em>, <em><del>ClassName</del> <u>TypeName</u> <code style="background-color:inherit;font-size:medium">.</code> <code style="background-color:inherit;font-size:medium">super</code></em>, is involved, then <u>if <em>TypeName</em> denotes a class,</u> the target reference is the value of <em><del>ClassName</del> <u>TypeName</u> <code style="background-color:inherit;font-size:medium">.</code> <code style="background-color:inherit;font-size:medium">this</code></em>; <u>otherwise, the target reference is the value of <code style="background-color:inherit;font-size:medium">this</code></u>.<span class="assertion-id"> [jls-15.12.4.1-120-D]</span></span>
</li></ul>
<p>...
</p>
<div id="H15.12.4.4"></div>
<h3> <span class="mw-headline" id="15.12.4.4_Locate_Method_to_Invoke_.5BModified.5D"> 15.12.4.4 Locate Method to Invoke [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4.4" class="external text" rel="nofollow">JLS 15.12.4.4</a></small>
</p><p>...
</p><p><span class="norm-dynamic">
The dynamic method lookup uses the following procedure to search class <em>S</em>, and then the superclasses <u>and superinterfaces</u> of class <em>S</em>, as necessary, for method <em>m</em>.<span class="assertion-id"> [jls-15.12.4.4-230]</span></span>
</p><p><span class="norm-dynamic">
Let <em>X</em> be the compile-time type of the target reference of the method invocation.  Then:<span class="assertion-id"> [jls-15.12.4.4-240]</span></span>
</p>
<ul><li> <span class="norm-dynamic"> If class <em>S</em> contains a declaration for a <del>non-<code style="background-color:inherit;font-size:medium">abstract</code></del> method named <em>m</em> with the same descriptor (same number of parameters, the same parameter types, and the same return type) required by the method invocation as determined at compile time (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.3" class="external text" rel="nofollow">15.12.3</a>), then:<span class="assertion-id"> [jls-15.12.4.4-240-A]</span></span>
<ul><li> <span class="norm-dynamic"> If the invocation mode is <code style="background-color:inherit;font-size:medium">super</code> or <code style="background-color:inherit;font-size:medium">interface</code>, then this is the method to be invoked, and the procedure terminates.<span class="assertion-id"> [jls-15.12.4.4-240-A-1]</span></span>
</li><li> <span class="norm-dynamic"> If the invocation mode is <code style="background-color:inherit;font-size:medium">virtual</code>, and <u>the accessibility of <em>m</em> is such that</u> the declaration in <em>S</em> <del>overrides</del> <u>can override</u> (<a href="#H8.4.8.1" title="Lambda H" class="mw-redirect">8.4.8.1</a>) <em>X.m</em>, then the method declared in <em>S</em> is the method to be invoked, and the procedure terminates.<span class="assertion-id"> [jls-15.12.4.4-240-A-2]</span></span>
</li><li> <del><span class="norm-error"> If the invocation mode is <code style="background-color:inherit;font-size:medium">virtual</code>, and the declaration in <em>S</em> does not override <em>X.m</em>, and moreover <em>X.m</em> is declared <code style="background-color:inherit;font-size:medium">abstract</code>, then an <code style="background-color:inherit;font-size:medium">AbstractMethodError</code> is thrown.<span class="assertion-id"> [jls-15.12.4.4-240-A-3]</span></span></del>
</li></ul>
</li><li> <span class="norm-dynamic"> Otherwise, if <em>S</em> has a superclass, <del>this same</del> <u>the</u> lookup procedure <u>of steps 1 and 2</u> is performed recursively using the direct superclass of <em>S</em> in place of <em>S</em>; the method to be invoked, <u>if any,</u> is the result of the recursive invocation of this lookup procedure.<span class="assertion-id"> [jls-15.12.4.4-240-B]</span></span>
</li><li> <span class="norm-dynamic"> <u>If no method is found by the previous two steps, the superinterfaces of <em>S</em> are searched for a suitable method.  A set of candidates is considered with the following properties: i) each method is declared in a (direct or indirect) superinterface of <em>S</em>; ii) each method has the name and descriptor required by the method invocation; iii) each method is non-<code style="background-color:inherit;font-size:medium">static</code>; iv) for each method, where the method's declaring interface is <em>I</em>, there is no other method satisfying (i) through (iii) that is declared in a subinterface of <em>I</em>.  If this set contains a <code style="background-color:inherit;font-size:medium">default</code> method, one such method is the method to be invoked.  Otherwise, an <code style="background-color:inherit;font-size:medium">abstract</code> method in the set is selected as the method to be invoked.</u><span class="assertion-id"> [jsr335-15.12.4.4-240-C]</span></span>
</li></ul>
<p><span class="norm-error"> <u>After dynamic method lookup, various errors may occur:</u><span class="assertion-id"> [jsr335-15.12.4.4-242]</span></span>
</p>
<ul><li> <span class="norm-error"> <u>If the method to invoke is <code style="background-color:inherit;font-size:medium">abstract</code>, an <code style="background-color:inherit;font-size:medium">AbstractMethodError</code> is thrown.</u><span class="assertion-id"> [jsr335-15.12.4.4-242-A]</span></span>
</li><li> <span class="norm-error"> <u>If the method to invoke is <code style="background-color:inherit;font-size:medium">default</code>, and more than one <code style="background-color:inherit;font-size:medium">default</code> method appears in the set of candidates in step 3, above, an <code style="background-color:inherit;font-size:medium">IncompatibleClassChangeError</code> is thrown.</u><span class="assertion-id"> [jsr335-15.12.4.4-242-B]</span></span>
</li><li> <span class="norm-error"> <u>If the invocation mode is <code style="background-color:inherit;font-size:medium">interface</code> and the selected method is not <code style="background-color:inherit;font-size:medium">public</code>, an <code style="background-color:inherit;font-size:medium">IllegalAccessError</code> is thrown.</u><span class="assertion-id"> [jsr335-15.12.4.4-242-C]</span></span>
</li></ul>
<p>The above procedure <del>(if it terminates without error)</del> will find a non-<code style="background-color:inherit;font-size:medium">abstract</code>, accessible method to invoke, provided that all classes and interfaces in the program have been consistently compiled.  However, if this is not the case, then <del>various errors may occur.  The specification of</del> <u>additional details of</u> the behavior of a Java virtual machine <del>under these circumstances is</del> <u>are</u> given by <i>The Java Virtual Machine Specification</i>.
</p><p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p><p>The substantial change here is to explain how a default method may be selected for invocation, and it mirrors the JVM selection behavior described in <a href="#J" title="Lambda J" class="mw-redirect">Part J</a>.  Additional changes are made as bug fixes, for correctness.  Specifically:
</p>
<ul><li> It was incorrect to say that only non-<code style="background-color:inherit;font-size:medium">abstract</code> methods would be matched by the search.
</li><li> Because overriding, as defined in <a href="#H8.4.8.1" title="Lambda H" class="mw-redirect">8.4.8.1</a>, may involve generic substitution and other type analysis, it is more precise to say simply that <code style="background-color:inherit;font-size:medium">virtual</code> invocation will test for appropriate accessibility.
</li><li> When, during a <code style="background-color:inherit;font-size:medium">virtual</code> search, a matching method does not override <em>m</em>, it is not the case that an error occurs—instead, the search continues.
</li><li> Given consistently-compiled classes, the type checker has already proven that no runtime error will occur.  So there is no need for the "if it terminates without error" qualifier.</div></blockquote>
</li></ul>
<div id="H6"></div>
<h3> <span class="mw-headline" id="6_Names_.5BModified.5D"> 6 Names [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6" class="external text" rel="nofollow">JLS 6</a></small>
</p><p>...
</p><p>Access control (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6" class="external text" rel="nofollow">6.6</a>) can be specified in a class, interface, method, or field declaration to control when <i>access</i> to a member is allowed.  Access is a different concept from scope.  Access specified the part of the program text within which the declared entity can be referred to be a qualified name, a field access expression (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.11" class="external text" rel="nofollow">15.11</a>), or a method invocation expression (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" class="external text" rel="nofollow">15.12</a>) in which the method is not specified by a simple name.  <u>In the absence of an access modifier, most declarations have package access, allowing access</u> anywhere within the package that contains its declaration; other possibilities are <code style="background-color:inherit;font-size:medium">public</code>, <code style="background-color:inherit;font-size:medium">protected</code>, and <code style="background-color:inherit;font-size:medium">private</code>.
</p><p>...
</p>
<div id="H6.6.1"></div>
<h3> <span class="mw-headline" id="6.6.1_Determining_Accessibility_.5BModified.5D"> 6.6.1 Determining Accessibility [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6.1" class="external text" rel="nofollow">JLS 6.6.1</a></small>
</p>
<ul><li> <span class="norm-static"> A package is always accessible.<span class="assertion-id"> [jls-6.6.1-100-A]</span></span>
</li><li> <span class="norm-static"> If a class or interface type is declared <code style="background-color:inherit;font-size:medium">public</code>, then it may be accessed by any code, provided that the compilation unit (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-7.html#jls-7.3" class="external text" rel="nofollow">7.3</a>) in which it is declared is observable.<span class="assertion-id"> [jls-6.6.1-100-B]</span></span><p><span class="norm-static"> If a <del>top level</del> class or interface type is <del>not declared <code style="background-color:inherit;font-size:medium">public</code></del> <u>declared with package access</u>, then it may be accessed only from within the package in which it is declared.<span class="assertion-id"> [jls-6.6.1-100-B.1]</span></span></p><p><span class="norm-static"> <u>A class or interface declared without an access modifier implicitly has package access.</u><span class="assertion-id"> [jsr335-6.6.1-100-B.2]</span></span></p>
</li><li> <span class="norm-static"> An array type is accessible if and only if its element type is accessible.<span class="assertion-id"> [jls-6.6.1-100-C]</span></span>
</li><li> <span class="norm-static"> A member (class, interface, field, or method) of a reference <del>(class, interface, or array)</del> type or a constructor of a class type is accessible only if the type is accessible and the member or constructor is declared to permit access:<span class="assertion-id"> [jls-6.6.1-100-D]</span></span>
<ul><li> <span class="norm-static"> If the member or constructor is declared <code style="background-color:inherit;font-size:medium">public</code>, then access is permitted.<span class="assertion-id"> [jls-6.6.1-100-D-1]</span></span><p><span class="norm-static"> All members of interfaces <u>lacking access modifiers</u> are implicitly <code style="background-color:inherit;font-size:medium">public</code>.<span class="assertion-id"> [jls-6.6.1-100-D-1.1]</span></span></p>
</li><li> <span class="norm-static"> Otherwise, if the member or constructor is declared <code style="background-color:inherit;font-size:medium">protected</code>, then access is permitted only when one of the following is true:<span class="assertion-id"> [jls-6.6.1-100-D-2]</span></span>
<ul><li> <span class="norm-static"> Access to the member or constructor occurs from within the package containing the class in which the protected member or constructor is declared.<span class="assertion-id"> [jls-6.6.1-100-D-2-1]</span></span>
</li><li> <span class="norm-static"> Access is correct as described in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6.2" class="external text" rel="nofollow">6.6.2</a>.<span class="assertion-id"> [jls-6.6.1-100-D-2-2]</span></span>
</li></ul>
</li><li> <span class="norm-static"> Otherwise, <u>if the member or constructor is declared with package access, then access</u> is permitted only when the access occurs from within the package in which the type is declared.<span class="assertion-id"> [jls-6.6.1-100-D-4]</span></span><p><span class="norm-static"> <u>A class member or constructor declared without an access modifier implicitly has package access.</u><span class="assertion-id"> [jsr335-6.6.1-100-D-4.1]</span></span>
</li><li> <span class="norm-static"> Otherwise, <del>if</del> the member or constructor is declared <code style="background-color:inherit;font-size:medium">private</code>, <del>then</del> <u>and</u> access is permitted if and only if it occurs within the body of the top level class (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-7.html#jls-7.6" class="external text" rel="nofollow">7.6</a>) that encloses the declaration of the member or constructor.<span class="assertion-id"> [jls-6.6.1-100-D-3]</span></span>
</li></ul>
</li></ul>
<p>...
</p><p>Example 6.6-4. Access to <del>Default</del> <u>Package</u>-Access Fields, Methods, and Constructors
</p><p>If none of the access modifiers <code style="background-color:inherit;font-size:medium">public</code>, <code style="background-color:inherit;font-size:medium">protected</code>, or <code style="background-color:inherit;font-size:medium">private</code> are specified, a class member or constructor <u>has package access: it</u> is accessible throughout the package that contains the declaration of the class in which the class member is declared, but the class member or constructor is not accessible in any other package.
</p><p>If a <code style="background-color:inherit;font-size:medium">public</code> class has a method or constructor with <del>default</del> <u>package</u> access, then this method or constructor is not accessible to or inherited by a subclass declared outside this package.
</p><p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>Incidental uses of the word "default" or "none" in reference to accessibility should also be replaced with "package" in the following sections: <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.4" class="external text" rel="nofollow">4.4</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-7.html#jls-7.4.1" class="external text" rel="nofollow">7.4.1</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.8.3" class="external text" rel="nofollow">8.4.8.3</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.3.3" class="external text" rel="nofollow">12.3.3</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html#jls-13" class="external text" rel="nofollow">13</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html#jls-13.4.7" class="external text" rel="nofollow">13.4.7</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.1" class="external text" rel="nofollow">15.12.2.1</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.4.3" class="external text" rel="nofollow">15.12.4.3</a>.</div></blockquote>
<div id="H7.6"></div>
<h3> <span class="mw-headline" id="7.6_Top_Level_Type_Declarations_.5BModified.5D"> 7.6 Top Level Type Declarations [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-7.html#jls-7.6" class="external text" rel="nofollow">JLS 7.6</a></small>
</p><p>...
</p><p><del>By default</del> <u>In the absence of an access modifier</u>, the top level types declared in a package <u>have package access: they</u> are accessible only within the compilation units of that package<u>.</u> <del>but</del> A type may be declared to be <code style="background-color:inherit;font-size:medium">public</code> to grant access to the type from code in other packages (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6" class="external text" rel="nofollow">6.6</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.1" class="external text" rel="nofollow">8.1.1</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.1.1" class="external text" rel="nofollow">9.1.1</a>).
</p><p>...
</p>
<div id="H13.5.3"></div>
<h3> <span class="mw-headline" id="13.5.3_Interface_Members_.5BModified.5D"> 13.5.3 Interface Members [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html#jls-13.5.3" class="external text" rel="nofollow">JLS 13.5.3</a></small>
</p><p>Adding <u>an <code style="background-color:inherit;font-size:medium">abstract</code></u> method to an interface does not break compatibility with pre-existing binaries.
</p><p>...
</p>
<div id="H13.5.6"></div>
<h3> <span class="mw-headline" id="13.5.6_abstract_Method_Declarations_.5BModified.5D"> 13.5.6 <del><code style="background-color:inherit;font-size:medium">abstract</code></del> Method <u>Declarations</u> [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html#jls-13.5.6" class="external text" rel="nofollow">JLS 13.5.6</a></small>
</p><p>The considerations for changing <code style="background-color:inherit;font-size:medium">abstract</code> method declarations in interfaces <del>are the same as</del> <u>include</u> those for <code style="background-color:inherit;font-size:medium">abstract</code> methods in classes, as described in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html#jls-13.4.14" class="external text" rel="nofollow">13.4.14</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html#jls-13.4.15" class="external text" rel="nofollow">13.4.15</a>, <u><a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html#jls-13.4.19" class="external text" rel="nofollow">13.4.19</a></u>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html#jls-13.4.21" class="external text" rel="nofollow">13.4.21</a>, and <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html#jls-13.4.23" class="external text" rel="nofollow">13.4.23</a>.
</p><p><u>Adding a <code style="background-color:inherit;font-size:medium">default</code> method, or changing a method from <code style="background-color:inherit;font-size:medium">abstract</code> to <code style="background-color:inherit;font-size:medium">default</code>, does not break linkage compatibility with pre-existing binaries, but may cause an <code style="background-color:inherit;font-size:medium">IncompatibleClassChangeError</code> if a pre-existing binary attempts to invoke the method.  This error occurs if the qualifying type, <em>T</em>, is a subtype of two interfaces, <em>I</em> and <em>J</em>, where both <em>I</em> and <em>J</em> declare a <code style="background-color:inherit;font-size:medium">default</code> method with the same signature and result type, and neither <em>I</em> nor <em>J</em> is a subinterface of the other.</u>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div>
<p>Strictly speaking, adding a default method is a binary-compatible change, even if it introduces errors at compile time or invocation time, because it does not introduce errors at link time.
</p><p>Practically speaking, the risk of accidental clashes occurring by introducing a default method are similar to those associated with adding a new method to a non-<code style="background-color:inherit;font-size:medium">final</code> class.  (In the event of a clash, adding a method to a class is unlikely to trigger a <code style="background-color:inherit;font-size:medium">LinkageError</code>, but an accidental override of the method in a child can lead to unpredictable method behavior.  Both changes can cause errors at compile time.)
</p>
</div></li>
<li style="margin-bottom:12px;"><div>
<p>The following illustrates how adding a default method can result in an invocation-time error.
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
interface Painter {
  default void draw() {
    System.out.println(&quot;Here's a picture...&quot;);
  }
}

interface Cowboy {
}

class CowboyArtist implements Cowboy, Painter {
  public static void main(String... args) {
    new CowboyArtist().draw();
  }
}
</pre>
<p>Running <code style="background-color:inherit;font-size:medium">CowboyArtist</code> will print <code style="background-color:inherit;font-size:medium">Here's a picture...</code>.
</p><p>Now consider a scenario in which a default method is added to <code style="background-color:inherit;font-size:medium">Cowboy</code> without recompiling <code style="background-color:inherit;font-size:medium">CowboyArtist</code>.
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
interface Cowboy {
  default void draw() {
    System.out.println(&quot;Bang!&quot;);
  }
}
</pre>
<p>The class <code style="background-color:inherit;font-size:medium">CowboyArtist</code> will link without error, but running the <code style="background-color:inherit;font-size:medium">main</code> method will result in an <code style="background-color:inherit;font-size:medium">IncompatibleClassChangeError</code>.
</p>
</div></li></ol></div></blockquote></p>



<a id="top"></a>
	
	<a id="J"/><h1 id="firstHeading" class="firstHeading">Lambda Specification, Part J: Java Virtual Machine</h1>
									<p><small>
Navigation: <a href="#overview" title="Lambda Specification" class="mw-redirect">Overview</a>&nbsp;- <a href="#A" title="Lambda A" class="mw-redirect">Part A</a>&nbsp;- <a href="#B" title="Lambda B" class="mw-redirect">Part B</a>&nbsp;- <a href="#C" title="Lambda C" class="mw-redirect">Part C</a>&nbsp;- <a href="#D" title="Lambda D" class="mw-redirect">Part D</a>&nbsp;- <a href="#E" title="Lambda E" class="mw-redirect">Part E</a>&nbsp;- <a href="#F" title="Lambda F" class="mw-redirect">Part F</a>&nbsp;- <a href="#G" title="Lambda G" class="mw-redirect">Part G</a>&nbsp;- <a href="#H" title="Lambda H" class="mw-redirect">Part H</a>&nbsp;- <a href="#J" title="Lambda J" class="mw-redirect">Part J</a>
<br />
Sections: <a href="#JJVMS-4.6">JVMS-4.6</a>&nbsp;- <a href="#JJVMS-4.9.1">JVMS-4.9.1</a>&nbsp;- <a href="#JJVMS-4.9.2">JVMS-4.9.2</a>&nbsp;- <a href="#JJVMS-4.4.8">JVMS-4.4.8</a>&nbsp;- <a href="#JJVMS-5.4.3.3">JVMS-5.4.3.3</a>&nbsp;- <a href="#JJVMS-5.4.3.4">JVMS-5.4.3.4</a>&nbsp;- <a href="#JJVMS-5.4.5">JVMS-5.4.5</a>&nbsp;- <a href="#JJVMS-6.5.invokeinterface">JVMS-6.5.invokeinterface</a>&nbsp;- <a href="#JJVMS-6.5.invokespecial">JVMS-6.5.invokespecial</a>&nbsp;- <a href="#JJVMS-6.5.invokestatic">JVMS-6.5.invokestatic</a>&nbsp;- <a href="#JJVMS-6.5.invokevirtual">JVMS-6.5.invokevirtual</a>
<br />
Version 0.9.3.  Copyright © 2014 Oracle America, Inc.  <a href="#Legal_Notice" title="Lambda Specification" class="mw-redirect">Legal Notice</a>.
</small>
</p>
<h3> <span class="mw-headline" id="Summary"> Summary </span></h3>
<p>Changes to the Java Virtual Machine are necessary to support the implementation of default methods.  Methods declared in interface class files need not be declared <code style="background-color:inherit;font-size:medium">abstract</code>, and thus can carry a <code style="background-color:inherit;font-size:medium">Code</code> attribute.  Methods declared in interface class files may also be <code style="background-color:inherit;font-size:medium">private</code> or <code style="background-color:inherit;font-size:medium">static</code>.  The <code style="background-color:inherit;font-size:medium">invokespecial</code> and <code style="background-color:inherit;font-size:medium">invokestatic</code> instructions may refer to interface methods.  The rules for method resolution and invocation (via <code style="background-color:inherit;font-size:medium">invokeinterface</code>, <code style="background-color:inherit;font-size:medium">invokespecial</code>, <code style="background-color:inherit;font-size:medium">invokestatic</code>, and <code style="background-color:inherit;font-size:medium">invokevirtual</code>) are enhanced to support execution of code in interfaces.
</p>
<div id="JJVMS-4.6"></div>
<h3> <span class="mw-headline" id="JVMS_4.6_Methods_.5BModified.5D"> JVMS 4.6 Methods [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6" class="external text" rel="nofollow">JVMS 4.6</a></small>
</p><p>...
</p><p><span class="norm-static">
Methods of classes may set any of the flags in Table 4.5.  However, a specific method of a class may have at most one of its <code style="background-color:inherit;font-size:medium">ACC_PRIVATE</code>, <code style="background-color:inherit;font-size:medium">ACC_PROTECTED</code>, and <code style="background-color:inherit;font-size:medium">ACC_PUBLIC</code> flags set (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.3" class="external text" rel="nofollow">8.4.3</a>).<span class="assertion-id"> [jvms-4.6-200-A.5]</span></span>
</p><p><span class="norm-static">
<u>Methods of interfaces may set any of the flags in Table 4.5 except <code style="background-color:inherit;font-size:medium">ACC_PROTECTED</code>, <code style="background-color:inherit;font-size:medium">ACC_FINAL</code>, <code style="background-color:inherit;font-size:medium">ACC_NATIVE</code>, and <code style="background-color:inherit;font-size:medium">ACC_SYNCHRONIZED</code> (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.4" class="external text" rel="nofollow">9.4</a>); they must have exactly one of the <code style="background-color:inherit;font-size:medium">ACC_PUBLIC</code> or <code style="background-color:inherit;font-size:medium">ACC_PRIVATE</code> flags set.</u><span class="assertion-id"> [jsr335-4.6-200-A.10]</span></span>
</p><p><span class="norm-static">
<u>An interface method in a class file whose version number is not 52.0 or above</u> must have <u>its</u> <code style="background-color:inherit;font-size:medium">ACC_ABSTRACT</code> and <code style="background-color:inherit;font-size:medium">ACC_PUBLIC</code> flags set <del>they may have their <code style="background-color:inherit;font-size:medium">ACC_VARARGS</code>, <code style="background-color:inherit;font-size:medium">ACC_BRIDGE</code>, and <code style="background-color:inherit;font-size:medium">ACC_SYNTHETIC</code> flags set and must not have any of the other flags in Table 4.5 set (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.4" class="external text" rel="nofollow">9.4</a>)</del>.<span class="assertion-id"> [jvms-4.6-200-A.6]</span></span>
</p><p><span class="norm-static">
If a specific method <u>of a class or interface</u> has its <code style="background-color:inherit;font-size:medium">ACC_ABSTRACT</code> flag set, it must not have any of its <code style="background-color:inherit;font-size:medium">ACC_FINAL</code>, <code style="background-color:inherit;font-size:medium">ACC_NATIVE</code>, <code style="background-color:inherit;font-size:medium">ACC_PRIVATE</code>, <code style="background-color:inherit;font-size:medium">ACC_STATIC</code>, <code style="background-color:inherit;font-size:medium">ACC_STRICT</code>, or <code style="background-color:inherit;font-size:medium">ACC_SYNCHRONIZED</code> flags set (<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.3.1" class="external text" rel="nofollow">8.4.3.1</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.3.3" class="external text" rel="nofollow">8.4.3.3</a>, <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.3.4" class="external text" rel="nofollow">8.4.3.4</a>).<span class="assertion-id"> [jsr335-4.6-200-A.11]</span></span>
</p><p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
Interface methods prior to version 52.0 must be <code style="background-color:inherit;font-size:medium">abstract</code>, and thus must not be <code style="background-color:inherit;font-size:medium">private</code>, <code style="background-color:inherit;font-size:medium">static</code>, or <code style="background-color:inherit;font-size:medium">strictfp</code>; they are also prohibited from having <code style="background-color:inherit;font-size:medium">Code</code> attributes (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.3" class="external text" rel="nofollow">4.7.3</a>).  In version 52.0, an interface method may be non-abstract and thus is free to use these flags and have a <code style="background-color:inherit;font-size:medium">Code</code> attribute.</div></blockquote>
<div id="JJVMS-4.9.1"></div>
<h3> <span class="mw-headline" id="JVMS_4.9.1_Static_Constraints_.5BModified.5D"> JVMS 4.9.1 Static Constraints [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.9.1" class="external text" rel="nofollow">JVMS 4.9.1</a></small>
</p><p>...
</p><p><span class="norm-static">
The static constraints on the operands of instructions in the <code style="background-color:inherit;font-size:medium">code</code> array are as follows:<span class="assertion-id"> [jvms-4.9.1-120]</span></span>
</p><p>...
</p>
<ul><li> <span class="norm-static"> The indexbyte operands of each <code style="background-color:inherit;font-size:medium">invokevirtual</code> <del><code style="background-color:inherit;font-size:medium">invokespecial</code>, and <code style="background-color:inherit;font-size:medium">invokestatic</code></del> instruction must represent a valid index into the <code style="background-color:inherit;font-size:medium">constant_pool</code> table.  The constant pool entry referenced by that index must be of type <code style="background-color:inherit;font-size:medium">CONSTANT_Methodref</code>.<span class="assertion-id"> [jvms-4.9.1-120-G]</span></span>
</li><li> <span class="norm-static"> <u>The indexbyte operands of each <code style="background-color:inherit;font-size:medium">invokespecial</code> and <code style="background-color:inherit;font-size:medium">invokestatic</code> instruction must represent a valid index into the <code style="background-color:inherit;font-size:medium">constant_pool</code> table.  The constant pool entry referenced by that index must be either of type <code style="background-color:inherit;font-size:medium">CONSTANT_Methodref</code> or, if the constant pool appears in a class file whose version number is 52.0 or above, of type <code style="background-color:inherit;font-size:medium">CONSTANT_InterfaceMethodref</code>.</u><span class="assertion-id"> [jsr335-4.9.1-120-T]</span></span>
</li></ul>
<p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
In order to invoke <code style="background-color:inherit;font-size:medium">static</code> and <code style="background-color:inherit;font-size:medium">private</code> methods in interfaces, <code style="background-color:inherit;font-size:medium">InterfaceMethodrefs</code> must be supported by the <code style="background-color:inherit;font-size:medium">invokestatic</code> and <code style="background-color:inherit;font-size:medium">invokespecial</code> instructions.  In addition, this change allows non-<code style="background-color:inherit;font-size:medium">static</code>, non-<code style="background-color:inherit;font-size:medium">abstract</code> methods appearing in a direct superinterface to be invoked via <code style="background-color:inherit;font-size:medium">invokespecial</code>.</div></blockquote>
<div id="JJVMS-4.9.2"></div>
<h3> <span class="mw-headline" id="JVMS_4.9.2_Structural_Constraints_.5BModified.5D"> JVMS 4.9.2 Structural Constraints [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.9.2" class="external text" rel="nofollow">JVMS 4.9.2</a></small>
</p><p><span class="norm-static">
The structural constraints on the <code style="background-color:inherit;font-size:medium">code</code> array specify constraints on relationships between Java virtual machine instructions.  The structural constraints are as follows:<span class="assertion-id"> [jvms-4.9.2-100]</span></span>
</p><p>...
</p>
<ul><li> <span class="norm-static"> Each <code style="background-color:inherit;font-size:medium">invokespecial</code> instruction must name an instance initialization method (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.9" class="external text" rel="nofollow">2.9</a>), <u>or must reference</u> a method in the current class <u>or interface</u>, <del>or</del> a method in a superclass of the current class <u>or interface</u>, <u>or a method in a direct superinterface of the current class or interface</u>.<span class="assertion-id"> [jvms-4.9.2-120-G]</span></span><p><span class="norm-static"> If an <code style="background-color:inherit;font-size:medium">invokespecial</code> instruction names an instance initialization method <del>from</del> <u>referenced in</u> a class that is not the current class or a superclass, and the target reference on the operand stack is a class instance created by an earlier <code style="background-color:inherit;font-size:medium">new</code> instruction, then <code style="background-color:inherit;font-size:medium">invokespecial</code> must name an instance initialization method <del>from</del> <u>referenced in</u> the class of that class instance.<span class="assertion-id"> [jvms-4.9.2-120-G.2]</span></span></p>
</li></ul>
<p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> A clause is added to support <code style="background-color:inherit;font-size:medium">invokespecial</code> of default methods in a superinterface.  References to a superinterface method must point to a <i>direct</i> superinterface; this is in contrast to references to a superclass method, which can point to any superclass.  This is because i) the search path for a closer match of an interface method (as required by the <code style="background-color:inherit;font-size:medium">ACC_SUPER</code> flag) is not clear if the reference is not to a direct superinterface, and ii) there is no practical need for more flexibility (note that a reference can <i>resolve</i> to a method in an ancestor interface, even if the interface is not named directly).  In retrospect, the ideal probably would have been to make a similar restriction on invocations of superclass methods.
</div></li>
<li style="margin-bottom:12px;"><div> The introduction of phrases like "referenced in" is a clarification of existing behavior: the check is against the class appearing in the <code style="background-color:inherit;font-size:medium">Methodref</code> or <code style="background-color:inherit;font-size:medium">InterfaceMethodref</code>, <i>not</i> the declaring class of the resolved method.
</div></li></ol></div></blockquote>
<div id="JJVMS-4.4.8"></div>
<h3> <span class="mw-headline" id="JVMS_4.4.8_The_CONSTANT_MethodHandle_info_Structure_.5BModified.5D"> JVMS 4.4.8 The <code style="background-color:inherit;font-size:medium">CONSTANT_MethodHandle_info</code> Structure [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.8" class="external text" rel="nofollow">JVMS 4.4.8</a></small>
</p><p>...
</p><p><span class="norm-static">
If the value of the <code style="background-color:inherit;font-size:medium">reference_kind</code> item is 5 (<code style="background-color:inherit;font-size:medium">REF_invokeVirtual</code>) <del>6 (<code style="background-color:inherit;font-size:medium">REF_invokeStatic</code>), 7 (<code style="background-color:inherit;font-size:medium">REF_invokeSpecial</code>),</del> or 8 (<code style="background-color:inherit;font-size:medium">REF_newInvokeSpecial</code>), then the <code style="background-color:inherit;font-size:medium">constant_pool</code> entry at that index must be a <code style="background-color:inherit;font-size:medium">CONSTANT_Methodref_info</code> (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.2" class="external text" rel="nofollow">4.4.2</a>) structure representing a class's method or constructor (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.9" class="external text" rel="nofollow">2.9</a>) for which a method handle is to be created.<span class="assertion-id"> [jvms-4.4.8-200-C.2]</span></span>
</p><p><span class="norm-static">
<u>If the value of the <code style="background-color:inherit;font-size:medium">reference_kind</code> item is 6 (<code style="background-color:inherit;font-size:medium">REF_invokeStatic</code>) or 7 (<code style="background-color:inherit;font-size:medium">REF_invokeSpecial</code>), then the <code style="background-color:inherit;font-size:medium">constant_pool</code> entry at that index must be either a <code style="background-color:inherit;font-size:medium">CONSTANT_Methodref_info</code> structure or, if the constant pool appears in a class file whose version number is 52.0 or above, a <code style="background-color:inherit;font-size:medium">CONSTANT_InterfaceMethodref</code> (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.2" class="external text" rel="nofollow">4.4.2</a>) structure representing a class's or interface's method for which a method handle is to be created.</u><span class="assertion-id"> [jsr335-4.4.8-200-C.6]</span></span>
</p><p><span class="norm-static">
If the value of the <code style="background-color:inherit;font-size:medium">reference_kind</code> item is 9 (<code style="background-color:inherit;font-size:medium">REF_invokeInterface</code>), then the <code style="background-color:inherit;font-size:medium">constant_pool</code> entry at that index must be a <code style="background-color:inherit;font-size:medium">CONSTANT_InterfaceMethodref_info</code> <del>(<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.2" class="external text" rel="nofollow">4.4.2</a>)</del> structure representing an interface's method for which a method handle is to be created.<span class="assertion-id"> [jsr335-4.4.8-200-C.3]</span></span>
</p><p>...
</p>
<div id="JJVMS-5.4.3.3"></div>
<h3> <span class="mw-headline" id="JVMS_5.4.3.3_Method_Resolution_.5BModified.5D"> JVMS 5.4.3.3 Method Resolution [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.3.3" class="external text" rel="nofollow">JVMS 5.4.3.3</a></small>
</p><p><span class="norm-dynamic">
To resolve an unresolved symbolic reference from <em>D</em> to a method in a class <em>C</em>, the symbolic reference to <em>C</em> given by the method reference is first resolved (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.3.1" class="external text" rel="nofollow">5.4.3.1</a>).  Therefore, any exception that can be thrown as a result of failure of resolution of a class reference can be thrown as a result of method resolution.  If the reference to <em>C</em> can be successfully resolved, exceptions relating to the resolution of the method reference itself can be thrown.<span class="assertion-id"> [jvms-5.4.3.3-100]</span></span>
</p><p><span class="norm-dynamic">
When resolving a method reference:<span class="assertion-id"> [jvms-5.4.3.3-200]</span></span>
</p>
<ul><li> <span class="norm-dynamic"> Method resolution checks whether <em>C</em> is a class or an interface.<span class="assertion-id"> [jvms-5.4.3.3-200-A]</span></span>
<ul><li> <span class="norm-dynamic"> If <em>C</em> is an interface, method resolution throws an <code style="background-color:inherit;font-size:medium">IncompatibleClassChangeError</code>.<span class="assertion-id"> [jvms-5.4.3.3-200-A-1]</span></span>
</li></ul>
</li><li> <span class="norm-dynamic"> Method resolution attempts to look up the referenced method in <em>C</em> and its superclasses: ...<span class="assertion-id"> [jvms-5.4.3.3-200-B]</span></span>
</li><li> <span class="norm-dynamic"> Otherwise, method resolution attempts to locate the referenced method in <del>any of</del> the superinterfaces of the specified class <em>C</em>:<span class="assertion-id"> [jvms-5.4.3.3-200-C]</span></span>
<ul><li> <span class="norm-dynamic"> <u>If the <i>maximally-specific superinterface methods</i> (defined below) of <em>C</em> for the name and descriptor specified by the method reference include exactly one method that does not have set its <code style="background-color:inherit;font-size:medium">ACC_ABSTRACT</code> flag, then this method is chosen and method lookup succeeds.</u><span class="assertion-id"> [jsr335-5.4.3.3-200-C-3]</span></span>
</li><li> <span class="norm-dynamic"> <u>Otherwise</u>, if any superinterface of <em>C</em> declares a method with the name and descriptor specified by the method reference <u>that has set neither its <code style="background-color:inherit;font-size:medium">ACC_PRIVATE</code> flag nor its <code style="background-color:inherit;font-size:medium">ACC_STATIC</code> flag, one of these is arbitrarily chosen and</u> method lookup succeeds.<span class="assertion-id"> [jvms-5.4.3.3-200-C-1]</span></span>
</li><li> <span class="norm-dynamic"> Otherwise, method lookup fails.<span class="assertion-id"> [jvms-5.4.3.3-200-C-2]</span></span>
</li></ul>
</li></ul>
<p><span class="norm-static">
<u>A <i>maximally-specific superinterface method</i> of a class or interface <em>C</em> for a particular method name and descriptor is any method for which the following conditions hold:</u><span class="assertion-id"> [jsr335-5.4.3.3-25]</span></span>
</p>
<ul><li> <span class="norm-static"> <u>The method is declared in a superinterface (direct or indirect) of <em>C</em>.</u><span class="assertion-id"> [jsr335-5.4.3.3-25-A]</span></span>
</li><li> <span class="norm-static"> <u>The method is declared with the specified name and descriptor.</u><span class="assertion-id"> [jsr335-5.4.3.3-25-B]</span></span>
</li><li> <span class="norm-static"> <u>The method has set neither its <code style="background-color:inherit;font-size:medium">ACC_PRIVATE</code> flag nor its <code style="background-color:inherit;font-size:medium">ACC_STATIC</code> flag.</u><span class="assertion-id"> [jsr335-5.4.3.3-25-C]</span></span>
</li><li> <span class="norm-static"> <u>Where the method is declared in interface <em>I</em>, there exists no other maximally-specific superinterface method of <em>C</em> for the given name and descriptor that is declared in a subinterface of <em>I</em>.</u><span class="assertion-id"> [jsr335-5.4.3.3-25-D]</span></span>
</li></ul>
<p><span class="norm-dynamic"> If method lookup fails, method resolution throws a <code style="background-color:inherit;font-size:medium">NoSuchMethodError</code>.<span class="assertion-id"> [jvms-5.4.3.3-210-A]</span></span>
</p><p><span class="norm-dynamic"> <del>If method lookup succeeds and the method is <code style="background-color:inherit;font-size:medium">abstract</code>, but <em>C</em> is not <code style="background-color:inherit;font-size:medium">abstract</code>, method resolution throws an <code style="background-color:inherit;font-size:medium">AbstractMethodError</code>.</del><span class="assertion-id"> [jvms-5.4.3.3-210-B]</span></span>
</p><p><span class="norm-dynamic"> <del>Otherwise, if</del> <u>If method lookup succeeds and</u> the referenced method is not accessible (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.4" class="external text" rel="nofollow">5.4.4</a>) to <em>D</em>, method resolution throws an <code style="background-color:inherit;font-size:medium">IllegalAccessError</code>.<span class="assertion-id"> [jvms-5.4.3.3-210-C]</span></span>
</p><p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> When resolution searches for a method in the class's superinterfaces, we prefer to identify a maximally-specific non-abstract method.  This is because it is possible that this is the method that will be <i>selected</i> and invoked by an <code style="background-color:inherit;font-size:medium">invoke</code> instruction, and so we want to ensure that class loader constraints are performed for this method.
<p>Otherwise, the result is nondeterministic.  This is not new: the specification has never identified exactly which method is chosen, and how "ties" should be broken.  In the past, this was mostly an unobservable distinction.  However, now that the set of interface methods is more heterogenous, care must be taken to avoid more serious problems with nondeterministic behavior.
</p><p>Thus:
</p>
<ul><li> Superinterface methods that are <code style="background-color:inherit;font-size:medium">private</code> and <code style="background-color:inherit;font-size:medium">static</code> are ignored by resolution.  This is consistent with the Java language view of these declarations, which says that they are not inherited.  They can still be referenced, of course, by directly naming the interface in which they are declared, via an <code style="background-color:inherit;font-size:medium">InterfaceMethodref</code>.  (In retrospect, it might be more consistent with the Java language to give the same treatment to private methods in classes...)
</li><li> Any behavior controlled by the resolved method should not depend on whether the method is <code style="background-color:inherit;font-size:medium">abstract</code> or not.
</li></ul>
</div></li>
<li style="margin-bottom:12px;"><div> The check that the resolved method is not <code style="background-color:inherit;font-size:medium">abstract</code> unless the named class is also <code style="background-color:inherit;font-size:medium">abstract</code> has been removed.  This is a rather ad hoc check, and conflicts with the nondeterministic choice of interface methods, as explained above.  The effect of removing the check is to allow <code style="background-color:inherit;font-size:medium">abstract</code> methods in non-<code style="background-color:inherit;font-size:medium">abstract</code> classes to be invoked, assuming that the object for the invocation has a concrete implementation of the method.
<p>This change is retroactive for all class versions.
</p>
</div></li></ol></div></blockquote>
<div id="JJVMS-5.4.3.4"></div>
<h3> <span class="mw-headline" id="JVMS_5.4.3.4_Interface_Method_Resolution_.5BModified.5D"> JVMS 5.4.3.4 Interface Method Resolution [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.3.4" class="external text" rel="nofollow">JVMS 5.4.3.4</a></small>
</p><p><span class="norm-dynamic">
To resolve an unresolved symbolic reference from <em>D</em> to an interface method in an interface <em>C</em>, the symbolic reference to <em>C</em> given by the interface method reference is first resolved (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.3.1" class="external text" rel="nofollow">5.4.3.1</a>).  Therefore, any exception that can be thrown as a result of failure of resolution of an interface reference can be thrown as a result of interface method resolution.  If the reference to <em>C</em> can be successfully resolved, exceptions relating to the resolution of the method reference itself can be thrown.<span class="assertion-id"> [jvms-5.4.3.4-100]</span></span>
</p><p><span class="norm-dynamic">
When resolving an interface method reference:<span class="assertion-id"> [jvms-5.4.3.4-200]</span></span>
</p>
<ul><li> <span class="norm-dynamic">If <em>C</em> is not an interface, interface method resolution throws an <code style="background-color:inherit;font-size:medium">IncompatibleClassChangeError</code>.<span class="assertion-id"> [jvms-5.4.3.4-200-A]</span></span>
</li><li> <span class="norm-dynamic"> <u>Otherwise, if <em>C</em> declares a method with the name and descriptor specified by the interface method reference, method lookup succeeds.</u><span class="assertion-id"> [jsr335-5.4.3.4-200-D]</span></span>
</li><li> <span class="norm-dynamic"> <u>Otherwise, if the class <code style="background-color:inherit;font-size:medium">Object</code> declares a method with the name and descriptor specified by the interface method reference that has set its <code style="background-color:inherit;font-size:medium">ACC_PUBLIC</code> flag and does <i>not</i> have set its <code style="background-color:inherit;font-size:medium">ACC_STATIC</code> flag, method lookup succeeds.</u><span class="assertion-id"> [jsr335-5.4.3.4-200-E]</span></span>
</li><li> <span class="norm-dynamic"> <u>Otherwise, if the <i>maximally-specific superinterface methods</i> (<a href="#JJVMS-5.4.3.3" title="Lambda J" class="mw-redirect">JVMS-5.4.3.3</a>) of <em>C</em> for the name and descriptor specified by the method reference include exactly one method that does not have set its <code style="background-color:inherit;font-size:medium">ACC_ABSTRACT</code> flag, then this method is chosen and method lookup succeeds.</u><span class="assertion-id"> [jsr335-5.4.3.4-200-F]</span></span>
</li><li> <span class="norm-dynamic"> <u>Otherwise, if any superinterface of <em>C</em> declares a method with the name and descriptor specified by the method reference that has set neither its <code style="background-color:inherit;font-size:medium">ACC_PRIVATE</code> flag nor its <code style="background-color:inherit;font-size:medium">ACC_STATIC</code> flag, one of these is arbitrarily chosen and method lookup succeeds.</u><span class="assertion-id"> [jsr335-5.4.3.4-200-G]</span></span>
</li><li> <span class="norm-dynamic"> <u>Otherwise,</u> interface method resolution throws a <code style="background-color:inherit;font-size:medium">NoSuchMethodError</code>.<span class="assertion-id"> [jsr335-5.4.3.4-200-H]</span></span>
</li></ul>
<p><span class="norm-dynamic"> <u>If method lookup succeeds and the referenced method is not accessible (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.4" class="external text" rel="nofollow">5.4.4</a>) to <em>D</em>, method resolution throws an <code style="background-color:inherit;font-size:medium">IllegalAccessError</code>.</u><span class="assertion-id"> [jsr335-5.4.3.4-210]</span></span>
</p><p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> The clause about access is added because resolution may pick a <code style="background-color:inherit;font-size:medium">private</code> method of interface <em>C</em>.
</div></li>
<li style="margin-bottom:12px;"><div> An oversight in previous iterations of the JVM Specification allowed non-public and static methods of the class <code style="background-color:inherit;font-size:medium">Object</code> to be the result of interface method resolution.  Such results were not consistent with the Java language's inheritance model (see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.2" class="external text" rel="nofollow">9.2</a>), nor were they properly handled downstream (such as in the specification for <code style="background-color:inherit;font-size:medium">invokeinterface</code>).  This is corrected by disallowing resolution to such methods.
</div></li></ol></div></blockquote>
<div id="JJVMS-5.4.5"></div>
<h3> <span class="mw-headline" id="JVMS_5.4.5_Method_Overriding_.5BModified.5D"> JVMS 5.4.5 Method Overriding [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.5" class="external text" rel="nofollow">JVMS 5.4.5</a></small>
</p><p><span class="norm-static">
An instance method <em>m<sub>1</sub></em> declared in a class <em>C</em> overrides another instance method <em>m<sub>2</sub></em> declared in a class <em>A</em> iff <u>either <em>m<sub>1</sub></em> is the same as <em>m<sub>2</sub></em>, or</u> all of the following are true:<span class="assertion-id"> [jvms-5.4.5-100]</span></span>
</p>
<ul><li> <span class="norm-static"> <em>C</em> is a subclass of <em>A</em>.<span class="assertion-id"> [jvms-5.4.5-100-A]</span></span>
</li><li> <span class="norm-static"> <em>m<sub>2</sub></em> has the same name and descriptor as <em>m<sub>1</sub></em>.<span class="assertion-id"> [jvms-5.4.5-100-B]</span></span>
</li><li> <span class="norm-static"> <u><em>m<sub>1</sub></em> is not marked <code style="background-color:inherit;font-size:medium">ACC_PRIVATE</code>.</u><span class="assertion-id"> [jsr335-5.4.5-100-D]</span></span>
</li><li> <span class="norm-static"> Either:<span class="assertion-id"> [jvms-5.4.5-100-C]</span></span>
<ul><li> <span class="norm-static"> <em>m<sub>2</sub></em> is marked <code style="background-color:inherit;font-size:medium">ACC_PUBLIC</code>; or is marked <code style="background-color:inherit;font-size:medium">ACC_PROTECTED</code>; or is marked neither <code style="background-color:inherit;font-size:medium">ACC_PUBLIC</code> nor <code style="background-color:inherit;font-size:medium">ACC_PROTECTED</code> nor <code style="background-color:inherit;font-size:medium">ACC_PRIVATE</code> and belongs to the same run-time package as <em>C</em>, or<span class="assertion-id"> [jvms-5.4.5-100-C-A]</span></span>
</li><li> <span class="norm-static"> <em>m<sub>1</sub></em> overrides a method <em>m<sub>3</sub></em>, <em>m<sub>3</sub></em> distinct from <em>m<sub>1</sub></em>, <em>m<sub>3</sub></em> distinct from <em>m<sub>2</sub></em>, such that <em>m<sub>3</sub></em> overrides <em>m<sub>2</sub></em>.<span class="assertion-id"> [jvms-5.4.5-100-C-B]</span></span>
</li></ul>
</li></ul>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
This is a bug fix to make the specification consistent with longstanding VM behavior, which is to skip over private methods during selection.  (It also clarifies that private methods can be considered to "override" themselves.)</div></blockquote>
<div id="JJVMS-6.5.invokeinterface"></div>
<h3> <span class="mw-headline" id="JVMS_6.5_invokeinterface_.5BModified.5D"> JVMS 6.5 invokeinterface [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.invokeinterface" class="external text" rel="nofollow">JVMS 6.5.invokeinterface</a></small>
</p><p>...
</p><p><span class="norm-dynamic"> Let <em>C</em> be the class of <em>objectref</em>.  The actual method to be invoked is selected by the following lookup procedure:<span class="assertion-id"> [jvms-6.5.invokeinterface.desc-200]</span></span>
</p>
<ul><li> <span class="norm-dynamic"> If <em>C</em> contains a declaration for an instance method with the same name and descriptor as the resolved method, then this is the method to be invoked <del>and the lookup procedure terminates</del>.<span class="assertion-id"> [jvms-6.5.invokeinterface.desc-200-A]</span></span>
</li><li> <span class="norm-dynamic"> Otherwise, if <em>C</em> has a superclass, <u>a search for a declaration of an instance method with the same name and descriptor as the resolved method is performed, starting with the direct superclass of <em>C</em> and continuing with the direct superclass of that class, and so forth, until a match is found or no further superclasses exist.  If a match is found, it is the method to be invoked.</u><span class="assertion-id"> [jvms-6.5.invokeinterface.desc-200-B]</span></span>
</li><li> <span class="norm-dynamic"> <u>Otherwise, the superinterfaces of <em>C</em> are searched for all maximally-specific methods (<a href="#JJVMS-5.4.3.3" title="Lambda J" class="mw-redirect">JVMS-5.4.3.3</a>) that match the resolved method's name and descriptor:</u><span class="assertion-id"> [jsr335-6.5.invokeinterface.desc-200-D]</span></span>
<ul><li> <span class="norm-dynamic"> <u>If exactly one of the maximally-specific matching methods is not <code style="background-color:inherit;font-size:medium">abstract</code>, this is the method to be invoked.</u><span class="assertion-id"> [jsr335-6.5.invokeinterface.desc-200-D3]</span></span>
</li><li> <span class="norm-dynamic"> <u>Otherwise, if more than one of the maximally-specific matching methods is not <code style="background-color:inherit;font-size:medium">abstract</code>, an <code style="background-color:inherit;font-size:medium">IncompatibleClassChangeError</code> is raised.</u><span class="assertion-id"> [jsr335-6.5.invokeinterface.desc-200-D4]</span></span>
</li><li> <span class="norm-dynamic"> Otherwise, an <code style="background-color:inherit;font-size:medium">AbstractMethodError</code> is raised.<span class="assertion-id"> [jvms-6.5.invokeinterface.desc-200-C]</span></span>
</li></ul>
</li></ul>
<p>...
</p><p><span class="norm-dynamic">
During resolution of the symbolic reference to the interface method, any of the exceptions pertaining to interface method resolution (<a href="#JJVMS-5.4.3.4" title="Lambda J" class="mw-redirect">JVMS-5.4.3.4</a>) can be thrown.<span class="assertion-id"> [jvms-6.5.invokeinterface.linking-100]</span></span>
</p><p><span class="norm-dynamic">
<u>Otherwise, if the resolved method is a <code style="background-color:inherit;font-size:medium">static</code> method, the <code style="background-color:inherit;font-size:medium">invokeinterface</code> instruction throws an <code style="background-color:inherit;font-size:medium">IncompatibleClassChangeError</code>.</u><span class="assertion-id"> [jsr335-6.5.invokeinterface.linking-20]</span></span>
</p><p><span class="norm-dynamic">
<u>Otherwise, if the resolved method is a <code style="background-color:inherit;font-size:medium">private</code> method, the <code style="background-color:inherit;font-size:medium">invokeinterface</code> instruction throws an <code style="background-color:inherit;font-size:medium">IncompatibleClassChangeError</code>.</u><span class="assertion-id"> [jsr335-6.5.invokeinterface.linking-22]</span></span>
</p><p><span class="norm-dynamic">
Otherwise, if <em>objectref</em> is <code style="background-color:inherit;font-size:medium">null</code>, the <code style="background-color:inherit;font-size:medium">invokeinterface</code> instruction throws a <code style="background-color:inherit;font-size:medium">NullPointerException</code>.<span class="assertion-id"> [jsr335-6.5.invokeinterface.runtime-100]</span></span>
</p><p><span class="norm-dynamic">
Otherwise, if the class of <em>objectref</em> does not implement the resolved interface, <em>invokeinterface</em> throws an <code style="background-color:inherit;font-size:medium">IncompatibleClassChangeError</code>.<span class="assertion-id"> [jsr335-6.5.invokeinterface.runtime-110]</span></span>
</p><p><del><span class="norm-dynamic"> Otherwise, if no method matching the resolved name and descriptor is selected, <code style="background-color:inherit;font-size:medium">invokeinterface</code> throws an <code style="background-color:inherit;font-size:medium">AbstractMethodError</code>.<span class="assertion-id"> [jsr335-6.5.invokeinterface.runtime-120]</span></span></del>
</p><p><span class="norm-dynamic">
Otherwise, if the selected method is not <code style="background-color:inherit;font-size:medium">public</code>, <em>invokeinterface</em> throws an <code style="background-color:inherit;font-size:medium">IllegalAccessError</code>.<span class="assertion-id"> [jsr335-6.5.invokeinterface.runtime-130]</span></span>
</p><p><span class="norm-dynamic">
Otherwise, if the selected method is <code style="background-color:inherit;font-size:medium">abstract</code>, <code style="background-color:inherit;font-size:medium">invokeinterface</code> throws an <code style="background-color:inherit;font-size:medium">AbstractMethodError</code>.<span class="assertion-id"> [jsr335-6.5.invokeinterface.runtime-140]</span></span>
</p><p><span class="norm-dynamic">
Otherwise, if the selected method is <code style="background-color:inherit;font-size:medium">native</code> ...<span class="assertion-id"> [jsr335-6.5.invokeinterface.runtime-150]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> The selection logic is modified so that a non-<code style="background-color:inherit;font-size:medium">abstract</code> method declared in a superinterface may be selected.  By design, this change is retroactive: an <code style="background-color:inherit;font-size:medium">invokeinterface</code> occurring in an old class file may have the effect of invoking a non-<code style="background-color:inherit;font-size:medium">abstract</code> interface method declared in a new class file.
<p>Methods in interfaces are only considered if there is no matching method in the class hierarchy.
</p><p>In the event that we must choose between two non-<code style="background-color:inherit;font-size:medium">abstract</code> methods in the superinterface hierarchy, with neither more specific than the other, an error occurs.  We do not attempt to disambiguate (for example, one may be the referenced method and one may be unrelated, but we do not prefer the referenced method).
</p><p>On the other hand, if there are many <code style="background-color:inherit;font-size:medium">abstract</code> methods but only one non-<code style="background-color:inherit;font-size:medium">abstract</code> method, the non-<code style="background-color:inherit;font-size:medium">abstract</code> method is chosen (unless an <code style="background-color:inherit;font-size:medium">abstract</code> method is more specific).
</p><p>Like method resolution, method selection ignores <code style="background-color:inherit;font-size:medium">private</code> and <code style="background-color:inherit;font-size:medium">static</code> methods declared in superinterfaces.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> Like <code style="background-color:inherit;font-size:medium">invokevirtual</code>, <code style="background-color:inherit;font-size:medium">invokeinterface</code> does not allow the resolved method to be <code style="background-color:inherit;font-size:medium">static</code> (this was impossible in previous versions, assuming the class <code style="background-color:inherit;font-size:medium">Object</code> has no <code style="background-color:inherit;font-size:medium">static</code> methods).  Since <code style="background-color:inherit;font-size:medium">private</code> interface methods cannot be selected, we similarly report an error if the resolved method is <code style="background-color:inherit;font-size:medium">private</code>.
</div></li>
<li style="margin-bottom:12px;"><div> Given the restructured selection logic, it is no longer necessary to separately mandate an <code style="background-color:inherit;font-size:medium">AbstractMethodError</code> if nothing is found.  So that clause has been removed (but the behavior in that case is unchanged).
</div></li></ol></div></blockquote>
<div id="JJVMS-6.5.invokespecial"></div>
<h3> <span class="mw-headline" id="JVMS_6.5_invokespecial_.5BModified.5D"> JVMS 6.5 invokespecial [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.invokespecial" class="external text" rel="nofollow">JVMS 6.5.invokespecial</a></small>
</p><p>...
</p><p><span class="norm-dynamic">
The unsigned <em>indexbyte1</em> and <em>indexbyte2</em> are used to construct an index into the runtime constant pool of the current class (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.6" class="external text" rel="nofollow">2.6</a>), where the value of the index is <em>(indexbyte1 &lt;&lt; 8) | indexbyte2</em>.  The runtime constant pool item at that index must be a symbolic reference to a method <u>or an interface method</u> (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.1" class="external text" rel="nofollow">5.1</a>), which gives the name and descriptor (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.3" class="external text" rel="nofollow">4.3.3</a>) of the method as well as a symbolic reference to the class <u>or interface</u> in which the method is to be found.  The named method is resolved <u>(<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.3.3" class="external text" rel="nofollow">5.4.3.3</a>, <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.3.4" class="external text" rel="nofollow">5.4.3.4</a>)</u>.  Finally, if the resolved method is <code style="background-color:inherit;font-size:medium">protected</code> (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6" class="external text" rel="nofollow">4.6</a>), and it is a member of a superclass of the current class, and the method is not declared in the same runtime package (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.3" class="external text" rel="nofollow">5.3</a>) as the current class, then the class of <em>objectref</em> must be either the current class or a subclass of the current class, <u>or an <code style="background-color:inherit;font-size:medium">IllegalAccessError</code> is raised</u>.<span class="assertion-id"> [jvms-6.5.invokespecial.desc-100]</span></span>
</p><p><span class="norm-dynamic">
Next, <del>the resolved</del> <u>a</u> method is selected for invocation <u>according to the following rules.</u><span class="assertion-id"> [jsr335-6.5.invokespecial.desc-150]</span></span>
</p><p><span class="norm-dynamic">
<u>Let <em>C</em> be the class or interface named by the method reference or interface method reference</u>, unless all of the following conditions are true:<span class="assertion-id"> [jvms-6.5.invokespecial.desc-200]</span></span>
</p>
<ul><li> <span class="norm-dynamic"> The <code style="background-color:inherit;font-size:medium">ACC_SUPER</code> flag (see Table 4.1, "Class access and property modifiers") is set for the current class.<span class="assertion-id"> [jvms-6.5.invokespecial.desc-200-A]</span></span>
</li><li> <span class="norm-dynamic"> The class <del>of the resolved method</del> <u>named by the method reference</u> is a superclass <u>(not a superinterface)</u> of the current class.<span class="assertion-id"> [jvms-6.5.invokespecial.desc-200-B]</span></span>
</li><li> <span class="norm-dynamic"> The resolved method is not an instance initialization method (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.9" class="external text" rel="nofollow">2.9</a>).<span class="assertion-id"> [jvms-6.5.invokespecial.desc-200-C]</span></span>
</li></ul>
<p><span class="norm-dynamic">
If the above conditions are true, <del>the actual method to be invoked is selected by the following lookup procedure</del> let <em>C</em>, <u>instead,</u> be the direct superclass of the current class.<span class="assertion-id"> [jsr335-6.5.invokespecial.desc-210]</span></span>
</p><p><span class="norm-dynamic">
<u>The method for invocation is selected as follows:</u><span class="assertion-id"> [jvms-6.5.invokespecial.desc-300]</span></span>
</p>
<ul><li> <span class="norm-dynamic"> If <em>C</em> contains a declaration for an instance method with the same name and descriptor as the resolved method, then this method will be invoked. <del>The lookup procedure terminates</del>.<span class="assertion-id"> [jvms-6.5.invokespecial.desc-300-A]</span></span>
</li><li> <span class="norm-dynamic"> Otherwise, if <em>C</em> <u>is a class and</u> has a superclass, <u>a search for a declaration of an instance method with the same name and descriptor as the resolved method is performed, starting with the direct superclass of <em>C</em> and continuing with the direct superclass of that class, and so forth, until a match is found or no further superclasses exist.  If a match is found, it is the method to be invoked.</u><span class="assertion-id"> [jvms-6.5.invokespecial.desc-300-B]</span></span>
</li><li> <span class="norm-dynamic"> <u>Otherwise, if <em>C</em> is an interface and the class <code style="background-color:inherit;font-size:medium">Object</code> contains a declaration of a <code style="background-color:inherit;font-size:medium">public</code> (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6" class="external text" rel="nofollow">4.6</a>) instance method with the same name and descriptor as the resolved method, this is the method to be invoked.</u><span class="assertion-id"> [jvms-6.5.invokespecial.desc-300-E]</span></span>
</li><li> <span class="norm-dynamic"> <u>Otherwise, the superinterfaces of <em>C</em> are searched for all maximally-specific methods (<a href="#JJVMS-5.4.3.3" title="Lambda J" class="mw-redirect">JVMS-5.4.3.3</a>) that match the resolved method's name and descriptor:</u><span class="assertion-id"> [jsr335-6.5.invokespecial.desc-300-D]</span></span>
<ul><li> <span class="norm-dynamic"> <u>If exactly one of the maximally-specific matching methods is not <code style="background-color:inherit;font-size:medium">abstract</code>, this is the method to be invoked.</u><span class="assertion-id"> [jsr335-6.5.invokespecial.desc-300-D3]</span></span>
</li><li> <span class="norm-dynamic"> <u>Otherwise, if more than one of the maximally-specific matching methods is not <code style="background-color:inherit;font-size:medium">abstract</code>, an <code style="background-color:inherit;font-size:medium">IncompatibleClassChangeError</code> is raised.</u><span class="assertion-id"> [jsr335-6.5.invokespecial.desc-300-D4]</span></span>
</li><li> <span class="norm-dynamic"> Otherwise, an <code style="background-color:inherit;font-size:medium">AbstractMethodError</code> is raised.<span class="assertion-id"> [jvms-6.5.invokespecial.desc-300-C]</span></span>
</li></ul>
</li></ul>
<p>...
</p><p><span class="norm-dynamic">
Otherwise, if <em>objectref</em> is <code style="background-color:inherit;font-size:medium">null</code>, the <code style="background-color:inherit;font-size:medium">invokespecial</code> instruction throws a <code style="background-color:inherit;font-size:medium">NullPointerException</code>.<span class="assertion-id"> [jvms-6.5.invokespecial.runtime-100]</span></span>
</p><p><del><span class="norm-dynamic"> Otherwise if no method matching the resolved name and descriptor is selected, <code style="background-color:inherit;font-size:medium">invokespecial</code> throws an <code style="background-color:inherit;font-size:medium">AbstractMethodError</code>.<span class="assertion-id"> [jvms-6.5.invokespecial.runtime-110]</span></span></del>
</p><p><span class="norm-dynamic">
Otherwise, if the selected method is <code style="background-color:inherit;font-size:medium">abstract</code>, <code style="background-color:inherit;font-size:medium">invokespecial</code> throws an <code style="background-color:inherit;font-size:medium">AbstractMethodError</code>.<span class="assertion-id"> [jvms-6.5.invokespecial.runtime-120]</span></span>
</p><p><span class="norm-dynamic">
Otherwise, if the selected method is <code style="background-color:inherit;font-size:medium">native</code> ...<span class="assertion-id"> [jvms-6.5.invokespecial.runtime-130]</span></span>
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> The <code style="background-color:inherit;font-size:medium">invokespecial</code> instruction is extended to:
<ul><li> Handle invocation of a <code style="background-color:inherit;font-size:medium">private</code> interface method.
</li><li> Handle invocation of a non-<code style="background-color:inherit;font-size:medium">abstract</code> interface method referenced via a direct superinterface.
</li><li> Handle invocation of a non-<code style="background-color:inherit;font-size:medium">abstract</code> interface method referenced via a superclass.
</li></ul>
<p>In these cases, the rules for selection are essentially the same as those for <code style="background-color:inherit;font-size:medium">invokeinterface</code> (except that the search starts from a different class).
</p><p>For simplicity of presentation, the selection logic has been changed to apply in all cases.  Sometimes this is redundant—in fact, with the exception of the <code style="background-color:inherit;font-size:medium">ACC_SUPER</code> trick performed for indirect superclass invocations, if selection produces a method, it will be the resolved method.  But, selection must also ensure that appropriate error checks (such as the <code style="background-color:inherit;font-size:medium">IncompatibleClassChangeError</code>) are performed, to avoid nondeterminism.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> The behavior of selection has been clarified slightly to account for the possibility that the <code style="background-color:inherit;font-size:medium">Methodref</code> resolves to an interface method, but this method has a closer match in a superclass.
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
public interface I { public abstract void m(); }
public abstract class A implements I {}
public class B extends A { public void m() { ... } }
public class C extends B {
  public void test() {
    invokespecial A.m()V;
  }
}
</pre>
<p>The previous specification text suggested that this would be an <code style="background-color:inherit;font-size:medium">AbstractMethodError</code>, since since <code style="background-color:inherit;font-size:medium">I</code> is not "a superclass of the current class".  However, the behavior of the HotSpot VM here has been to select <code style="background-color:inherit;font-size:medium">B.m</code>.
</p>
</div></li></ol></div></blockquote>
<div id="JJVMS-6.5.invokestatic"></div>
<h3> <span class="mw-headline" id="JVMS_6.5_invokestatic_.5BModified.5D"> JVMS 6.5 invokestatic [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.invokestatic" class="external text" rel="nofollow">JVMS 6.5.invokestatic</a></small>
</p><p>...
</p><p><span class="norm-dynamic">
The unsigned <em>indexbyte1</em> and <em>indexbyte2</em> are used to construct an index into the runtime constant pool of the current class (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.6" class="external text" rel="nofollow">2.6</a>), where the value of the index is <em>(indexbyte1 &lt;&lt; 8) | indexbyte2</em>.  The runtime constant pool item at that index must be a symbolic reference to a method <u>or an interface method</u> (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.1" class="external text" rel="nofollow">5.1</a>), which gives the name and descriptor (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.3" class="external text" rel="nofollow">4.3.3</a>) of the method as well as a symbolic reference to the class <u>or interface</u> in which the method is to be found.  The named method is resolved (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.3.3" class="external text" rel="nofollow">5.4.3.3</a>).  The resolved method must not be an instance initialization method (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.9" class="external text" rel="nofollow">2.9</a>) or <del>the</del> <u>a</u> class or interface initialization method (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.9" class="external text" rel="nofollow">2.9</a>).  It must be <code style="background-color:inherit;font-size:medium">static</code>, and therefore cannot be <code style="background-color:inherit;font-size:medium">abstract</code>.<span class="assertion-id"> [jvms-6.5.invokestatic.desc-100]</span></span>
</p><p><span class="norm-dynamic">
On successful resolution of the method, the class <u>or interface</u> that declared the resolved method is initialized (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.5" class="external text" rel="nofollow">5.5</a>) if that class <u>or interface</u> has not already been initialized.<span class="assertion-id"> [jvms-6.5.invokestatic.desc-110]</span></span>
</p><p>...
</p><p><span class="norm-dynamic">
Otherwise, if the resolved method is an instance method, the <em>invokestatic</em> instruction throws an <code style="background-color:inherit;font-size:medium">IncompatibleClassChangeError</code>.<span class="assertion-id"> [jvms-6.5.invokestatic.linking-110]</span></span>
</p><p><span class="norm-dynamic">
Otherwise, if execution of this <em>invokestatic</em> instruction causes initialization of the referenced class <u>or interface</u>, <em>invokestatic</em> may throw an <code style="background-color:inherit;font-size:medium">Error</code> as detailed in <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.5" class="external text" rel="nofollow">5.5</a>.<span class="assertion-id"> [jvms-6.5.invokestatic.runtime-100]</span></span>
</p><p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
The <code style="background-color:inherit;font-size:medium">invokestatic</code> instruction is extended to handle invocation of a <code style="background-color:inherit;font-size:medium">static</code> interface method.</div></blockquote>
<div id="JJVMS-6.5.invokevirtual"></div>
<h3> <span class="mw-headline" id="JVMS_6.5_invokevirtual_.5BModified.5D"> JVMS 6.5 invokevirtual [Modified] </span></h3>
<p><small>Compare <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.invokevirtual" class="external text" rel="nofollow">JVMS 6.5.invokevirtual</a></small>
</p><p>...
</p><p><span class="norm-dynamic">
The unsigned <em>indexbyte1</em> and <em>indexbyte2</em> are used to construct an index into the runtime constant pool of the current class (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.6" class="external text" rel="nofollow">2.6</a>), where the value of the index is <em>(indexbyte1 &lt;&lt; 8) | indexbyte2</em>.  The runtime constant pool item at that index must be a symbolic reference to a method (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.1" class="external text" rel="nofollow">5.1</a>), which gives the name and descriptor (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.3" class="external text" rel="nofollow">4.3.3</a>) of the method as well as a symbolic reference to the class in which the method is to be found.  The named method is resolved (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.3.3" class="external text" rel="nofollow">5.4.3.3</a>).  The resolved method must not be an instance initialization method (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.9" class="external text" rel="nofollow">2.9</a>) or <del>the</del> <u>a</u> class or interface initialization method (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.9" class="external text" rel="nofollow">2.9</a>).  Finally, if the resolved method is <code style="background-color:inherit;font-size:medium">protected</code> (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6" class="external text" rel="nofollow">4.6</a>), and it is a member of a superclass of the current class, and the method is not declared in the same runtime package (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.3" class="external text" rel="nofollow">5.3</a>) as the current class, then the class of <em>objectref</em> must be either the current class or a subclass of the current class.<span class="assertion-id"> [jvms-6.5.invokevirtual.desc-100]</span></span>
</p><p><span class="norm-dynamic">
If the resolved method is not signature polymorphic (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.9" class="external text" rel="nofollow">2.9</a>), then the <em>invokevirtual</em> instruction proceeds as follows.<span class="assertion-id"> [jvms-6.5.invokevirtual.desc-200]</span></span>
</p><p><span class="norm-dynamic">
Let <em>C</em> be the class of <em>objectref</em>.  The actual method to be invoked is selected by the following lookup procedure:<span class="assertion-id"> [jvms-6.5.invokevirtual.desc-210]</span></span>
</p>
<ul><li> <span class="norm-dynamic"> If <em>C</em> contains a declaration for an instance method <em>M</em> that overrides (<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.5" class="external text" rel="nofollow">5.4.5</a>) the resolved method, then <em>M</em> is the method to be invoked <del>and the lookup procedure terminates</del>.<span class="assertion-id"> [jvms-6.5.invokevirtual.desc-210-A]</span></span>
</li><li> <span class="norm-dynamic"> Otherwise, if <em>C</em> has a superclass, <u>a search for a declaration of an instance method that overrides the resolved method is performed, starting with the direct superclass of <em>C</em> and continuing with the direct superclass of that class, and so forth, until an overriding method is found or no further superclasses exist.  If an overriding method is found, it is the method to be invoked.</u><span class="assertion-id"> [jvms-6.5.invokevirtual.desc-210-B]</span></span>
</li><li> <span class="norm-dynamic"> <u>Otherwise, the superinterfaces of <em>C</em> are searched for all maximally-specific methods (<a href="#JJVMS-5.4.3.3" title="Lambda J" class="mw-redirect">JVMS-5.4.3.3</a>) that match the resolved method's name and descriptor:</u><span class="assertion-id"> [jsr335-6.5.invokevirtual.desc-210-D]</span></span>
<ul><li> <span class="norm-dynamic"> <u>If exactly one of the maximally-specific matching methods is not <code style="background-color:inherit;font-size:medium">abstract</code>, this is the method to be invoked.</u><span class="assertion-id"> [jsr335-6.5.invokevirtual.desc-210-D3]</span></span>
</li><li> <span class="norm-dynamic"> <u>Otherwise, if more than one of the maximally-specific matching methods is not <code style="background-color:inherit;font-size:medium">abstract</code>, an <code style="background-color:inherit;font-size:medium">IncompatibleClassChangeError</code> is raised.</u><span class="assertion-id"> [jsr335-6.5.invokevirtual.desc-210-D4]</span></span>
</li><li> <span class="norm-dynamic"> Otherwise, an <code style="background-color:inherit;font-size:medium">AbstractMethodError</code> is raised.<span class="assertion-id"> [jvms-6.5.invokevirtual.desc-210-C]</span></span>
</li></ul>
</li></ul>
<p>...
</p><p><span class="norm-dynamic"> Otherwise, if the resolved method is not signature polymorphic:<span class="assertion-id"> [jvms-6.5.invokevirtual.runtime-110]</span></span>
</p>
<ul><li> <del><span class="norm-dynamic"> If no method matching the resolved name and descriptor is selected, <code style="background-color:inherit;font-size:medium">invokevirtual</code> throws an <code style="background-color:inherit;font-size:medium">AbstractMethodError</code>.<span class="assertion-id"> [jvms-6.5.invokevirtual.runtime-110-A]</span></span></del>
</li><li> <span class="norm-dynamic"> <del>Otherwise</del> If the selected method is <code style="background-color:inherit;font-size:medium">abstract</code>, <code style="background-color:inherit;font-size:medium">invokevirtual</code> throws an <code style="background-color:inherit;font-size:medium">AbstractMethodError</code>.<span class="assertion-id"> [jvms-6.5.invokevirtual.runtime-110-B]</span></span>
</li><li> <span class="norm-dynamic"> Otherwise, if the selected method is <code style="background-color:inherit;font-size:medium">native</code> ...<span class="assertion-id"> [jvms-6.5.invokevirtual.runtime-110-C]</span></span>
</li></ul>
<p>...
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>
<p>Discussion and motivation:
</p>
<ol>
<li style="margin-bottom:12px;"><div> It is possible that the <code style="background-color:inherit;font-size:medium">Methodref</code> of an <code style="background-color:inherit;font-size:medium">invokevirtual</code> instruction resolves to an interface method.  In this case, it is possible that there is no overriding method in the class hierarchy, but that a non-<code style="background-color:inherit;font-size:medium">abstract</code> interface method matches the resolved method's signature.  The selection logic has been modified to match such a method, using the same rules as those for <code style="background-color:inherit;font-size:medium">invokeinterface</code>.
<p>Again, this change is designed to be retroactive: an <code style="background-color:inherit;font-size:medium">invokevirtual</code> occurring in an old class file may have the effect of invoking a non-<code style="background-color:inherit;font-size:medium">abstract</code> interface method declared in a new class file.
</p>
</div></li>
<li style="margin-bottom:12px;"><div> Given the restructured selection logic, it is no longer necessary to separately mandate an <code style="background-color:inherit;font-size:medium">AbstractMethodError</code> if nothing is found.  So that clause has been removed (but the behavior in that case is unchanged).
</div></li></ol></div></blockquote>



</body></html>