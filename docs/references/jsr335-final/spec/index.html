<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" dir="ltr">
<head>
<title>JSR 335: Lambda Expressions for the Java™ Programming Language</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="MediaWiki 1.16.5" />

<style type="text/css">
p,li,dd,dt,tr { line-height:120%; }
li { margin-top:4pt; }
a { text-decoration:none; }
dt { font-weight:bold; margin-top:8pt; }
dd { margin-left:0pt; }
.assertion-id { visibility:hidden; font-style:italic; }
</style>
</head>
<body class="mediawiki ltr ns-0 ns-subject page-JSR_335_Lambda_Expressions_for_the_Java™_Programming_Language skin-monobook">
	<a id="top"></a>
	
	<h1 id="firstHeading" class="firstHeading">JSR 335: Lambda Expressions for the Java™ Programming Language</h1>
									<p><small>Version 0.9.3.  Copyright © 2014 Oracle America, Inc.  <a href="index.html#Legal_Notice" title="Lambda Specification" class="mw-redirect">Legal Notice</a>.</small>
</p>
<h2> <span class="mw-headline" id="Outline"> Outline </span></h2>
<ul><li> <b><a href="A.html" title="Lambda A" class="mw-redirect">Part A: Functional Interfaces</a></b>: Provides a definition of functional interfaces, which lambda expressions and method references can be used to instantiate.
</li><li> <b><a href="B.html" title="Lambda B" class="mw-redirect">Part B: Lambda Expressions</a></b>: Defines the syntax of lambda expressions, including rules for the new kinds of parameter lists and statement lists.
</li><li> <b><a href="C.html" title="Lambda C" class="mw-redirect">Part C: Method References</a></b>: Defines the syntax of method references.
</li><li> <b><a href="D.html" title="Lambda D" class="mw-redirect">Part D: Poly Expressions</a></b>: Describes poly expressions, which are a category of expressions that can adapt their typing to conform to a particular context.
</li><li> <b><a href="E.html" title="Lambda E" class="mw-redirect">Part E: Typing and Evaluation</a></b>: Specifies the typing rules and evaluation behavior of lambda expressions and method references.
</li><li> <b><a href="F.html" title="Lambda F" class="mw-redirect">Part F: Overload Resolution</a></b>: Adapts overload resolution to handle lambda expressions and other poly expressions.
</li><li> <b><a href="G.html" title="Lambda G" class="mw-redirect">Part G: Type Inference</a></b>: Redefines type inference to support lambda expressions and method references, and to allow context to be pushed down to nested poly expressions.
</li><li> <b><a href="H.html" title="Lambda H" class="mw-redirect">Part H: Default Methods</a></b>: Describes the syntax and inheritance behavior of default methods, which are members of interfaces.
</li><li> <b><a href="J.html" title="Lambda J" class="mw-redirect">Part J: Java Virtual Machine</a></b>: Enhances the JVM specification to support code-carrying methods in interfaces.
</li></ul>
<h2> <span class="mw-headline" id="Introduction"> Introduction </span></h2>
<p>This document presents the language and virtual machine specification changes for JSR 335: Lambda Expressions for the Java™ Programming Language.
</p><p>The new language features are described with reference to existing structure and definitions in the <a href="http://docs.oracle.com/javase/specs/jls/se7/html/index.html" class="external text" rel="nofollow">Java Language Specification, Java SE 7 Edition</a>.  Unless stated otherwise, section numbers interspersed throughout the document refer to the Java Language Specification (possibly as amended by this document).  The bulk of the changes apply to the following JLS chapters:
</p>
<ul><li> 5. Conversions and Promotions
</li><li> 8. Classes
</li><li> 9. Interfaces
</li><li> 14. Blocks and Statements
</li><li> 15. Expressions
</li></ul>
<p>Edits to the JLS are not presented sequentially; rather, they are organized into parts that group together related changes.  Some JLS sections have multiple edits, each in a different part.
</p><p>A small addendum to the <a href="http://docs.oracle.com/javase/7/docs/platform/serialization/spec/serialTOC.html" class="external text" rel="nofollow">Java Object Serialization Specification</a> is made in <a href="E.html#ESerialization" title="Lambda E" class="mw-redirect">Part E</a>.
</p><p>Changes to the <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/index.html" class="external text" rel="nofollow">Java Virtual Machine Specification, Java SE 7 Edition</a>, are also necessary to support default methods.  These changes are indicated in <a href="J.html" title="Lambda J" class="mw-redirect">Part J</a>.
</p><p>Except to ensure that necessary functionality is made available by a Java Virtual Machine, this document does not consider implementation.  The mapping of lambda expressions to objects, for example, is only minimally specified as required by type safety—our goal is to allow the implementer freedom as to how and when the object expressed by a lambda expression is created.
</p>
<h3> <span class="mw-headline" id="Notation"> Notation </span></h3>
<p>In a section tagged [New] or [Addendum], everything is new text.
</p><p>In a section tagged [Modified], this is existing text, <u>this is new text</u> <del>this has been removed</del>, and this is more existing text.
</p><p>The following is a formula: <em>f(x)=z</em>.
</p><p>The following is literal program text: <code style="background-color:inherit;font-size:medium">final int x</code>.
</p><p>This sentence introduces a <i>new term</i>.
</p>
<blockquote style="background:whitesmoke; border:1px dotted;padding:5px;"><div>This is a note containing discussion or examples.  Such notes are not typically intended to appear in the revised language specification.</div></blockquote>
<h2> <span class="mw-headline" id="Summary"> Summary </span></h2>
<p>For the reader interested in a broad view of this document, a summary from each part is reproduced below.
</p>
<h4> <span class="mw-headline" id="Part_A"> <a href="A.html" title="Lambda A" class="mw-redirect">Part A</a> </span></h4>
<p>A <i>functional interface</i> is an interface that has just one abstract method (aside from the methods of <code style="background-color:inherit;font-size:medium">Object</code>), and thus represents a single function contract.  (In some cases, this "single" method may take the form of multiple abstract methods with override-equivalent signatures inherited from superinterfaces; in this case, the inherited methods logically represent a single method.)
</p><p>In addition to the usual process of creating an interface instance by declaring and instantiating a class, instances of functional interfaces can be created with <i>lambda expressions</i> or <i>method references</i>.
</p><p>The <i>function type</i> of a functional interface <em>I</em> is a method type—type parameters, formal parameter types, return types, and thrown types—that can be used to legally override the abstract method(s) of <em>I</em>.
</p><p>The term <i>functional interface type</i> refers to a non-generic functional interface, a parameterization of a functional interface, a raw functional interface, or an intersection type inducing a functional interface.
</p>
<h4> <span class="mw-headline" id="Part_B"> <a href="B.html" title="Lambda B" class="mw-redirect">Part B</a> </span></h4>
<p>A lambda expression is like a method: it provides a list of formal parameters and a body—an expression or block—expressed in terms of those parameters.
</p><p>Examples of lambda expressions:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
s -&gt; s.length()

(int x, int y) -&gt; x+y

() -&gt; 42

(x, y, z) -&gt; {
  if (true) return x;
  else {
    int result = y;
    for (int i = 1; i &lt; z; i++)
      result *= i;
    return result;
  }
}
</pre>
<p>This particular syntax was chosen principally because something similar has been generally well-received in other Java-like languages (C# and Scala), and a clearly "better" alternative did not present itself. It has the advantage over alternate proposals of minimizing bracketing noise around simple lambda expressions.  When some extra bracketing is needed to visually distinguish either the full lambda expression or its body expression, parentheses are naturally supported (just as in other cases in which operator precedence is unclear).
</p><p>The formal parameters of a lambda expression may have either declared types or inferred types. We refer to a lambda expression whose formal parameters have declared types as <i>explicitly-typed</i>, and a lambda expression whose formal parameters have inferred types as <i>implicitly-typed</i>.  The parameter types of an implicitly-typed lambda are derived from the functional interface type targeted by the expression.
</p><p>A lambda body is either a single expression or a block. Like a method body, a lambda body describes code that will be executed whenever an invocation occurs.
</p><p>Unlike code appearing in anonymous class declarations, the meaning of names and the <code style="background-color:inherit;font-size:medium">this</code> and <code style="background-color:inherit;font-size:medium">super</code> keywords appearing in a lambda body are the same as in the surrounding context (except that lambda parameters introduce new names).
</p><p>For both lambda bodies and inner classes, local variables in the enclosing context can only be referenced if they are <code style="background-color:inherit;font-size:medium">final</code> or <i>effectively final</i>. A variable is <i>effectively final</i> if it is never assigned to after its initialization.
</p><p>Block lambda bodies that don't return anything are considered <i>void-compatible</i>; block lambda bodies that return a value from every execution path are considered <i>value-compatible</i>. In a value-compatible lambda body, the <i>result expressions</i> are any expressions that may produce an invocation's value.
</p>
<h4> <span class="mw-headline" id="Part_C"> <a href="C.html" title="Lambda C" class="mw-redirect">Part C</a> </span></h4>
<p>A method reference is used to refer to the invocation of a method without actually performing the invocation.  Certain forms of method references also allow class instance creation or array creation to be treated as if it were a method invocation.
</p><p>Examples of method references:
</p>
<pre style="border:none;background-color:inherit;color:inherit;font-size:medium;padding:0px;margin-left:20px">
System::getProperty
&quot;abc&quot;::length
System.out::println
String::length
super::toString
ArrayList::new
int[]::new
</pre>
<p>The target reference (i.e., the "receiver") of an instance method may be provided by the method reference expression or it may be provided later when the method is invoked.  The immediately enclosing instance of a new inner class instance must be provided by a lexically enclosing instance of <code style="background-color:inherit;font-size:medium">this</code>.
</p><p>When more than one member method of a type has the same name, or when a class has more than one constructor, the appropriate method or constructor is selected based on the functional interface type targeted by the expression.
</p>
<h4> <span class="mw-headline" id="Part_D"> <a href="D.html" title="Lambda D" class="mw-redirect">Part D</a> </span></h4>
<p>Every expression written in the Java programming language either produces no result (<code style="background-color:inherit;font-size:medium">void</code>) or has a type that can be deduced at compile time.  When an expression appears in most contexts, it must be <i>compatible</i> with a type expected in that context; this type is called the <i>target type</i>.  For convenience, compatibility of an expression with its surrounding context is facilitated by the language in two ways:
</p>
<ul><li> First, for some expressions, termed <i>poly expressions</i>, the deduced type can be influenced by the target type.  The same expression can have different types in different contexts.
</li><li> Second, after the type of the expression has been deduced, an implicit <i>conversion</i> from the type of the expression to the target type can sometimes be performed.
</li></ul>
<p>If neither strategy is able to produce the appropriate type, an error occurs at compile time.
</p><p>Given certain meanings of names, the type of a <i>standalone expression</i> (an expression that is not a poly expression) can be determined entirely from the contents of the expression.  In contrast, the type of a poly expression may be influenced by the expression's target type.
</p><p>The following forms of expressions may be poly expressions:
</p>
<ul><li> Parenthesized expressions
</li><li> Class instance creation expressions
</li><li> Method invocation expressions
</li><li> Conditional operator expressions
</li><li> Lambda expressions
</li><li> Method references
</li></ul>
<p>To determine whether an expression of one of these forms is a poly expression, we may consider the kind of context in which the expression appears and the content of the expression.
</p><p>Generic method invocation expressions, along with class instance creation expressions that use a diamond <code style="background-color:inherit;font-size:medium">&lt;&gt;</code>, may be poly expressions when they appear in assignment or invocation contexts.  This allows type argument inference to depend on context.
</p><p>Lambda expressions and method references are always poly expressions; their typing rules are covered by <a href="E.html" title="Lambda E" class="mw-redirect">Part E</a>.
</p><p>Conditional operator expressions may be poly expressions if they appear in assignment or invocation contexts, unless both operands produce primitives (or boxed primitives).  When they are poly expressions, the target type is "pushed down" to each operand.
</p><p>Similarly, parenthesized expressions that wrap poly subexpressions are poly expressions, passing the target type on to the subexpression.
</p><p>Casts can be used to explicitly "tag" a lambda expression or a method reference with a particular target type.  To provide an appropriate degree of flexibility, the target type may be a list of types denoting an intersection type (as long as the intersection is also a functional interface type, typically meaning one element is a functional interface and the others are marker interfaces).  Since the feature is generally useful, we also support casts of arbitrary expressions to intersection types.
</p>
<h4> <span class="mw-headline" id="Part_E"> <a href="E.html" title="Lambda E" class="mw-redirect">Part E</a> </span></h4>
<p>Lambda expressions and method references are always poly expressions. It is a compile-time error if one of these occurs in a program in someplace other than an assignment context, an invocation context, or a casting context.
</p><p>The type of a lambda expression or method reference is a functional interface type, derived from its target type.  To be compatible with the target type, the expression must be <i>congruent</i> with the function type of this functional interface type.
</p><p>To test that a lambda expression is congruent, the function type's parameter and return types are compared to the expression.  The lambda parameter types (if given) must exactly match those of the function type, while the body must be assignment-compatible with the function type's return type.  The lambda's expression body (or each result expression of its block body) may be a poly expression.
</p><p>To test that a method reference is congruent, a <i>compile-time declaration</i> is determined following the process used for method <i>invocations</i>. The function type's parameter types are used as argument types in this search, where the first parameter type may sometimes act as the receiver for an instance method. The selected declaration's return type is then checked to be assignment-compatible with the function type's return type.
</p><p>For some method references, there is only one possible compile-time declaration with only one possible invocation type, regardless of the targeted function type. These are referred to as <i>exact method references</i>.
</p><p>In addition to the compatibility requirement, lambda bodies and referenced methods must not throw exceptions that are incompatible with the function type's <code style="background-color:inherit;font-size:medium">throws</code> clause.
</p><p>Evaluation of a lambda expression or method reference produces an instance of a functional interface.  Evaluation does not cause the execution of a lambda body or the invocation of a referenced method; instead, this may occur at a later time when an appropriate method of the interface is invoked.
</p><p>To evaluate the expression, either a new instance of an appropriate class is allocated and initialized, or an existing instance of an appropriate class is referenced.  The evaluation rules are minimally restrictive, thus allowing VMs freedom for optimization.  For example, a separate class need not be defined for each distinct expression, nor must a new object be allocated on every evaluation.
</p>
<h4> <span class="mw-headline" id="Part_F"> <a href="F.html" title="Lambda F" class="mw-redirect">Part F</a> </span></h4>
<p>Method and constructor declarations can be overloaded, meaning multiple matching declarations with different parameter types can co-exist in a type.  In order to interpret a method invocation or a class instance creation expression, the compiler performs "overload resolution," inferring the declaration intended by the user at a particular invocation site.  This occurs in three steps: i) identifying <i>potentially applicable methods</i>, that is, methods of the appropriate shape; ii) performing type analysis to identify <i>applicable methods</i> for the given arguments; iii) among the applicable methods, choosing one that is <i>most specific</i>.
</p><p>To accomodate lambda expressions, the definition of potential applicability is expanded to take into account both the arity of the candidate methods and the presence and "shape" of functional interface target types.
</p><p>To check for applicability, the types of an invocation's arguments can no longer, in general, be inputs to the analysis.  This is because:
</p>
<ul><li> The arguments to a method invocation may be poly expressions
</li><li> Poly expressions cannot be typed in the absence of a target type
</li><li> Overload resolution has to be completed before the arguments' target types will be known
</li></ul>
<p>Instead, the input to the applicability check is a list of argument <i>expressions</i>, which <i>can</i> be checked for compatibility with potential target types, even if the ultimate types of the expressions are unknown.
</p><p>The meaning of an implicitly-typed lambda expression or an inexact method reference is sufficiently vague prior to resolving a target type that arguments containing these expressions are not considered <i>pertinent to applicability</i>; they are simply ignored (except for their expected arity) until overload resolution is finished.
</p><p>The Java 7 most-specific analysis was defined as a pairwise comparison of method declarations via subtyping.  Here, we augment the analysis so that, where the corresponding argument is an explicitly-typed lambda expression or an exact method reference, one functional interface type can be preferred over another if it has a "better" function type return type, by a variety of measures: subtyping, boxing, or <code style="background-color:inherit;font-size:medium">void</code> vs. non-<code style="background-color:inherit;font-size:medium">void</code>.
</p>
<h4> <span class="mw-headline" id="Part_G"> <a href="G.html" title="Lambda G" class="mw-redirect">Part G</a> </span></h4>
<p>A variety of compile-time analyses require reasoning about types that are not yet known.  Principal among these are generic method applicability testing and generic method invocation type inference.  In general, we refer to the process of reasoning about unknown types as <i>type inference</i>.
</p><p>At a high level, type inference consists of <i>reducing</i> compatibility assertions about expressions or types, called <i>constraint formulas</i>, to a set of <i>bounds</i> on <i>inference variables</i>.  For example, given inference variable <em>α</em>, it might be determined that the constraint formula <em>⟨<code style="background-color:inherit;font-size:medium">String[]</code> &lt;: α<code style="background-color:inherit;font-size:medium">[]</code>⟩</em> reduces to the lower bound <em><code style="background-color:inherit;font-size:medium">String</code> &lt;: α</em>.  As bounds are inferred, they are <i>incorporated</i> into a <i>bound set</i>.  Ultimately, this bound set is <i>resolved</i> to produce an instantiation for each of the inference variables.
</p><p>To infer a generic method's applicability, we assert that the arguments to the method are compatible with their corresponding formal parameter types, and reduce these constraints to a bound set.  We then check that there exists a resolution of the resulting bounds.
</p><p>To infer the type of a generic method invocation, we re-use the inferred bound set from method applicability testing, augmenting it with the results of asserting the compatibility of the method's return type with its target type.  If any invocation arguments are implicitly-typed lambda expressions or inexact method references, we resolve their targeted parameter types as necessary in order to allow their compatibility constraints to be safely reduced.  We also assert that any exceptions thrown by lambda expression bodies are contained by the <code style="background-color:inherit;font-size:medium">throws</code> clauses of their target function types.  After reduction, we resolve the inference variables and use them as type arguments to determine the invocation type of the method.
</p><p>Type inference is also used to determine: i) a target functional interface type for a lambda expression that is assigned to a wildcard-parameterized functional interface; and ii) whether an applicable method is more specific than another applicable, generic method.
</p><p>The following details of reduction are especially noteworthy:
</p><p>When a generic method invocation or diamond constructor invocation appears as the argument to another invocation, the target type of the nested invocation is the targeted formal parameter type.  If the target type contains inference variables, the inference variables and bounds from the nested invocation are "lifted" into the outer inference analysis, and dependencies between the outer and inner inference variables are inferred.  Ultimately, information from an outermost invocation can be "pushed down" to nested invocations via these dependencies.
</p><p>When a lambda expression appears as the argument to a generic invocation, and its target type includes inference variables, we proceed by:
</p>
<ul><li> Checking that the target type is a functional interface type and deriving a target function type.
</li><li> If the lambda parameters' types are implicit, ensuring that the target function type has proper types as its parameter types (allowing the lambda body to be type-checked).
</li><li> If the lambda parameters' types are explicit, asserting that these types match the target type's parameter types.
</li><li> Asserting that each result expression in the lambda body is compatible with the target type's return type.
</li></ul>
<p>Thus, lambda bodies can influence the instantiation of inference variables appearing in the targeted function type's return type, and lambda parameter types, if explicit, can influence the instantiation of inference variables appearing in the targeted function type's parameter types.
</p><p>A method reference appearing as the argument to a generic invocation is handled in much the same way.
</p>
<h4> <span class="mw-headline" id="Part_H"> <a href="H.html" title="Lambda H" class="mw-redirect">Part H</a> </span></h4>
<p>A <i>default method</i> is a method that is declared in an interface with the modifier <code style="background-color:inherit;font-size:medium">default</code>.  Its body provides a default implementation for any class that implements the interface without overriding the method.  This allows new functionality to be added to existing (and perhaps already widely-distributed) interfaces.  More generally, it provides a mechanism for multiple inheritance of behavior.
</p><p>An interface may also declare <code style="background-color:inherit;font-size:medium">static</code> methods, which work in much the same way as <code style="background-color:inherit;font-size:medium">static</code> methods in classes, except that they are not inherited.  Often, an interface is the most appropriate place to declare methods that produce or manipulate objects of the interface type.
</p><p>An interface method that is neither <code style="background-color:inherit;font-size:medium">default</code> nor <code style="background-color:inherit;font-size:medium">static</code> is implicitly <code style="background-color:inherit;font-size:medium">abstract</code>.
</p><p>An interface <em>I</em> inherits from its direct superinterfaces all <code style="background-color:inherit;font-size:medium">abstract</code> and default methods that are members of a superinterface, not overridden by a declaration in <em>I</em>, and not already overridden by another method in a superinterface of <em>I</em>.
</p><p>Similarly, a class <em>C</em> inherits from its direct superclass and direct superinterfaces all <code style="background-color:inherit;font-size:medium">abstract</code> and default methods that are members of a supertype, not overridden by a declaration in <em>C</em> <i>nor</i> a concrete method inherited from the superclass of <em>C</em>, and not already overridden by another method in a supertype of <em>C</em>.
</p><p>Notably, this implies that a method inherited from a superclass of <em>C</em> can override a default or <code style="background-color:inherit;font-size:medium">abstract</code> method in a superinterface of <em>C</em>.  We say the superclass method overrides the superinterface method <i>from <em>C</em></i>.  In contrast, an inherited interface method never overrides any methods other than those already overridden at its declaration site.
</p><p>It is a compile-time error if <em>I</em> or <em>C</em> inherits a default method whose signature is override-equivalent with another method inherited by <em>I</em>. This is the case whether the other method is <code style="background-color:inherit;font-size:medium">abstract</code> or not.
</p><p>This error condition can be avoided by declaring a new method that overrides, and thus prevents the inheritance of, all conflicting methods.
</p><p>An overridden default method can be accessed by using a method invocation expression of the form <code style="background-color:inherit;font-size:medium"><em>InterfaceName</em>.super.<em>m</em>()</code>.  The named interface must be a direct superinterface of the type declaration immediately enclosing the expression.
</p><p>A <code style="background-color:inherit;font-size:medium">this</code> expression may appear in a default method body; its type is the type of the enclosing interface.  Similarly, an anonymous or local class may be declared in a default method body, so the enclosing instance of an inner class may have an interface type.
</p><p>To avoid confusion with the <code style="background-color:inherit;font-size:medium">default</code> modifier, the access level given implicitly to unmodified declarations in classes is now referred to as <i>package</i> access rather than <i>default</i> access.
</p>
<h4> <span class="mw-headline" id="Part_J"> <a href="J.html" title="Lambda J" class="mw-redirect">Part J</a> </span></h4>
<p>Changes to the Java Virtual Machine are necessary to support the implementation of default methods.  Methods declared in interface class files need not be declared <code style="background-color:inherit;font-size:medium">abstract</code>, and thus can carry a <code style="background-color:inherit;font-size:medium">Code</code> attribute.  Methods declared in interface class files may also be <code style="background-color:inherit;font-size:medium">private</code> or <code style="background-color:inherit;font-size:medium">static</code>.  The <code style="background-color:inherit;font-size:medium">invokespecial</code> and <code style="background-color:inherit;font-size:medium">invokestatic</code> instructions may refer to interface methods.  The rules for method resolution and invocation (via <code style="background-color:inherit;font-size:medium">invokeinterface</code>, <code style="background-color:inherit;font-size:medium">invokespecial</code>, <code style="background-color:inherit;font-size:medium">invokestatic</code>, and <code style="background-color:inherit;font-size:medium">invokevirtual</code>) are enhanced to support execution of code in interfaces.
</p>
<h2> <span class="mw-headline" id="Change_Log"> Change Log </span></h2>
<h4> <span class="mw-headline" id="0.9.3"> 0.9.3 </span></h4>
<p>Method References: Renumbered the Method Reference Expressions section 15.13 (to make room, the JLS 7 15.13 will be merged with a previous section).
</p><p>Typing and Evaluation: Added changes to 6.6.2 to clarify accessibility of references to <code style="background-color:inherit;font-size:medium">protected</code> methods.
</p><p>Type Inference: Bug fix for subtyping constraints involving the null type.  Added rule to invocation typing for lifting constraints on nested invocation arguments that are lambdas/method references into the enclosing inference context.
</p>
<h4> <span class="mw-headline" id="0.9.2"> 0.9.2 </span></h4>
<p>Overload Resolution: Used a simpler, equivalent definition of "reference expression" for the purpose of more-specific method testing.
</p><p>Type Inference: Cleaned up handling of intersection types in 18.2.4 and 18.5.4.  Simplified discussion in 18.2.1.1.
</p>
<h4> <span class="mw-headline" id="0.9.1"> 0.9.1 </span></h4>
<p>Introduction: Added brief discussions about exception transparency and speculative checking during overload resolution.
</p><p>Method References: Removed the <code style="background-color:inherit;font-size:medium">TypeName::m</code> form of unbound method reference, which turned out to be unnecessary and introduced many complications.
</p><p>Poly Expressions: Added a note clarifying that poly conditionals do not have to contain poly expressions.
</p><p>Typing and Evaluation: Removed mentions of the <code style="background-color:inherit;font-size:medium">TypeName::m</code> method reference form.  Allowed raw inner class types to be used in exact constructor references (because diamond inference cannot occur).
</p><p>Overload Resolution: Eliminated unnecessary uses of the qualifier "poly" in discussions of conditional expressions.
</p><p>Type Inference: Modified exception checking constraints so that they only exist for <em>LambdaExpressions</em> and <em>MethodReferences</em> (these constraints were previously generated for all other forms of expressions, and then trivially reduced to <em>true</em>).
</p><p>Default Methods: Tweaked inheritance rule for interfaces so that a static/non-static clash would be properly detected.
</p><p>Java Virtual Machine: Clarified that only 52.0 class files can allow <code style="background-color:inherit;font-size:medium">InterfaceMethodrefs</code> in method references of the kind <code style="background-color:inherit;font-size:medium">invokeStatic</code> and <code style="background-color:inherit;font-size:medium">invokeSpecial</code>.
</p>
<h4> <span class="mw-headline" id="0.9.0"> 0.9.0 </span></h4>
<p>Functional Interfaces: Introduced the term <i>non-wildcard parameterization</i> as an intermediate step when deriving a function type.  Clarified when intersection types are used.  Cleanup of some old discussion.
</p><p>Lambda Expressions: Cleanup of some old discussion.
</p><p>Method References: Prohibited use of constructor type arguments with diamond inference.  Separated <code style="background-color:inherit;font-size:medium">TypeName::m</code> and <code style="background-color:inherit;font-size:medium">ReferenceType::m</code> as two distinct grammatical forms.
</p><p>Poly Expressions: Grammatical changes so that a <em>LambdaExpression</em> is no longer a <em>Primary</em>, in order to address ambiguities.
</p><p>Typing and Evaluation: Introduced the <i>ground target type</i> as an intermediate step towards deriving a function type.  Checked that there are no overriding errors when the lambda or method reference overrides the methods of this type.  Described exactly which methods are overridden, and which (erasure-based) casts occur at runtime.  Accommodated the additional <code style="background-color:inherit;font-size:medium">TypeName::m</code> syntactic form of a method reference.  Described how references to signature-polymorphic methods are handled.  Added new changes to 13.1 to account for method references.
</p><p>Overload Resolution: Asserted that, for a more-specific test of two functional interfaces targeted by an exact method references, the parameter types are the same.  Cleaned up the rules for deriving the actual target types of invocation arguments when unchecked conversion was necessary.
</p><p>Type Inference: Mirrored the changes in Parts E and F.  Clarified how inference variables in a wildcard-parameterized target type of an explicitly-typed lambda expression are handled, and cleaned up the section describing functional interface parameterization inference.  Clarified how subtyping and equality constraints handle non-parameterized inner classes of parameterized types.  Added an incorporation rule to check consistency of parameterized upper bounds.  Cleaned up the treatment of <code style="background-color:inherit;font-size:medium">? extends Object</code>, which should be equivalent to <code style="background-color:inherit;font-size:medium">?</code>.  Added some overlooked resolution dependencies on capture inference variables.  Added rules to invocation type inference to special-case when the return type is an inference variable, and may end up either being wildcard-parameterized or requiring unchecked conversion.  Explicitly moved the definition of <em>lub</em> to 4.10.4.
</p><p>Default Methods: Prohibited invoking a static interface method with an expression qualifier.
</p>
<h4> <span class="mw-headline" id="0.8.0"> 0.8.0 </span></h4>
<p>Poly Expressions: Prohibited arrays in intersection casts.
</p><p>Typing and Evaluation: Made lambdas incompatible with generic targeted function types.  Performed capture before the method reference method search.  Avoided diamond inference for inner classes of raw types.  Defined method references requiring inference as inexact.  Specified unchecked warnings for method reference assignment.  Added lambdas and method references to 15.7.5.
</p><p>Overload Resolution: Clarified the invocation type of the <code style="background-color:inherit;font-size:medium">getClass</code> method.  Clarified that unchecked invocation does not cause target parameter types to be erased.
</p><p>Type Inference: No longer require a bound set as input to reduction.  Allowed narrowing of primitive constants in lambda bodies.  Clarified when unchecked conversion occurs during inference.  Cleaned up reduction of containment/equality constraints involving wildcards.  Fixed minor notational problems.
</p><p>Default Methods: Added the runtime behavior of default method invocation (15.12.4.4).  Defined <i>concrete</i> methods.  Updated the definition of hiding (by static methods), consistent with previous changes to overriding.  Clarified that <code style="background-color:inherit;font-size:medium">TypeName.super</code> cannot be used to refer to a type variable.  Clarified that the type to search, for <code style="background-color:inherit;font-size:medium">InterfaceName.super</code>, is provided by the <code style="background-color:inherit;font-size:medium">implements</code> clause.
</p><p>Java Virtual Machine: Allowed <code style="background-color:inherit;font-size:medium">invokeStatic</code> and <code style="background-color:inherit;font-size:medium">invokeSpecial</code> MethodHandles to use <code style="background-color:inherit;font-size:medium">InterfaceMethodrefs</code>.  Prohibited <code style="background-color:inherit;font-size:medium">static</code> and non-<code style="background-color:inherit;font-size:medium">public</code> methods of class <code style="background-color:inherit;font-size:medium">Object</code> from being the resolution of an <code style="background-color:inherit;font-size:medium">InterfaceMethodref</code>.
</p>
<h4> <span class="mw-headline" id="0.7.0"> 0.7.0 </span></h4>
<p>Typing and Evaluation: Added a paragraph for the Java Object Serialization Specification.  Cleaned up presentation of method reference resolution logic.
</p><p>Overload Resolution: Ensured that, in most-specific testing, all varargs parameter types are considered, even when there are 0 varargs arguments.
</p><p>Type Inference: Provided full rules for "more specific method" inference.  Backed off of approach to unchecked conversion inference, and specified when unchecked conversions are allowed by reduction.  In resolution, adjusted to perform lub only on proper types.
</p><p>Default Methods: Added a discussion about binary compatibility to Chapter 13.
</p><p>Java Virtual Machine: Fixed text in method resolution to properly ignore <code style="background-color:inherit;font-size:medium">static</code> and <code style="background-color:inherit;font-size:medium">private</code> methods in superinterfaces.
</p>
<h4> <span class="mw-headline" id="0.6.3"> 0.6.3 </span></h4>
<p>Functional Interfaces: Renamed the term <i>function descriptor</i> to <i>function type</i> (undoing the previous renaming of <i>functional interface type</i> to <i>function type</i>).  Cleaned up the conditions under which an intersection type can be considered a functional interface type.  Addressed a negative interaction of wildcards with derivation of a function type.
</p><p>Lambda Expressions: Introduced the terms <i>explicitly-typed lambda</i> and <i>implicitly-typed lambda</i>.  Changed treatment of "_" to allow it as a name in non-lambda contexts (noting the possibility of future deprecation).
</p><p>Typing and Evaluation: Introduced the terms <i>exact method reference</i> and <i>inexact method reference</i>.  Removed the compatibility condition for lambda expressions that their body not contain errors.  Introduced a section detailing the process of identifying a compile-time declaration for a method reference (distinct from testing for compatibility).  Adjusted resolution of an unbound/static method reference to be less brittle.
</p><p>Overload Resolution: Asserted that arguments involving implicitly-typed lambdas and inexact method references are not <i>pertinent to applicability</i>; they are only checked for arity during overload resolution.  (This replaces the approach of considering some methods to be only <i>provisionally applicable</i>.)  Minimized the changes to most-specific analysis, so that extra (non-subtyping) work is only done when two functional interfaces are compared and correspond to an explicitly-typed lambda or an exact method reference.  Adjusted potential applicability of an unbound/static method reference to be less brittle.  Made the accessibility of a varargs type a post-resolution check.
</p><p>Type Inference: Added new bounds to represent capture variables and variables that appear in <code style="background-color:inherit;font-size:medium">throws</code> clauses, and described their impact on incorporation and resolution.  Eliminated the notion of "delayed constraints".  Defined special reduction rules for exact method references.  Described reduction of <code style="background-color:inherit;font-size:medium">throws</code> constraints.  Described how invocation type inference handles sequencing of reduction for constraints on arguments that are not pertinent to applicability, as well as <code style="background-color:inherit;font-size:medium">throws</code> constraints (interleaved with resolution of variables, as needed).  Made use of capture bounds during invocation type inference.
</p><p>Default Methods: Prohibited static and default methods from the body of annotation type declarations (<code style="background-color:inherit;font-size:medium">@interface</code>s).
</p><p>Java Virtual Machine: Introduced the term <i>maximally-specific superinterface methods</i> for use in resolution and selection.  Adjusted resolution to be more flexible and to ignore <code style="background-color:inherit;font-size:medium">static</code> and <code style="background-color:inherit;font-size:medium">private</code> methods in superinterfaces.  Prohibited <code style="background-color:inherit;font-size:medium">invokespecial</code> from referring to indirect superinterfaces.  Cleaned up the selection logic of <code style="background-color:inherit;font-size:medium">invokespecial</code>.  Clarified how the changes affect older class files.  Adjusted definition of overriding to be consistent with actual behavior in VMs.
</p>
<h4> <span class="mw-headline" id="0.6.2"> 0.6.2 </span></h4>
<p>Functional Interfaces: Renamed the term <i>functional interface type</i> to just <i>function type</i>, to avoid the assumption that intersection types are excluded from this set.  Defined the descriptor of a raw functional interface type.  Minor fixes in examples to reflect actual compiler behavior.  Adjusted the definition of return-type substitutability to reflect actual compiler behavior.
</p><p>Lambda Expressions: Small change to the scoping rules of local classes to avoid confusion.
</p><p>Method References: Added a number of well-formedness checks for method references (some new, some previously covered by the compatibility definition).  Adjusted terminology so that "method references" refers generally to both "constructor references" and "array creation references".
</p><p>Poly Expressions: Incorporated above terminology changes.  Added section 15.29, which is just a renumbering of 15.28.
</p><p>Typing and Evaluation: Added a lambda compatibility rule that errors do not occur in the lambda body.  Made the check for static-ness of a referenced method a post-compatibility error.  Removed mention of "synthetic" classes and methods, to clarify that the ACC_SYNTHETIC flag is not mandated.  Unified the presentation of "compile-time declarations"/runtime behavior for standard method references, constructor references, and array creation references—the latter two are based on "notional methods" that represent class instance creation or array creation.  Moved the error check for exceptions in lambda bodies to 11.2.3.
</p><p>Overload Resolution: Changed definition of "potentially compatible" for method references to exclude cases in which there are no method declarations of the desired arity.  Defined provisionally-applicable methods to <i>never</i> be more specific rather than <i>always</i> more specific (the outcome should be the same, though).  Unified the presentation of "more specific" for fixed-arity and variable-arity methods.
</p><p>Type Inference: Specified reduction for subtyping and equality constraints.  Specified incorporation.  Specified resolution.  Updated reduction rules for lambdas and method references to track changes in "Typing and Evaluation."  Adjusted terminology so that "bound" refers to all of "proper bounds", "dependencies", and "delayed constraint formulas".  Made tweaks to the notation for constraint formulas and bounds.
</p><p>Default Methods: Removed support for an explicit <code style="background-color:inherit;font-size:medium">package</code> access modifier.  Refined the definition of overriding to more accurately represent the intended behavior when the overriding method is inherited (mostly to account for package-access methods).
</p><p>Java Virtual Machine: Changed the representation of methods declared in interfaces and passed to invokespecial/invokestatic from a Methodref to an InterfaceMethodref.  Rolled back changes that were intended to support Methodref structures that point to methods declared in interfaces.
</p>
<h4> <span class="mw-headline" id="0.6.1"> 0.6.1 </span></h4>
<p>Functional Interfaces: Renamed the <code style="background-color:inherit;font-size:medium">@Functional</code> annotation to <code style="background-color:inherit;font-size:medium">@FunctionalInterface</code>.
</p><p>Typing and Evaluation: Clarified the unpredictable semantics of operators like <code style="background-color:inherit;font-size:medium">==</code> when applied to the value produced by a lambda expression or method reference.
</p><p>Type Inference: Described enhanced analysis for nested generic method invocations, which involves additional forms of dependencies.  Described <i>delayed constraints</i> and defined the conditions under which they are produced by lambda expressions and method references.  As a simplification, eliminated context type from the compatibility constraint formulas.  Defined reduction for poly conditional expressions.  Revised inference process for instantiating wildcard-parameterized functional interface targets.
</p><p>Default Methods: Eliminated support for <code style="background-color:inherit;font-size:medium">synchronized</code> methods in interfaces.
</p><p>Java Virtual Machine: Adjusted the definition of Methodref_info to allow for methods in interfaces.  Adjusted restrictions on modifiers for interface methods.  Revised resolution rules and specification for <code style="background-color:inherit;font-size:medium">invokevirtual</code>.  Introduced adjustments to <code style="background-color:inherit;font-size:medium">invokespecial</code> and <code style="background-color:inherit;font-size:medium">invokestatic</code> to support interface methods.
</p>
<h4> <span class="mw-headline" id="0.6.0"> 0.6.0 </span></h4>
<p>Overall: Split Part F into Part F, Overload Resolution and Part G, Type Inference.  Split the old Part G into Part H, Default Methods and Part J, Java Virtual Machine.
</p><p>Functional Interfaces: Defined intersections as a kind of functional interface type.  Defined the descriptor of wildcard-parameterized types.  Added the <code style="background-color:inherit;font-size:medium">@Functional</code> annotation.
</p><p>Lambda Expressions: Added the <code style="background-color:inherit;font-size:medium">_</code> keyword and the <code style="background-color:inherit;font-size:medium">-&gt;</code> operator to the grammar.
</p><p>Method References: Added qualified <code style="background-color:inherit;font-size:medium">super</code> references.  Added array constructor references.  Added the <code style="background-color:inherit;font-size:medium">::</code> separator to the grammar.
</p><p>Poly Expressions: Allowed casts to intersection types.  Refined the conditions under which a method invocation is considered a poly expression.  Introduced rules for classifying and typing conditional expressions.
</p><p>Typing and Evaluation: Refined the presentation of inference of wildcard-parameterized type instantiations.  Allowed arbitrary statement expressions in lambda bodies targeting a <code style="background-color:inherit;font-size:medium">void</code> return.  Always interpret lambda returns in an assignment context.  Defined runtime behavior when targeting an intersection functional interface type.  Eliminated support for unbound inner class constructor references.  Added support for qualified <code style="background-color:inherit;font-size:medium">super</code> references and array constructor references.  Restricted supported forms of static method references.
</p><p>Overload Resolution: Defined <i>potentially applicable</i> for methods with functional interface parameter types targeted by lambda expressions.  Revised <i>most specific method</i> analysis to consider the invocation argument expressions, compare descriptors of functional interface types, and minimize boxing/unboxing.
</p><p>Type Inference: Added a stub for <i>most specific method inference</i>.
</p><p>Default Methods: Modified syntax, treating <code style="background-color:inherit;font-size:medium">default</code> as a method modifier.  Added support for static interface methods.  Refined the inheritance rules for default and abstract methods.  Enclosing instances of inner classes can be interfaces.  Added support for the <code style="background-color:inherit;font-size:medium">package</code> access modifier.
</p>
<h4> <span class="mw-headline" id="0.5.1"> 0.5.1 </span></h4>
<p>Introduction: Revised and added to the discussion of future enhancements.
</p><p>Lambda Expressions: To allow void method invocations as expression lambda bodies, restricted the void-/value-compatible distinction to block bodies.  Refined the definition of <i>effectively final</i> to conform with the JLS 7 bug fixes to the rules for <code style="background-color:inherit;font-size:medium">final</code> variables.  Added a note in the section on <code style="background-color:inherit;font-size:medium">this</code> that lambda expressions do not introduce a new <code style="background-color:inherit;font-size:medium">this</code> scope.
</p><p>Method and Constructor References: Added <code style="background-color:inherit;font-size:medium">super</code> method references.
</p><p>Typing and Evaluation: Adjusted lambda compatibility rules to support <code style="background-color:inherit;font-size:medium">void</code> method invocations as lambda expression bodies.  Adjusted method reference compatibility rules to support <code style="background-color:inherit;font-size:medium">super</code> method references.  Clarified that class type arguments in a constructor reference can be inferred.  Described the details of method and constructor reference evaluation, in particular how the reference is interpreted as an invocation.
</p><p>Type Inference: Updated lambda compatibility inference rules consistent with the changes to support <code style="background-color:inherit;font-size:medium">void</code> method invocations.  Added examples and discussion.
</p><p>Default Methods: Allowed <code style="background-color:inherit;font-size:medium">this</code> to appear in the body of a default method.  Added discussion on <code style="background-color:inherit;font-size:medium">super</code> method invocations.
</p>
<h4> <span class="mw-headline" id="0.5.0"> 0.5.0 </span></h4>
<p>Overall: Introduced the above "Summary" section, providing a digestible review of the contents of each part.  Formatted to support each part as a separate HTML document.  Added the above "Unfinished Items" section, and removed most other design discussions that speculated on future changes.  These enhancement ideas are recorded and discussed elsewhere, leaving the spec document to act as a more stable baseline.  Minor rephrasing and presentation cleanup throughout.
</p><p>Functional Interfaces: Backed out of a flawed attempt to rewrite 8.4.6 in a way that minimized the use of erasure.
</p><p>Lambda Expressions: Eliminated syntax supporting generic lambda expressions, which was intrusive.  Settled on a strategy in which generic functional interfaces are supported, but cannot be instantiated by lambda expressions; they can still be instantiated by method references.  Removed support for recursive lambdas and associated changes to the definite assignment rules.  Removed orphaned discussion of <code style="background-color:inherit;font-size:medium">Void</code> as a return type (the related feature was already removed in 0.4.2).  Updated rules about lambda parameters to mimic 8.4.1 in JLS 7.  Updated rules about scope and shadowing to match changes in JLS 7, which handles all these rules in 6.3 and 6.4.  Added lambda parameters to 4.12.3.
</p><p>Poly Expressions: Merged the previous "Conversions and Contexts" part with the first half of the previous "Poly Expressions".  This part now includes all discussion about contexts and poly expressions, except for the compatibility and typing rules for lambdas and method references.  Updated 5.4 to match changes in JLS 7.  Eliminated special grammar rules for handling generic lambda expressions.
</p><p>Typing and Evaluation: Merged the second half of the previous "Poly Expressions" part with new material on lambda expression and method reference evaluation.  Improved the compatibility definitions and clarified their interface with type inference in the case in which the target type has wildcards.
</p><p>Type Inference: Added this part.
</p><p>Default Methods: Added this part.
</p>
<h4> <span class="mw-headline" id="0.4.2"> 0.4.2 </span></h4>
<p>Lambda Expressions: Removed rules that support treatment of <code style="background-color:inherit;font-size:medium">void</code> lambda bodies as implementations of methods that return <code style="background-color:inherit;font-size:medium">Void</code>; expanded the accompanying discussion about the possible approaches.
</p><p>Poly Expressions: Removed compatibility rules allowing <code style="background-color:inherit;font-size:medium">void</code> lambda bodies or method references in contexts that require a <code style="background-color:inherit;font-size:medium">Void</code> return type.
</p>
<h4> <span class="mw-headline" id="0.4.1"> 0.4.1 </span></h4>
<p>Functional Interfaces: Allowed generic methods, and added corresponding examples.  Revised "return type substitutable" and related tests to take into account alpha-equivalent type parameters.
</p><p>Lambda Expressions: Updated the syntax to the C#/Scala style.  Added syntax for and a section addressing lambda type parameters.  Further discussion about parsing.  Renumbered to section 15.27.  Prohibited shadowing with lambda parameters.  Allowed local classes to capture effectively-final variables.
</p><p>Method and Constructor References: Updated the syntax (noting that it is still subject to change).  Added discussion about parsing.  Renumbered to section 15.28.
</p><p>Conversions and Contexts: Swapped the order with "Poly Expressions" (making this Part D) and moved the material about expression compatibility rules into the Poly Expressions part (now Part E).  Revised introductory discussion to explicitly define "target type" and clarify that poly expressions and implicit conversions are different, complementary features.  De-emphasized the "compatibility" terminology, eliminating the need for many of the modifications in previous versions.  Reverted section numbers to those in the JLS.
</p><p>Poly Expressions: Eliminated the <i>PolyExpression</i> grammar production; lambda expressions and method references as syntactically primaries, and appropriate context is checked as a semantic rather than syntactic restriction.  Added grammar rules to prevent generic lambdas after casts.  Revised some section numbering, introducing a general discussion of expressions and poly expressions in 15.2.  Eliminated the <i>poly context</i> terminology, relying instead on the existing context concepts from Chapter 5.  Stopped designating constant expressions as poly expressions, instead relying on the old conversion semantics for implicit constant narrowing.  Revised method reference search to allow instance method references to get the receiver's type parameters from the target type.
</p><p>Appendix: Eliminated the need for changes to the grammar throughout the JLS that made up the bulk of the former appendix.
</p>
<h4> <span class="mw-headline" id="0.4.0"> 0.4.0 </span></h4>
<p>Overall: Reformatted as HTML with extensive links.
</p><p>Functional Interfaces: Renamed "SAM types"; redefined this property in terms of declarations rather than type instantiations.  Eliminated a dependency on the particulars of return-type-substitutability.  Ensured that the interface can be generically overridden, but avoided attempts to make guarantees about type instantiations.
</p><p>Lambda Expressions: Updated discussion on syntax.
</p><p>Conversions and Contexts: Added note about making method reference parameter type compatibility more strict in strict invocation contexts.
</p>
<h4> <span class="mw-headline" id="0.3.5"> 0.3.5 </span></h4>
<p>Overall: Promoted the "to discuss" section to a summary of unresolved questions in the document.  Added Part C, Method References (subsequent parts were renamed).  Added an appendix, Part Z, to hold negligible changes that are distracting in the main body of the text.  Added discussion of potential future enhancements at the end of the document.
</p><p>SAM Types: Adjusted the definition of "SAM type" for wildcard-parameterized types to use capture; made the corresponding descriptor undefined.  Adjusted the criteria under which an Object method is disregarded.  Added a check that some abstract method of a SAM type is return-type-substitutable for all others (not guaranteed when type arguments are applied).  Added more examples involving generic SAM types.  Altered the return-type-substitutable definition to more closely match implementations' behavior.
</p><p>Lambda Expressions: Added more discussion about syntax alternatives.  Moved <code style="background-color:inherit;font-size:medium">Void</code> return description in 14.2 to Part F.  Extended discussion about the possibility of return type boxing via overriding and bridge methods.  Noted that the handling of shadowing rules is incomplete.
</p><p>Poly Expressions: Added method references as an additional kind of poly expression.  Added discussion about chained inference.  Moved many grammar production renamings into the appendix.
</p><p>Conversions and Contexts: Moved some of the adjustments to the casting conversion text into the appendix.  Revised compatibility rules for lambda expressions.  Introduced compatibility rules for method references.
</p>
<h4> <span class="mw-headline" id="0.3.4"> 0.3.4 </span></h4>
<p>Introduction: Added a reference list of optional non-lambda changes that should be discussed.  Added Part E, Lambda Expression Evaluation.
</p><p>SAM Types: Added examples and discussion involving generic interfaces.  Added more examples of SAM descriptor thrown types.
</p><p>Lambda Expressions: Made effectively final references from inner classes an optional revision (moving it into discussion).  Also made implicit returns to Void in method bodies optional, and specified handling of returns to Void when the body completes normally.  Moved the <i>effectively final</i> definition into 4.12.4.  Adjusted the restriction on <code style="background-color:inherit;font-size:medium">break</code> and <code style="background-color:inherit;font-size:medium">continue</code> labels to better integrate with existing text.
</p>
<h4> <span class="mw-headline" id="0.3.3"> 0.3.3 </span></h4>
<p>SAM Types: Removed support for SAM class types.  Moved the specification to Chapter 9 (Interfaces).  Clarified the definition of SAM type.  Restricted the set of abstract methods that "don't count" in interfaces to the methods of Object that are defined to be implicit members (9.2).  Improved SAM type examples.  Simplified SAM descriptor definition and eliminated any use of order of methods (see discussion).  Added discussion about accessibility.  Added discussion about additional considerations if abstract classes were allowed.
</p><p>Lambda Expressions: Made "final" and "effectively final" mutually exclusive.  Clarified the discussion about meaning of names and dependencies on type checking.  Prohibited mixing value and void returns in a method.  Added new changes for sections 9.3.1 and 12.5.  Deferred treatment of the interaction between SAM types and lambdas to later sections.
</p>
<h4> <span class="mw-headline" id="0.3.2"> 0.3.2 </span></h4>
<p>SAM Types: Added discussion about method order and about generic methods.  Added SAM descriptor examples.  Small additional comments and cleanup.
</p>
<div id="future"></div>
<h2> <span class="mw-headline" id="Potential_Future_Enhancements"> Potential Future Enhancements </span></h2>
<p>The following have been determined to be outside the scope of JSR 335.  While there are no concrete plans to do so, it is possible that they might be considered as enhancements to the JSR 335 features in a future iteration of the Java Programming Language.
</p>
<h3> <span class="mw-headline" id="Functional_Classes"> Functional Classes </span></h3>
<p>It would be possible to treat certain abstract classes that have a single abstract method as lambda expression targets, like functional interfaces.  Good examples from the Java SE API are <code style="background-color:inherit;font-size:medium">java.util.TimerTask</code>, <code style="background-color:inherit;font-size:medium">javax.swing.InputVerifier</code>, <code style="background-color:inherit;font-size:medium">javax.swing.SwingWorker</code>, and <code style="background-color:inherit;font-size:medium">javax.swing.AbstractAction</code>.
</p><p>This is best handled in the current framework by creating a subclass with a constructor that takes a functional interface—the <code style="background-color:inherit;font-size:medium">Thread(Runnable)</code> constructor essentially does this, although it is not designed very cleanly.  Arguably, the strategy of delegating to a functional-interface-typed field rather than an abstract method ought to be the preferred approach when new APIs are developed, and so there would be much less need to declare functional classes.  (On the other hand, anonymous inner classes that implement abstract methods have more convenient access to the members of the superclass.)
</p><p>The biggest reason that functional classes have been avoided is that defining a synthetic class that extends an arbitrary class is much more difficult and constraining than defining a synthetic class that implements an arbitrary interface: the superclass may have an enclosing instance; the superclass constructor may have parameters; the superclass may have inaccessible abstract methods or constructors.  Most significantly, the superclass constructor can execute arbitrary code and throw arbitrary (possibly even checked) exceptions.  This conflicts with our design goal of allowing implementations freedom regarding when and how often instances of these synthetic classes are created.
</p>
<h3> <span class="mw-headline" id="Standalone_Lambda_Expressions_.26_Structural_Function_Types"> Standalone Lambda Expressions &amp; Structural Function Types </span></h3>
<p>In contexts that do not provide a target type, it would be possible to treat the value of a lambda expression as a special object with a <i>structural function type</i>.  Such values could later be applied directly, converted to functional interface instances, or, if structural function types are denotable, assigned to a variable.
</p><p>Structural function types are difficult for users because they introduce a new category of structural type syntax that everyone has to understand.  If the types are erased, their usefulness is limited by clashes that arise when declaring overloaded methods.  Structural function types are difficult for the specification and implementation because the entire type system has to be adjusted to take into account the existence of a new kind of type.
</p>
<h3> <span class="mw-headline" id="Nonlocal_Control_Flow"> Nonlocal Control Flow </span></h3>
<p>The body of a lambda expressions is evaluated as an <i>expression</i> (as a method invocation, to be precise), meaning that ultimately the evaluation either completes—possibly producing a value—or throws an exception.
</p><p>There are many interesting applications that involve evaluating a lambda-like abstraction as a <i>statement</i>.  This would allow evaluation of the body to have other effects, such as returning (rather than <i>producing</i>) a value or breaking out of a loop.  See <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.1" class="external text" rel="nofollow">14.1</a> for the comprehensive list of possible effects of statement execution.  These effects, when triggered by evaluation of a lambda-like abstraction, can be termed "nonlocal," because the code that describes them appears in a different location than the code that triggers them.  As an example, a <code style="background-color:inherit;font-size:medium">for</code> loop could be re-expressed as a call to a library method that takes as input a lambda-like abstraction; the body of the library method invokes its input as a statement, and the effects of doing so may cause the library method to terminate.
</p><p>This is a more ambitious and less well-understood problem domain than the approach we take of evaluating lambda bodies as method invocations.  It is a less-natural fit for the existing language.
</p>
<h3> <span class="mw-headline" id="Capture_of_Mutable_Variables"> Capture of Mutable Variables </span></h3>
<p>Lambda expressions can only refer to local variables and parameters from the surrounding scope if those variables are <i>effectively final,</i> meaning that their values never change.  This allows the variable to be "captured" for later use as a value rather than a variable.
</p><p>It might seem awkward to be unable to, say, keep a tally of the number of times a lambda body is invoked by incrementing a local variable.  However, if different threads invoke the body at the same time, it is very easy for concurrency bugs to manifest themselves.  To responsibly facilitate that kind of behavior in the language, we would prefer to provide some sort of static analysis that helps to prevent concurrency bugs.
</p><p>On the other hand, a safer and cleaner approach to solving problems like this is to avoid mutation of shared variables.  The current language restrictions encourage those kinds of solutions.
</p>
<h3> <span class="mw-headline" id="Special_Exception_Checking_for_Lambda_Body_Invocations"> Special Exception Checking for Lambda Body Invocations </span></h3>
<p>A checked exception thrown by a lambda body should be identified by the type system wherever the corresponding method is invoked.  This is supported in a limited way by allowing functional interface methods to have <code style="background-color:inherit;font-size:medium">throws</code> clauses—then, naturally, the method invocation knows what exceptions may be thrown.  It is also possible to use a type parameter of a functional interface in the <code style="background-color:inherit;font-size:medium">throws</code> clause, thus allowing a thrown exception type to be inferred (by, say, the invocation of a library method that accepts a lambda argument).
</p><p>However, generics are not well-suited to the problem of representing the exceptions thrown by a block of code.  In the common case (zero checked exceptions), an extra type parameter is a painful clerical burden (for example, <code style="background-color:inherit;font-size:medium">Function&lt;String, Number&gt;</code> becomes <code style="background-color:inherit;font-size:medium">Function&lt;String, Number, RuntimeException&gt;</code>).  And in cases in which multiple exceptions are thrown, there is no way to provide a list of types as a type argument.  Even with workarounds for these problems, it is difficult to write lambda-friendly library code that properly accounts for all the exception types thrown by the provided lambda bodies.
</p><p>A more ambitious solution would be to special-case the treatment of lambdas in the compiler's exception checking logic, detecting the locations in which the checked exceptions of a lambda body may manifest themselves <i>without</i> relying on the <code style="background-color:inherit;font-size:medium">throws</code> clause of the functional interface.  This would eliminate any clerical burden on programmers, while still providing strong exception checking; but it would require the compiler to perform advanced analysis techniques.
</p>
<h3> <span class="mw-headline" id="Speculative_Type_Checking_During_Overload_Resolution"> Speculative Type Checking During Overload Resolution </span></h3>
<p>Implicitly-typed lambda expressions (that is, lambdas with parameters that do not declare their types) and inexact method references (that is, references to overloaded or generic methods) cannot be type-checked before their parameter types are known.  These types are derived from the targeted functional interface type.  In the case of a method invocation argument (e.g., <code style="background-color:inherit;font-size:medium">m(x -&gt; x.foo())</code>), if the method being invoked is overloaded, there may be multiple possible target types, one for each overloaded method declaration.
</p><p>The approach developed here is to ignore the lambda expression or method reference until after overload resolution decides on the method to be invoked—the lambda argument is not <i>pertinent to applicability</i>.  Once overload resolution completes, the lambda body can be type-checked.
</p><p>Another possible approach is to type-check the lambda body or method reference <i>speculatively</i>, once for each possible target type.  This provides a more powerful disambiguation mechanism for overload resolution—the use of lambda parameters in the lambda body may clarify which parameter type was expected.  However, there are a number of challenges: users must consider multiple possible typings when reading a block of code; program behavior depends on subtle type errors; worst-case computational complexity is exponential.  And in some cases, it is still necessary to ignore lambda expressions during overload resolution, because the parameter types are inferred from the method invocation's own target type.
</p>
<h2> <span class="mw-headline" id="Legal_Notice"> Legal Notice </span></h2>
<p>Copyright © 2014 Oracle America, Inc.<br />
4150 Network Circle, Santa Clara, California 95054, U.S.A. All rights reserved.<br />
</p><p>NOTICE
</p><p>The Specification is protected by copyright and the information described therein may be protected by one or more U.S. patents, foreign patents, or pending applications. Except as provided under the following license, no part of the Specification may be reproduced in any form by any means without the prior written authorization of Oracle USA, Inc. ("Oracle") and its licensors, if any. Any use of the Specification and the information described therein will be governed by the terms and conditions of this Agreement.
</p><p>Subject to the terms and conditions of this license, including your compliance with Paragraphs 1 and 2 below, Oracle hereby grants you a fully-paid, non-exclusive, non- transferable, limited license (without the right to sublicense) under Oracle's intellectual property rights to:
</p><p>1. Review the Specification for the purposes of evaluation. This includes: (i) developing implementations of the Specification for your internal, non-commercial use; (ii) discussing the Specification with any third party; and (iii) excerpting brief portions of the Specification in oral or written communications which discuss the Specification provided that such excerpts do not in the aggregate constitute a significant portion of the Technology.
</p><p>2. Distribute implementations of the Specification to third parties for their testing and evaluation use, provided that any such implementation:
</p><p>(i) does not modify, subset, superset or otherwise extend the Licensor Name Space, or include any public or protected packages, classes, Java interfaces, fields or methods within the Licensor Name Space other than those required/authorized by the Specification or Specifications being implemented;
</p><p>(ii) is clearly and prominently marked with the word "UNTESTED" or "EARLY ACCESS" or "INCOMPATIBLE" or "UNSTABLE" or "BETA" in any list of available builds and in proximity to every link initiating its download, where the list or link is under Licensee's control; and
</p><p>(iii) includes the following notice: "This is an implementation of an early-draft specification developed under the Java Community Process (JCP) and is made available for testing and evaluation purposes only. The code is not compatible with any specification of the JCP."
</p><p>The grant set forth above concerning your distribution of implementations of the specification is contingent upon your agreement to terminate development and distribution of your "early draft" implementation as soon as feasible following final completion of the specification. If you fail to do so, the foregoing grant shall be considered null and void.
</p><p>No provision of this Agreement shall be understood to restrict your ability to make and distribute to third parties applications written to the Specification.
</p><p>Other than this limited license, you acquire no right, title or interest in or to the Specification or any other Oracle intellectual property, and the Specification may only be used in accordance with the license terms set forth herein. This license will expire on the earlier of: (a) two (2) years from the date of Release listed above; (b) the date on which the final version of the Specification is publicly released; or (c) the date on which the Java Specification Request (JSR) to which the Specification corresponds is withdrawn. In addition, this license will terminate immediately without notice from Oracle if you fail to comply with any provision of this license. Upon termination, you must cease use of or destroy the Specification.
</p><p>"Licensor Name Space" means the public class or interface declarations whose names begin with "java", "javax", "com.oracle" or their equivalents in any subsequent naming convention adopted by Oracle through the Java Community Process, or any recognized successors or replacements thereof.
</p><p>TRADEMARKS
</p><p>No right, title, or interest in or to any trademarks, service marks, or trade names of Oracle or Oracle's licensors is granted hereunder. Oracle, the Oracle logo, Java are trademarks or registered trademarks of Oracle USA, Inc. in the U.S. and other countries.
</p><p>DISCLAIMER OF WARRANTIES
</p><p>THE SPECIFICATION IS PROVIDED "AS IS" AND IS EXPERIMENTAL AND MAY CONTAIN DEFECTS OR DEFICIENCIES WHICH CANNOT OR WILL NOT BE CORRECTED BY ORACLE. ORACLE MAKES NO REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT THAT THE CONTENTS OF THE SPECIFICATION ARE SUITABLE FOR ANY PURPOSE OR THAT ANY PRACTICE OR IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADE SECRETS OR OTHER RIGHTS. This document does not represent any commitment to release or implement any portion of the Specification in any product.
</p><p>THE SPECIFICATION COULD INCLUDE TECHNICAL INACCURACIES OR TYPOGRAPHICAL ERRORS. CHANGES ARE PERIODICALLY ADDED TO THE INFORMATION THEREIN; THESE CHANGES WILL BE INCORPORATED INTO NEW VERSIONS OF THE SPECIFICATION, IF ANY. ORACLE MAY MAKE IMPROVEMENTS AND/OR CHANGES TO THE PRODUCT(S) AND/OR THE PROGRAM(S) DESCRIBED IN THE SPECIFICATION AT ANY TIME.  Any use of such changes in the Specification will be governed by the then-current license for the applicable version of the Specification.
</p><p>LIMITATION OF LIABILITY
</p><p>TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL ORACLE OR ITS LICENSORS BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION, LOST REVENUE, PROFITS OR DATA, OR FOR SPECIAL, INDIRECT, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF OR RELATED TO ANY FURNISHING, PRACTICING, MODIFYING OR ANY USE OF THE SPECIFICATION, EVEN IF ORACLE AND/OR ITS LICENSORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
</p><p>You will hold Oracle (and its licensors) harmless from any claims based on your use of the Specification for any purposes other than the limited right of evaluation as described above, and from any claims that later versions or releases of any Specification furnished to you are incompatible with the Specification provided to you under this license.
</p><p>RESTRICTED RIGHTS LEGEND
</p><p>If this Software is being acquired by or on behalf of the U.S. Government or by a U.S. Government prime contractor or subcontractor (at any tier), then the Government's rights in the Software and accompanying documentation shall be only as set forth in this license; this is in accordance with 48 C.F.R. 227.7201 through 227.7202-4 (for Department of Defense (DoD) acquisitions) and with 48 C.F.R. 2.101 and 12.212 (for non-DoD acquisitions).
</p><p>REPORT
</p><p>You may wish to report any ambiguities, inconsistencies or inaccuracies you may find in connection with your evaluation of the Specification ("Feedback"). To the extent that you provide Oracle with any Feedback, you hereby: (i) agree that such Feedback is provided on a non-proprietary and non-confidential basis, and (ii) grant Oracle a perpetual, non-exclusive, worldwide, fully paid-up, irrevocable license, with the right to sublicense through multiple levels of sublicensees, to incorporate, disclose, and use without limitation the Feedback for any purpose related to the Specification and future versions, implementations, and test suites thereof.
</p><p>GENERAL TERMS
</p><p>Any action related to this Agreement will be governed by California law and controlling U.S. federal law. The U.N. Convention for the International Sale of Goods and the choice of law rules of any jurisdiction will not apply.
</p><p>The Specification is subject to U.S. export control laws and may be subject to export or import regulations in other countries. Licensee agrees to comply strictly with all such laws and regulations and acknowledges that it has the responsibility to obtain such licenses to export, re-export or import as may be required after delivery to Licensee.
</p><p>This Agreement is the parties' entire agreement relating to its subject matter. It supersedes all prior or contemporaneous oral or written communications, proposals, conditions, representations and warranties and prevails over any conflicting or additional terms of any quote, order, acknowledgment, or other communication between the parties relating to its subject matter during the term of this Agreement. No modification to this Agreement will be binding, unless in writing and signed by an authorized representative of each party.
</p>


</body></html>
