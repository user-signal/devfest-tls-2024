<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>

    <title>Ferm√© pour inventaire</title>

    <meta name="description" content="Histoire et m√©canique des ¬´ closures ¬ª"/>
    <meta name="author" content="Fr√©d√©ric Cabestre"/>

    <link rel="stylesheet" href="./dist/reset.css">
    <link rel="stylesheet" href="./dist/reveal.css">
    <link rel="stylesheet" href="./dist/theme/transparents.css" id="theme"/>

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="./plugin/highlight/zenburn.css"/>
</head>

<body>
<div class="reveal">
    <div class="slides">

        <section>
            <h1>Ferm√© pour inventaire</h1>
            <h3>Histoire et m√©canique des ¬´ closures ¬ª</h3>
            <aside class="notes">
                Bonjour √† tous, et merci d'avoir choisi cette session dans laquelle il ne sera question ni de Kubernetes,
                ni d'IA... Quoique ?
            </aside>
        </section>

        <section>
            <div style="display: flex; justify-content: space-between">
                <div style="margin-left: 2em; display: flex; flex-direction: column">
                    <div style="margin-top: 1em; font-size: 1.55em; text-align: left" class="green">Fr√©d√©ric Cabestre</div>
                </div>
            </div>
            <blockquote style="margin-top: 8em; margin-right: 2em; margin-bottom: 100%">
                Soy cantor, soy embustero<br>
                Me gusta el juego y el vino, tengo alma de marinero<br>
                ¬øQu√© le voy a hacer si yo nac√≠ en el Mediterr√°neo?
                <div style="margin-top:1ex; font-size: smaller">&mdash; Juan Manuel Serrat</div>
            </blockquote>
<!--            <blockquote style="margin-top: 11.45em; margin-right: 2em; margin-bottom: 100%">-->
<!--                Le pr√©sent sans pass√© n'a pas d'avenir-->
<!--                <div style="font-size: smaller">&mdash; <a href="https://fr.wikipedia.org/wiki/Fernand_Braudel">Fernand Braudel</a></div>-->
<!--            </blockquote>-->
            <aside class="notes">
                Je suis Fr√©d√©ric Cabestre, un artisan du logiciel issu il y a fort longtemps du monde acad√©mique... Ce
                qui a laiss√© quelques traces. Si vous avez des soucis avec des sujets √©sot√©riques ou tout simplement besoin
                de faire accompagner une √©quipe de d√©veloppement, vous pouvez me contacter... Vous trouverez bien comment
                faire.
            </aside>
        </section>

        <section>
            <h1><span style="font-size:2em;text-transform:lowercase">$\lambda$</span></h1>
            <aside class="notes">
                Les fonctions d'ordre sup√©rieur (c'est-√†-dire dont les param√®tres sont des fonctions ou dont la valeur de
                retour peut √™tre une fonction) font d√©finitivement partie de l'outillage de base du d√©veloppeur.
                <br><br>
                Pour cel√† les fonctions sont devenues des entit√©s de premi√®re classe des langages de programmation. Autrement dit
                ce sont des valeurs √† part enti√®re que l'on peut par exemple affecter √† des variables.
                <br><br>
                Il n'est d'ailleurs m√™me plus n√©cessaire de les nommer pour pouvoir les d√©finir. Nous pouvons cr√©er des fonctions anonymes
                commun√©ment appel√©es ¬´ lambdas ¬ª.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px">
                                val aList = 1..100
                                val filteredList = aList.filter({ x -> x % 2 == 0 })
                                println(filteredList)

                                /*

                                  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
                                   28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50,
                                   52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
                                   76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100]

                                */
            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Cet attirail permet d'exprimer plus l'intention que la proc√©dure √† suivre. Par exemple ici en disposant d'une
                fonction ¬´ filter ¬ª sur des collections, √† laquelle on peut fournir un pr√©dicat, il n'est plus besoin de s'appesantir
                sur les d√©tails d'une it√©ration. La d√©marche est plus d√©clarative que proc√©durale.
                <br><br>
                Dans ce qui suit l'essentiel des exemples de code seront en Kotlin. J'aurais pu m'appuyer sur C#, Rust, Java
                ou Javascript... Non, quand m√™me pas Javascript ! Mais Kotlin c'est mon langage du moment, dont la lecture
                ne devrait pas vous troubler. Contrairement √†...
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="language-lisp" style="max-height: 800px">

                    (defun filter (fn list)
                        (cond ((null list) nil)
                              (t (cond ((funcall (eval fn) (car list)) (cons (car list) (filter fn (cdr list))))
                                       (t (filter fn (cdr list)))))))

                    (filter '(lambda (x) (= (mod x 2) 0)) '(1 2 3 4 5 6))

            </code><div class="lang">Lisp</div></pre>
            <aside class="notes">
                ... Common Lisp. Si Lisp va √™tre une sorte de fil rouge historique de cette pr√©sentation, je n'avais pas
                envie de vous perdre b√™tement en route. D'autant que, moi qui ai enseign√© en TP de Lisp √† la Fac il y a
                plus de 25 ans, j'en ai un peu bav√© pour √©crire cet exemple pourtant simple.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        public inline fun &lt;T&gt; Iterable&lt;T&gt;.filter(predicate: (T) -> Boolean): List&lt;T&gt; {
                            return filterTo(ArrayList&lt;T&gt;(), predicate)
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        public inline fun &lt;T&gt; <span class="ch">Iterable&lt;T&gt;</span>.filter(predicate: (T) -> Boolean): List&lt;T&gt; {
                            return filterTo(ArrayList&lt;T&gt;(), predicate)
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        public inline fun &lt;T&gt; Iterable&lt;T&gt;.filter(predicate: <span class="ch">(T) -> Boolean</span>): List&lt;T&gt; {
                            return filterTo(ArrayList&lt;T&gt;(), predicate)
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        aList.filter(<span class="ch">{ x -> x % 2 == 0 }</span>)

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Dans cet exemple la partie en surbrillance est donc une lambda prenant en param√®tre un entier et v√©rifiant
                s'il est pair (le reste de la division par 2 doit √™tre 0).
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        aList.filter({ x -> x % 2 == 0 })

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                      aList.filter({ x<span class="ch">: Int</span> -> x % 2 == 0 })

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Kotlin, comme beaucoup de langages aujourd'hui, dispose de capacit√©s d'inf√©rence de type. Ce qui permet
                dans une certaine mesure de s'√©conomiser quelques annotations de type.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        aList.filter({ x -> x % 2 == 0 })

            </code><div class="lang">Kotlin</div></pre>
            <pre class="fragment" style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        aList.filter({ <span class="ch">it</span> % 2 == 0 })

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Particularit√© de Kotlin, on peut dans certains cas, comme ici, nommer implicitement un param√®tre unique
                ¬´ it ¬ª.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        aList.filter({ x -> x % 2 == 0 })

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        aList.filter({ it % 2 == 0 })

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        aList.filter { it % 2 == 0 }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Et autre particularit√© de Kotlin, une lambda en derni√®re position des param√®tres d'une fonction peut √™tre
                sortie de la liste des param√®tres. C'est un emprunt √† Groovy, je crois, qui contribue √† faire de Kotlin
                un langage sympathique pour faire des DSL embarqu√©s... Mais √ßa sera l'objet d'une autre pr√©sentation.
                Qui sait ?
                <br><br>
                En tout √©tat de cause, cet exemple n'est pas des plus int√©ressants pour notre exploration...
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun longComputation(x: Int): Int {
                            return x * x // ü§°
                        }

                        fun parametricPredicate(x: Int, y: Int): Boolean {
                            val c = longComputation(x)
                            return y % c == 0
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre class="fragment" style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px">

                        fun main() {
                            val aList = 1..100
                            val filteredList = aList.filter { y -> parametricPredicate(3, y) }
                            println(filteredList)

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Consid√©rons plut√¥t celui-ci¬†: un pr√©dicat ajustable par son premier param√®tre ( ¬´ x ¬ª) pour v√©rifier une
                propri√©t√© du second param√®tre (¬´ y ¬ª). Et tant qu'√† faire, cet ajustement est le r√©sultat d'un calcul
                arbitrairement long effectu√© sur ¬´ x ¬ª.
                <br><br>
                Je vous l'accorde, c'est un exemple tir√© par le peu de cheveux qu'il me reste. Mais il faut faire simple
                pour parler de choses compliqu√©es.
                <br><br>
                Et si l'on veut utiliser ce pr√©dicat √† deux arguments, dans le m√™me contexte que pr√©c√©demment, il va
                falloir l'adapter, √† l'aide d'une fonction anonyme...
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun longComputation(x: Int): Int {
                            return x * x // ü§°
                        }

                        fun parametricPredicate(x: Int, y: Int): Boolean {
                            val c = longComputation(x)
                            return y % c == 0
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val filteredList = aList.filter <span class="ch">{ y -> parametricPredicate(3, y) }</span>
                            println(filteredList)

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                ... en fixant le premier argument pour le ramener √† un seul param√®tre √† tester.
                <br><br>
                Un inconv√©nient de cette approche est que ¬´ longComputation ¬ª sera effectu√©e √† chaque it√©ration de ¬´ filter ¬ª.
                <br><br>
                Une fa√ßon de r√©soudre ce probl√®me est de sortir ce long calcul de ¬´ parametricPredicate ¬ª. Mais j'ai envie
                de vous pr√©senter une autre approche qui serait de pouvoir appliquer partiellement ¬´ parametricPredicate ¬ª √†
                un argument. Et pour cela je dois vous parler de...
            </aside>
        </section>

        <section>
            <h1>Curryfication</h1>
            <aside class="notes">
                Ce terme est d√©riv√© du nom d'Haskell Curry, un logicien du 20·µâ si√®cle ayant men√© des travaux sur la logique
                combinatoire et qui donn√© son pr√©nom √† un c√©l√®bre langage fonctionnel. En r√©alit√© ce concept
                est plut√¥t d√ª √† Moses Sch√∂nfinkel, mais Sch√∂nfinkelification aurait √©t√© plus difficile √† prononcer.
                <br><br>
                Alors de quoi s'agit-il ?
            </aside>
        </section>

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;  display: grid; grid-template-rows: 2fr 1fr">
                <div style="margin-top: .5em; font-size: 2.11em">$f: (A, B) \rightarrow C$</div>
                <div class="fragment" style="margin-top: .25em; font-size: 2.11em">$f: A \rightarrow (B \rightarrow C)$</div>
            </div>
            <aside class="notes">
                Tout simplement de voir une fonction √† 2 param√®tres...
                <br><br>
                ... comme √©quivalente √† une fonction √† un param√®tre produisant un autre fonction √† un param√®tre.
                <br><br>
                Et donc comme une fonction que l'on peut appliquer partiellement ou graduellement √† plusieurs arguments.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int, y: Int): Boolean {
                            val c = longComputation(x)
                            return y % c == 0
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = { y -> parametricPredicate(3, y) }
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Si l'on repart de notre example de travail, curryfier ¬´ parametricPredicate ¬ª revient √† le transformer ainsi...
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = parametricPredicate(3)
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Que peut-on constater ici ?
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): <span class="ch">(Int) -> Boolean</span> {
                            val c = longComputation(x)
                            return <span class="ch">{ y -> y % c == 0 }</span>
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = parametricPredicate(3)
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Qu'elle ne prend plus qu'un seul param√®tre, celui qui va servir √† ¬´ longComputation ¬ª. Et que son type
                indique bien qu'elle retourne une fonction de Int vers Boolean.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = <span class="ch">parametricPredicate(3)</span>
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Que l'on peut √©ventuellement affecter son r√©sultat √† une variable. N'oublions pas que les fonctions sont
                ici des citoyens de premi√®re classe...
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = parametricPredicate(3)
                            println(aList.filter(<span class="ch">predicate</span>))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Et donc qu'on peut utiliser ce r√©sultat comme pr√©dicat pour ¬´ filter ¬ª et accessoirement cette fois
                le long calcul n'est effectu√© qu'une seule fois et non √† chaque it√©ration du filtre.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        val parametricPredicate: (Int) -> (Int) -> Boolean = { x ->
                            val c = longComputation(x);
                            { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = parametricPredicate(3)
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Soit dit en passant, on aurait aussi pu faire un pas de plus et dire que ¬´ parametricPredicate ¬ª est...
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        val parametricPredicate: <span class="ch">(Int) -> (Int) -> Boolean</span> = { x ->
                            val c = longComputation(x);
                            { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = parametricPredicate(3)
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                ... une variable qui re√ßoit une fonction de Int qui retourne une fonction de Int vers Boolean.
                Mais bon, restons l√†...
            </aside>
        </section>

        <section>
            <h1>Lisp 1.5</h1>
            <h2>1958</h2>
            <aside class="notes">
                Avant d'aller plus loin, faisons un premier saut en 1958 √† la naissance de LISP.
            </aside>
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: auto auto; grid-template-rows: auto auto">
                <div>
                    <div style="grid-column: 1; grid-row: 1">
                        <img src="./images/john-mccarthy.png" alt="">
                    </div>
                    <div class="fragment" style="grid-column: 1; grid-row: 2">John MacCarthy</div>
                </div>
                <div class="fragment">
                    <div style="grid-column: 2; grid-row: 1/2">
                        <a href="http://www-formal.stanford.edu/jmc/recursive.pdf"><img style="border: thin solid black" src="./images/Lisp.png" alt=""></a>
                    </div>
                </div>
            </div>

            <aside class="notes">
                Cet √©l√©gant barbu est...
                <br><br>
                John McCarthy (1927-2011), chercheur de l'universit√© de Standford ayant obtenu
                le prix Turing en 1971, il est co-inventeur des syst√®mes √† temps partag√© (pensez Unix) et pionnier de l'IA
                (on lui doit le terme). En 1956, il cr√©e l'algorithme d'√©lagage Alpha-B√©ta utilis√© au c≈ìur de moteurs de
                jeux pour les √©checs par exemple.
                <br><br>
                Mais il a aussi contribu√© √† la cr√©ation de LISP en 1958 second langage concret apr√®s FORTRAN (1954).
            </aside>
        </section>

        <section>
            <a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf"><img src="./images/HistoryOfLisp.png" alt=""></a>
            <aside class="notes">
                Lisp est un langage con√ßu avant tout pour la manipulation symbolique, par opposition √† FORTRAN dont le but et
                le calcul num√©rique. L'id√©e √©tait d'avoir un langage facilitant l'√©criture d'algorithmes tels que la
                d√©rivation symbolique de fonctions (une des premi√®res applications) et largement adopt√© de ce fait dans
                la recherche en IA et en th√©orie des langages (de programmation ou naturels)...
            </aside>
        </section>

        <section>
            <img src="./images/HistoryOfLispHighlighted.png" alt="">
            <aside class="notes">
                Et de mani√®re assez cocasse, c'√©tait √† l'origine un langage sans fonctions d'ordre sup√©rieur avec une
                syntaxe proche de FORTRAN (le M-language) permettant de manipuler des structures de liste (le S-language).
                Rapidement, on s'est aper√ßu qu'il est possible de plonger le premier dans le second grace aux fonctions
                EVAL et APPLY, rendant LISP homo iconique. C'est-√†-dire que la structure du langage et structure des donn√©es
                manipul√©es est identique. √áa ouvre une porte √† la m√©ta-programmation qui s'apparente √† la r√©flexivit√©.
            </aside>
        </section>

        <section>
            <h1>Funarg Problem</h1>
            <aside class="notes">
                Dans la foul√©e, LISP gagne les fonctions d'ordre sup√©rieur et la possibilit√© de d√©finir des fonctions
                anonymes, des LAMBDAS. Un argument fonctionnel de fonction est ce que l'on nomme un FUNARG dans le jargon
                Lispien.
                <br><br>
                J'ai cru pendant longtemps de LISP √©tait avant tout fonctionnel et avait √©t√© inspir√©
                pas le lambda calcul. En fait LISP 1.5 √©tait encore tr√®s imp√©ratif (SETQ, RPLACA...) et McCarthy aurait
                indiqu√© s'en √™tre peu inspir√©.
            </aside>
        </section>

        <section>
            <a href="https://dspace.mit.edu/bitstream/handle/1721.1/5854/AIM-199.pdf"><img style="border: thin solid black; margin-bottom: 100%; margin-top: 3em" src="./images/funarg-problem.png" alt=""></a>
            <aside class="notes">
                Sauf que dans les premi√®res moutures de LISP, les FUNARG avaient un probl√®me √©tudi√© (ici par Joel Moses
                dans un m√©mo de MIT) et longuement d√©battu.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px">
                                fun longComputation(x: Int): Int {
                                    return x * x
                                }

                                fun parametricPredicate(x: Int): (Int) -> Boolean {
                                    val c = longComputation(x)
                                    return { y -> c % y == 0 }
                                }

                                fun main() {
                                    val c = 42
                                    val predicate: (Int) -> Boolean = parametricPredicate(3)
                                    if (predicate(81)) println("Ok") else println("Ko")
                                }
            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Pour illustrer ce probl√®me, reprenons notre exemple (pas en LISP bien s√ªr). C'est peu ou prou l'exemple
                initial, mais sans l'appel √† ¬´ filter ¬ª et avec une variable ¬´ c ¬ª d√©finie dans ¬´ main ¬ª.
            </aside>

        </section>

        <section>
            <h2>Les fonctions <span class="green">(r√©cursives)</span> d√©cortiqu√©es</h2>
            <a style="margin-bottom: 100%" href="https://www.youtube.com/watch?v=aTDSZtHCIGU"><img src="./images/Devoxx-2022.png" alt=""></a>
            <aside class="notes">
                En passant, je me permets une petite promotion √©hont√©e pour une de mes pr√©sentations pass√©es qui parle des
                fonctions, √©ventuellement r√©cursives, et de leur mise en ≈ìuvre. Pr√©sentation qui pourrait √™tre un
                compl√©ment int√©ressant √† celle-ci.
            </aside>

        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/1.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Nous allons suivre pas √† pas le d√©roulement de ce programme. Comme je l'explique plus en d√©tail dans
                mon autre pr√©sentation, l'environnement d'ex√©cution d'une fonction est fourni par un enregistrement
                d'activation plus tous ceux des fonctions appelantes. Un enregistrement est cr√©√© √† l'activation de la
                fonction et d√©truit quand elle se termine. Et dans la plupart des langages (mais pas tous) cette gestion
                se fait sous forme de pile.
                <br><br>
                Donc ici, on commence avec l'enregistrement d'activation de ¬´ main ¬ª dans la pile.
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    <span class="ch">val c = 42</span>
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/2.svg"></object>
                </div>
            </div>
            <aside class="notes">
                ¬´ c ¬ª se voit affecter la valeur 42
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/2.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Puis on appelle la fonction ¬´ parametricPredicate ¬ª currifi√©e avec 3 en argument.
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = <span class="ch">longComputation(x)</span>
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/3.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Ce qui g√©n√®re un nouvel enregistrement d'activation pour elle sur la pile. √Ä son tour ¬´ longComputation ¬ª
                est appel√©e avec 3 en argument.
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = <span class="ch">longComputation(x)</span>
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return <span class="ch">x * x</span>
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/4.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Et un nouvel enregistrement d'activation lui est allou√©e. ¬´ longComputation ¬ª produit et retourne son
                r√©sultat 9.
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = <span class="ch">longComputation(x)</span>
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/5.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Qui est affect√© √† ¬´ c ¬ª dans l'environnement de ¬´ parametricPredicate ¬ª.
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return <span class="ch">{ y -> c % y == 0 }</span>
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/5.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Et c'est que les Ath√©niens s'atteignirent ! ¬´ parametricPredicate ¬ª doit retourner une fonction
                anonyme, et na√Øvement, on pourrait consid√©rer (comme en langage C par exemple) qu'il s'agit d'un pointeur
                sur fonction.
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/6.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Ici l'adresse du code compil√© de la fonction ¬´ @Lambda0 ¬ª est retourn√© et affect√© √† la variable
                ¬´ predicate ¬ª dans l'environnement de ¬´ main ¬ª.
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if <span class="ch">(predicate(81))</span> println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/6.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Puis on appelle ¬´ predicate ¬ª avec 81 en param√®tre √† tester... Donc, on lui alloue un enregistrement
                d'activation.
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if <span class="ch">(predicate(81))</span> println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/7.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Mais dans cet environnement ¬´ c ¬ª n'a pas de valeur, alors on remonte la cha√Æne des environnements pour
                en trouver une. On tombe sur le 42 initial. Et l√†, c'est le drame ! On s'attend √† un r√©sultat positif
                (81 est divisible par 9 en nombre entier), pourtant c'est faux parce que la lambda n'utilise pas la
                bonne valeur de ¬´ c ¬ª. Il pourrait m√™me ne pas y avoir de valeur pour ¬´ c ¬ª.
                <br><br>
                √Ä vrai dire, je ne sais pas ce qui est le pire entre un programme qui plante clairement ou qui r√©pond √†
                c√¥t√© sans que l'on s'en aper√ßoive.
                <br><br>
                Alors ne nous m√©prenons pas : cela peut √™tre consid√©r√© comme une fonctionnalit√© l√©gitime. √áa s'appelle
                de la liaison dynamique. Et pendant longtemps, le sujet a √©t√© d√©battu, avec ses partisans et ces d√©tracteurs.
                Et c'est m√™me devenu un id√Æome LISP. On parle d'id√Æome dans un langage quand un design pattern est tr√®s
                li√© √† la s√©mantique du langage.
                <br><br>
                Je serais enclin √† dire, si l'on se place dans un cadre de programmation fonctionnelle, que le principe
                de raisonnement local est mis √† mal par un tel m√©canisme. Quand je code, j'ai du mal avec les effets
                contextuels d'utilisation d'une fonction autre que ses param√®tres d'entr√©e.
            </aside>
        </section>

        <section>
            <h1>Scheme</h1>
            <h2>1975</h2>
            <aside class="notes">
                Donc le sujet est d√©battu pendant plus de 15 ans dans le monde lispien. Jusqu'√† l'arriv√©e de SCHEME.
            </aside>
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: auto auto; grid-template-rows: auto auto">
                <div>
                    <div style="grid-column: 1; grid-row: 1">
                        <img src="./images/Guy_Steele.jpg" alt="">
                    </div>
                    <div class="fragment" style="grid-column: 1; grid-row: 2">Guy L. Steele Jr.</div>
                </div>
                <div class="fragment">
                    <div style="grid-column: 2; grid-row: 1/2">
                        <a href="https://media.githubusercontent.com/media/sarabander/sicp-pdf/master/sicp.pdf"><img src="./images/SICP.png" alt=""></a>
                    </div>
                </div>
            </div>
            <aside class="notes">
                Jusqu'√† croiser la route de...
                <br><br>
                Guy Lewis Steel Junior, √† qui on doit entre autres Emacs et le premier portage de TeX de Donald Knuth. Il
                a √©t√© impliqu√© dans la d√©finition ou la normalisation de nombreux langages de programmation, comme *Lisp
                et C* chez Thinking Machines ; Common Lisp, C, Fortran dans le cadre de commit√©s ; Et Java en tant
                qu'employ√© de Sun en 1994 puis Oracle depuis 2010. Il est m√™me r√©cemment all√© travailler avec Epic Games
                sur le langage Verse en compagnie de Simon Peyton-Jones, un des piliers d'Haskell.
                <br><br>
                Pour ce qui nous concerne aujourd'hui, il est surtout le co-cr√©ateur de Scheme en 1975 de SCHEME avec
                Gerald Sussmann au MIT. Gerald Jay Sussmann auteur du livre ¬´ Structure and Interpretation of Computer
                Programs ¬ª, que je vous invite √† parcourir tant il fait partie des fondamentaux.
            </aside>
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: auto auto; grid-template-rows: auto auto">
                <div>
                    <div style="grid-column: 1; grid-row: 1">
                        <img src="./images/Guy_Steele.jpg" alt="">
                    </div>
                    <div style="grid-column: 1; grid-row: 2">Guy L. Steele Jr.</div>
                </div>
                <div>
                    <div style="grid-column: 2; grid-row: 1/2">
                        <a href="https://dspace.mit.edu/bitstream/handle/1721.1/5753/AIM-443.pdf"><img style="border: thin solid black" src="./images/LambdaTheUltimate.png" alt=""></a>
                    </div>
                </div>
            </div>
            <aside class="notes">
                Il est aussi l'auteur des ¬´ Œª the ultimate ¬ª papers. C'est une s√©rie d'articles parfois co√©crits avec
                Sussmann, qui prend le partit de la liaison lexicale. Il s'agit de faire en sorte, m√™me au prix d'un
                surco√ªt √† l'ex√©cution d'un programme, que les variables libres d'une lambda prennent la valeur qu'elles
                avaient au moment de leur d√©finition et non au moment de l'ex√©cution.
                <br><br>
                Et au travers de multiples exemples, il montre toute l'utilit√© de ce concept.
            </aside>
        </section>

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;  display: grid; grid-template-columns: 3fr 2fr">
                <div style="justify-self: center">$x$</div>
                <div style="justify-self: start"> Variable</div>
                <div style="justify-self: center">$\lambda x.\,M$</div>
                <div style="justify-self: start"> Abstraction</div>
                <div style="justify-self: center; margin-bottom: 2.5em">$M\,N$</div>
                <div style="margin-bottom: 2.5em; justify-self: start"> Application</div>
                <div style="justify-self: center">$\lambda x.\,(f\,x) \rightarrow f$</div>
                <div style="justify-self: start">$\eta$-reduction</div>
                <div style="justify-self: center">$\lambda x.\,M[x] \rightarrow \lambda y.\,M[y]$</div>
                <div style="justify-self: start">$\alpha$-conversion</div>
                <div class="yellow" style="justify-self: center">$(\lambda x.\,M)\:E \rightarrow M[x:=E]$</div>
                <div class="yellow" style="justify-self: start">$\beta$-reduction</div>
            </div>
            <aside class="notes">
                Pour la peine, la liaison lexicale est au fondement de l'interpr√©tation du lambda calcul.
            </aside>
        </section>

        <section>
            <a href="https://www.cs.tufts.edu/comp/150FP/archive/peter-landin/mechanical-eval.pdf"><img style="border: thin solid black; margin-bottom: 100%; margin-top: 3em" src="./images/Landin.png" alt=""></a>
            <aside class="notes">
                Et sa mise en ≈ìuvre concr√®te est depuis longtemps comprise, comme dans cet article fondateur de Peter Landin
                datant de 1964 ! Accessoirement lui doit aussi le terme ¬´ sucre syntaxique ¬ª !
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return <span class="ch">{ y -> c % y == 0 }</span>
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/5.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Reprenons le d√©roul√© de notre exemple l√† o√π le probl√®me apparait. Retourner un ¬´ pointeur ¬ª sur le code
                de la fonction anonyme ne suffit pas. Il faut aussi fournir des √©lements de son environnement qui feraient
                d√©fault ult√©rieurement : les valeurs de ses variables libres. Celles qui ne font pas partie des param√®tres
                de la lambda.
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/6.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Et de plus, on a besoin que cette information survive √† la d√©s-allocation de l'enregistrement d'activation
                de ¬´ parametricPredicate ¬ª. Pour cel√†, on va allouer une structure contenant valeur des variables libres de
                la lambda et pointeur sur son code sur le tas (heap).
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/7.svg"></object>
                </div>
            </div>
            <aside class="notes">
                C'est cette structure qu'on appelle ¬´ Closure ¬ª ou ¬´ Fermeture ¬ª : on fait l'inventaire des variables libres
                four ¬´ fermer ¬ª la lambda. En ce sens, on peut dire qu'une fonction anonyme li√©e lexicalement est un concept
                du langage et une ¬´ Fermeture ¬ª un d√©tail d'impl√©mentation. Apr√®s, peut-√™tre √† tort, les termes ¬´ lambda ¬ª et
                ¬´ closure ¬ª sont devenus interchangeables dans certains discours.
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if <span class="ch">(predicate(81))</span> println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/8.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Et maintenant, lors de l'√©valuation de ¬´ predicate(81) ¬ª on fera r√©f√©rence √† la valeur de ¬´ c ¬ª lors la
                d√©finition de la lambda et non celle de ¬´ main ¬ª. Encore une fois, c'est un choix qui s'est d√©battu et le
                consensus actuel veut que la liaison lexicale soit la bonne approche.
            </aside>
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 2fr">
                <div style="grid-column: 2; grid-row: 1">
                    <img src="./images/Haskell-logo.png" alt="">
                </div>
                <div class="fragment" data-fragment-index="1" style="grid-column: 2; grid-row: 2">
                    <a href="https://www.cambridge.org/core/services/aop-cambridge-core/content/view/S0956796800000319"><img style="border: solid black 1px; margin-top: 2.5em" src="./images/Haskell.png" alt=""></a>
                </div>
                <div style="grid-column: 1; grid-row: 1">
                    <img src="./images/OCaml-logo.png" alt="">
                </div>
                <div class="fragment" data-fragment-index="1" style="grid-column: 1; grid-row: 2">
                    <a href="https://inria.hal.science/inria-00070049/document"><img style="border: solid black 1px; margin-top: 2.5em" src="./images/OCaml.png" alt=""></a>
                </div>
            </div>
            <aside class="notes">
                C'est d'ailleurs le monde de la programmation fonctionnelle, tout au long de la fin du 20·µâ si√®cle, qui a pouss√©
                dans ce sens (avec ici deux embl√©matiques repr√©sentants, Haskell et OCaml), emportant dans son sillage le monde
                lispien. Ici, vous avez deux rapports d√©crivant la mise en ≈ìuvre de l'un et l'autre. Et dans les deux cas la
                notion de closure fait int√©gralement partie de la machine viiruelle (ou de l'environnement d'ex√©cution) du
                langage.
            </aside>
        </section>

        <section>
            <img style="margin-top: 3em; margin-bottom: 100%" src="./images/OcamlClosures.png" alt="">
            <aside class="notes">
                Dans le cas d'OCaml, il y est dit qu'une valeur fonctionnelle est ¬´ √©videmment ¬ª repr√©sent√© pas une closure,
                c'est-√†-dire une paire pointeur de code / environnement de liaison des variables. Il y est aussi expliqu√© qu'elles
                sont allou√©e dans une space encore diff√©rent du tas pour de subtiles raisons de r√©cup√©ration m√©moire.
            </aside>
        </section>

        <section>
            <img style="margin-top: 2em; margin-bottom: 100%" src="./images/HaskellClosures.png" alt="">
            <aside class="notes">
                Pour Haskell, comme le montre ce sch√©ma, c'est un peu plus compliqu√©, ne serait-ce que du fait de choix de mise en
                ≈ìuvre d'un langage paresseux ! Mais si on y pr√™te attention on retrouve encore le couple pointeur de code / environnement.
            </aside>
        </section>

        <section>
            <h1>Clojure</h1>
            <h2>2007</h2>
            <aside class="notes">
                En plissant fortement les yeux, on notera tout de m√™me une similitude entre les ¬´ Closures ¬ª et les
                objets des langages OO : une structure avec un dictionnaire de valeurs et un pointeur sur du code qui fait
                r√©f√©rence √† ce dictionnaire. D'ailleurs Guy Steele dans ces ¬´ lambda the ultimate ¬ª papers en parle de
                mani√®re indirecte.
            </aside>
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: auto auto; grid-template-rows: auto auto">
                <div>
                    <div style="grid-column: 1; grid-row: 1">
                        <img src="./images/Hickey.png" alt="">
                    </div>
                    <div class="fragment" style="grid-column: 1; grid-row: 2">Rich Hickey</div>
                </div>
                <div class="fragment">
                    <div style="grid-column: 2; grid-row: 1/2">
                        <a href="https://dl.acm.org/doi/pdf/10.1145/3386321"><img style="border: thin solid black" src="./images/Clojure.png" alt=""></a>
                    </div>
                </div>
            </div>
            <aside class="notes">
                En 2007, Rich Hickey apr√®s avoir fait une premi√®re tentative sur la plateforme .NET, propose un dialecte
                de Scheme ciblant la JVM. Et forc√©ment, il adopte la liaison lexicale comme fondement pour la
                d√©finition des fonctions anonymes.
                <br><br>
                Et bien d'autres partis pris qu'il d√©taille dans cet article des
                ¬´ Proceedings of the ACM on Programming Languages ¬ª (appels terminaux et r√©cursivit√©).
                <br><br>
                Voyons comment il a (ou aurait) pu proc√©der pour mettre des ¬´ closure ¬ª sur une plateforme qui n'est pas
                initialement pr√©vue pour.
            </aside>
        </section>

        <section>
            <h1><span style="text-transform:lowercase">$\lambda$</span>-lifting</h1>
            <aside class="notes">
                On va d'abord parler d'une transformation classique utilis√©e par les compilateurs pour des langages
                fonctionnels. Elle n'est pas requise pour la suite, mais m√©rite qu'on la signale : Le ¬´ lambda lifting ¬ª.
                D'autant plus que dans la compilation de Java aujourd'hui, et pour une raison qui m'√©chappe, on l'appelle
                ¬´ lambda desugaring ¬ª. Il faudra qu'un jour, je pose la question √† R√©mi Forax...
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre class="fragment" style="font-size: 1.1ex; margin-top: 1em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicateLambda(c: Int, yy: Int): Boolean = yy % c == 0

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> parametricPredicateLambda(c, y) }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                L'id√©e est tr√®s simple : une premi√®re transformation du code fait apparaitre une fonction sans variable
                libre, au plus haut niveau, correspondant √† la lambda que l'on veut compiler
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        <span class="ch">fun parametricPredicateLambda(c: Int, yy: Int): Boolean = yy % c == 0</span>

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> parametricPredicateLambda(c, y) }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Forc√©ment, elle est susceptible d'avoir plus de param√®tres que la lambda d'origine, puisque les variables
                libres ne doivent plus l'√™tre.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicateLambda(c: Int, yy: Int): Boolean = yy % c == 0

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> <span class="ch">parametricPredicateLambda(c, y)</span> }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                L√†, vous me direz, on a fait que d√©placer le probl√®me... C'est pas faux !
            </aside>
        </section>

        <section>
            <h1>Closure conversion</h1>
            <aside class="notes">
                En fait, il y a une seconde transformation, qui elle en revanche en fondamentale pour notre sujet : la
                ¬´ closure conversion ¬ª.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Et c'est l√† que la similitude en objet et closure se voit un peu mieux.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(<span class="ch">val capture: C</span>, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Sauf qu'ici, j'ai d√©cid√© d'utiliser une structure, plut√¥t qu'une classe, qui embarque la variable captur√©e...
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, <span class="ch">val code: (C, I) -> O</span>)

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                ... et le pointeur dur le code.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): Closure&lt;Int, Int, Boolean&gt; {
                            val c = longComputation(x)
                            return Closure(c, ::parametricPredicateLambda)
                        }

                        fun main() {
                            val c = 42
                            val predicate: Closure&lt;Int, Int, Boolean&gt; = parametricPredicate(3)
                            if (predicate.code(predicate.capture, 81)) println("Ok") else println("Ko")
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Ce qui permet de r√©√©crire ¬´ parametricPredicate ¬ª...
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): Closure&lt;Int, Int, Boolean&gt; {
                            val c = longComputation(x)
                            return <span class="ch">Closure(c, ::parametricPredicateLambda)</span>
                        }

                        fun main() {
                            val c = 42
                            val predicate: Closure&lt;Int, Int, Boolean&gt; = parametricPredicate(3)
                            if (predicate.code(predicate.capture, 81)) println("Ok") else println("Ko")
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                ... de la fa√ßon suivante : elle retourne une repr√©sentation de la fonction anonyme accompagn√©e des
                valeurs des variables captur√©es. C'est une repr√©sentation op√©rationnelle d'une valeur fonction.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): Closure&lt;Int, Int, Boolean&gt; {
                            val c = longComputation(x)
                            return Closure(c, ::parametricPredicateLambda)
                        }

                        fun main() {
                            val c = 42
                            val predicate: Closure&lt;Int, Int, Boolean&gt; = parametricPredicate(3)
                            if (<span class="ch">predicate.code(predicate.capture, 81)</span>) println("Ok") else println("Ko")
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Et forc√©ment au point d'appel, il faut aussi effectuer une adaptation. On appelle le code de la
                fonction lambda lift√©e avec ces deux arguments, la valeur captur√©e et celle qu'on veut tester.
            </aside>
        </section>

        <section>
            <h1>Java 8</h1>
            <h2>2014</h2>
            <aside class="notes">
                L'utilisation de fonctions anonymes fait son chemin dans bien des langages. Peut-√™tre parce que de plus en
                plus de d√©veloppeurs sont sensibilis√©s √† la programmation fonctionnelle qui en use abondamment... Ou parce
                que √ßa fait bien, allez savoir ?
            </aside>
        </section>

        <section>
            <img style="border: thin solid" src="./images/JSR335.png" alt="">
            <aside class="notes">
                En attendant, la gestation du support des lambda dans Java d√©bute √† la sortie de Clojure, en 2007 et va
                quand m√™me durer 7 ans, pour voir officiellement sortir la JSR 335 dans Java 8.
            </aside>
        </section>

        <section>
            <a href="http://gafter.blogspot.com/2007/01/definition-of-closures.html"><img style="border: thin solid black" src="./images/Gafter.png" alt=""></a>
            <aside class="notes">
                Pourquoi tant de temps ? Parce que Java est un langage orient√© objets et que la somme des concepts sujets
                √† la liaison lexicale d√©passe les variables d'une fonction anonyme Lisp. Ce qui est tr√®s bien expliqu√©
                dans cet article de Neil Gafter, membre d'un groupe ayant formul√© une des trois propositions d'int√©grations
                initiales (rien que √ßa). Mais aussi parce que les enjeux de r√©tro compatibilit√© et d'√©volutivit√© de Java
                en tant que plateforme sont grands.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static int longComputation(int x) {
                                    return x * x;
                                }

                                public static IntPredicate parametricPredicate(int x) {
                                    var c = longComputation(x);
                                    return y -> y % c == 0;
                                }

                                void main() {
                                    var aStream = IntStream.rangeClosed(0, 100);
                                    var predicate = parametricPredicate(3);
                                    IntStream filteredStream = aStream.filter(predicate);

                                    System.out.println(
                                            filteredStream.
                                                    mapToObj(Integer::toString).
                                                    collect(Collectors.joining(",", "[", "]")));
                                }

                                // [0,9,18,27,36,45,54,63,72,81,90,99]

            </code></pre>
            <aside class="notes">
                Voil√† √† quoi ressemble notre exemple en Java. J'ai utilis√© ici la version 21 plut√¥t que la 8 avec la
                fonctionnalit√© classe anonyme et m√©thode 'main' d'instance pour qu'il ressemble plus √† la version Kotlin.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static int longComputation(int x) {
                                    return x * x;
                                }

                                public static IntPredicate parametricPredicate(int x) {
                                    var c = longComputation(x);
                                    return <span class="ch">y -> y % c == 0</span>;
                                }

                                void main() {
                                    var aStream = IntStream.rangeClosed(0, 100);
                                    var predicate = parametricPredicate(3);
                                    IntStream filteredStream = aStream.filter(predicate);

                                    System.out.println(
                                            filteredStream.
                                                    mapToObj(Integer::toString).
                                                    collect(Collectors.joining(",", "[", "]")));
                                }

                                // [0,9,18,27,36,45,54,63,72,81,90,99]

            </code></pre>
            <aside class="notes">
                La syntaxe pour le lambda est assez commune et proche de celle de Kotlin (aux accolades pr√®s).
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static int longComputation(int x) {
                                    return x * x;
                                }

                                public static <span class="ch">IntPredicate</span> parametricPredicate(int x) {
                                    var c = longComputation(x);
                                    return y -> y % c == 0;
                                }

                                void main() {
                                    var aStream = IntStream.rangeClosed(0, 100);
                                    var predicate = parametricPredicate(3);
                                    IntStream filteredStream = aStream.filter(predicate);

                                    System.out.println(
                                            filteredStream.
                                                    mapToObj(Integer::toString).
                                                    collect(Collectors.joining(",", "[", "]")));
                                }

                                // [0,9,18,27,36,45,54,63,72,81,90,99]

            </code></pre>
            <aside class="notes">
                En revanche, il n'y a pas de syntaxe pour d√©crire un type fonctionnel. Ici le type de retour de
                ¬´ parametricPredicate ¬ª est nominatif, c'est une interface.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                @FunctionalInterface
                                public interface IntPredicate {

                                    boolean test(int value);

                                }

            </code></pre>
            <aside class="notes">
                Mais pas n'importe qu'elle interface. C'est une ¬´ Single Abstract Method ¬ª ou ¬´ SAM ¬ª interface...
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                <span class="ch">@FunctionalInterface</span>
                                public interface IntPredicate {

                                    boolean test(int value);

                                }

            </code></pre>
            <aside class="notes">
                ... qui est annot√©e ¬´ @FunctionalInterface ¬ª.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                @FunctionalInterface
                                public interface IntPredicate {

                                    <span class="ch">boolean test(int value)</span>;

                                }

            </code></pre>
            <aside class="notes">
                Comme je l'ai d√©j√† dit, une closure ressemble √† un objet de disposant que d'une seule m√©thode pouvant
                acc√©der aux champs de l'objet. C'est cette similitude qui est exploit√©e ici. On assimile une certaine
                forme d'interface au type d'une lambda. On est l√† dans la recherche de r√©trocompatibilit√©, pour exploiter
                des interfaces d√©j√† existantes qui auraient la bonne forme, comme ¬´ Runnable ¬ª. Apr√®s cette forme de
                ¬´ SAM conversion ¬ª est aussi disponible en Kotlin, alors pour s'√™tre priv√© d'une syntaxe explicite, je
                n'en sais rien.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static boolean parametricPredicateLambda(int c, int yy) { return yy % c == 0; }

                                public static IntPredicate parametricPredicate(int x) {
                                    var c = longComputation(x);
                                    return new IntPredicate() {
                                        @Override
                                        public boolean test(int value) {
                                            return parametricPredicateLambda(c, value);
                                        }
                                    };
                                }

            </code></pre>
            <aside class="notes">
                En tout cas la strat√©gie de compilation retenue pour Java ressemble plut√¥t √† √ßa.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static boolean <span class="ch">parametricPredicateLambda</span>(int c, int yy) { return yy % c == 0; }

                                public static IntPredicate parametricPredicate(int x) {
                                    var c = longComputation(x);
                                    return new IntPredicate() {
                                        @Override
                                        public boolean test(int value) {
                                            return parametricPredicateLambda(c, value);
                                        }
                                    };
                                }

            </code></pre>
            <aside class="notes">
                On dispose toujours de notre fonction lambda-lift√©e... Enfin ¬´ desugared ¬ª dans la terminologie de Java.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static boolean parametricPredicateLambda(int c, int yy) { return yy % c == 0; }

                                public static IntPredicate parametricPredicate(int x) {
                                    var c = longComputation(x);
                                    return <span class="ch">new IntPredicate() {</span>
                                        <span class="ch">@Override</span>
                                        <span class="ch">public boolean test(int value) {</span>
                                            <span class="ch">return parametricPredicateLambda(c, value);</span>
                                        <span class="ch">}</span>
                                    <span class="ch">}</span>;
                                }

            </code></pre>
            <aside class="notes">
                Mais la traduction de la lambda lexicalement li√©e, la closure, s'appuie sur le m√©canisme de classe
                anonyme de Java. C'est-√†-dire, une classe cr√©√©e localement √† partir de l'interface fonctionnelle cible.
                Et il se trouve que ce type de classe interne acc√®de, par principe, au contexte dans lequel elle est
                cr√©√©e. Donc dans notre exemple √† ¬´ c ¬ª.
                <br><br>
                Si c'est l√† bien le principe retenu pour les lambdas en Java, il est pourtant mis en ≈ìuvre avec une
                subtilit√©...
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="Java" style="max-height: 800px" data-noescape>

          private static boolean lambda$parametricPredicate$0(int, int);
            descriptor: (II)Z
            flags: (0x100a) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC
            Code:
              stack=2, locals=2, args_size=2
                 0: iload_1
                 1: iload_0
                 2: irem
                 3: ifne          10
                 6: iconst_1
                 7: goto          11
                10: iconst_0
                11: ireturn
              LineNumberTable:
                line 15: 0
              StackMapTable: number_of_entries = 2
                frame_type = 10 /* same */
                frame_type = 64 /* same_locals_1_stack_item */
                  stack = [ int ]

            </code></pre>
            <aside class="notes">
                On va descendre un peu plus dans la soute et jeter un ≈ìil rapidement au bytecode g√©n√©r√© par le compilateur,
                gr√¢ce √† la commande ¬´ javap ¬ª sorte de d√©s-assembleur pour le code de la JVM.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="Java" style="max-height: 800px" data-noescape>

          private static boolean <span class="ch">lambda$parametricPredicate$0</span>(int, int);
            descriptor: (II)Z
            flags: (0x100a) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC
            Code:
              stack=2, locals=2, args_size=2
                 0: iload_1
                 1: iload_0
                 2: irem
                 3: ifne          10
                 6: iconst_1
                 7: goto          11
                10: iconst_0
                11: ireturn
              LineNumberTable:
                line 15: 0
              StackMapTable: number_of_entries = 2
                frame_type = 10 /* same */
                frame_type = 64 /* same_locals_1_stack_item */
                  stack = [ int ]

            </code></pre>
            <aside class="notes">
                Et en fouinant dans le r√©sultat, une premi√®re chose qui saute aux yeux, c'est notre fameuse
                fonction anonyme lambda-lift√©e, ici appel√© ¬´ lambda$parametricPredicate$0 ¬ª. On voit bien
                qu'elle a deux param√®tres au lieu d'un et qu'elle retourne un bool√©en.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="Java" style="max-height: 800px" data-noescape>

          public static java.util.function.IntPredicate parametricPredicate(int);
            descriptor: (I)Ljava/util/function/IntPredicate;
            flags: (0x0009) ACC_PUBLIC, ACC_STATIC
            Code:
              stack=1, locals=2, args_size=1
                 0: iload_0
                 1: invokestatic  #7                  // Method longComputation:(I)I
                 4: istore_1
                 5: iload_1
                 6: invokedynamic #13,  0             // InvokeDynamic #0:test:(I)Ljava/util/function/IntPredicate;
                11: areturn
              LineNumberTable:
                line 14: 0
                line 15: 5

            </code></pre>
            <aside class="notes">
                On retrouve aussi ¬´ parametricPredicate ¬ª qui doit retourner une valeur fonction de type ¬´ IntPredicate ¬ª.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

          public static java.util.function.IntPredicate parametricPredicate(int);
            descriptor: (I)Ljava/util/function/IntPredicate;
            flags: (0x0009) ACC_PUBLIC, ACC_STATIC
            Code:
              stack=1, locals=2, args_size=1
                 0: iload_0
                 1: invokestatic  #7                  // Method longComputation:(I)I
                 4: istore_1
                 5: iload_1
                 6: <span class="ch">invokedynamic</span> #13,  0             // InvokeDynamic #0:test:(I)Ljava/util/function/IntPredicate;
                11: areturn
              LineNumberTable:
                line 14: 0
                line 15: 5

            </code></pre>
            <aside class="notes">
                Les concepteurs de la JSR 335 vont tirer partit de l'instruction de la JVM introduite en Java 7
                pour les langages dynamique : ¬´ InvokeDynamic ¬ª. L'id√©e, c'est de se rendre r√©sistants √† de potentiels
                futurs choix de mise en ≈ìuvre en g√©n√©rant cette classe interne instance de ¬´ IntPredicate ¬ª √† la vol√©e.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

          public static java.util.function.IntPredicate parametricPredicate(int);
            descriptor: (I)Ljava/util/function/IntPredicate;
            flags: (0x0009) ACC_PUBLIC, ACC_STATIC
            Code:
              stack=1, locals=2, args_size=1
                 0: iload_0
                 1: invokestatic  #7                  // Method longComputation:(I)I
                 4: istore_1
                 5: iload_1
                 6: <span class="ch">invokedynamic</span> #13,  0             <span class="ch">// InvokeDynamic #0:test:(I)Ljava/util/function/IntPredicate;</span>
                11: areturn
              LineNumberTable:
                line 14: 0
                line 15: 5

            </code></pre>
            <aside class="notes">

            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

        BootstrapMethods:
          0: #94 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(
                        Ljava/lang/invoke/MethodHandles$Lookup;
                        Ljava/lang/String;Ljava/lang/invoke/MethodType;
                        Ljava/lang/invoke/MethodType;
                        Ljava/lang/invoke/MethodHandle;
                        Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
            Method arguments:
              #79 (I)Z
              #81 REF_invokeStatic Main.lambda$parametricPredicate$0:(II)Z
              #79 (I)Z

            </code></pre>
            <aside class="notes">
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

        BootstrapMethods:
          0: #94 REF_invokeStatic java/lang/invoke/<span class="ch">LambdaMetafactory</span>.metafactory:(
                        Ljava/lang/invoke/MethodHandles$Lookup;
                        Ljava/lang/String;Ljava/lang/invoke/MethodType;
                        Ljava/lang/invoke/MethodType;
                        Ljava/lang/invoke/MethodHandle;
                        Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
            Method arguments:
              #79 (I)Z
              #81 REF_invokeStatic Main.lambda$parametricPredicate$0:(II)Z
              #79 (I)Z

            </code></pre>
            <aside class="notes">
            </aside>
        </section>

        <section>
            <h1>Pour Conclure</h1>
            <aside class="notes">
                Le fonctions anonymes li√©es lexicalement ont tellement fait leur chemin qu'on les retrouve dans des
                langages sans processus de r√©cup√©ration automatique de la m√©moire comme C++ ou Rust.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="rust" style="max-height: 800px" data-noescape>

                        fn long_computation(x: i64) -> i64 { x * x }

                        fn parametric_predicate(x: i64) -> impl FnMut(&i64) -> bool {
                            let c = long_computation(x);
                            move |y| { y % c == 0 }
                        }

                        fn main() {
                            let a_range = 1 .. 100;
                            let predicate = parametric_predicate(3);
                            let filtered_range = a_range.filter(predicate);
                            println!("{:?}", filtered_range.collect::&lt;Vec&lt;i64&gt;&gt;())
                        }

                        // [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99]

            </code><div class="lang">Rust</div></pre>
            <aside class="notes">
                Dans le cas de Rust √ßa n'est pas particuli√®rement √©tonnant. Son concepteur initial, Graydon Hoare, fin
                connaisseur de la mise en ≈ìuvre des langages de programmation et qui se d√©crit comme un ¬´ language
                engineer ¬ª, est un amateur de d'OCaml. D'ailleurs les premi√®res versions de Rust, avant qui ne soit
                ¬´ self hosted ¬ª, √©taient √©crite en OCaml.
                <br><br>
                Et effectivement √† regarder rapidement notre exemple fil rouge en Rust on n'est pas d√©pays√© !
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="rust" style="max-height: 800px" data-noescape>

                        fn long_computation(x: i64) -> i64 { x * x }

                        fn parametric_predicate(x: i64) -> <span class="ch">impl FnMut(&i64) -> bool</span> {
                            let c = long_computation(x);
                            move <span class="ch">|y| { y % c == 0 }</span>
                        }

                        fn main() {
                            let a_range = 1 .. 100;
                            let predicate = parametric_predicate(3);
                            let filtered_range = a_range.filter(predicate);
                            println!("{:?}", filtered_range.collect::&lt;Vec&lt;i64&gt;&gt;())
                        }

                        // [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99]

            </code><div class="lang">Rust</div></pre>
            <aside class="notes">
                La d√©claration d'un type fonctionnel est √† mi-chemin entre Kotlin et Java, et l'√©criture d'une lambda
                en elle-m√™me n'a rien de r√©volutionnaire.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="rust" style="max-height: 800px" data-noescape>

                        fn long_computation(x: i64) -> i64 { x * x }

                        fn parametric_predicate(x: i64) -> impl FnMut(&i64) -> bool {
                            let c = long_computation(x);
                            <span class="ch">move</span> |y| { y % <span class="ch">c</span> == 0 }
                        }

                        fn main() {
                            let a_range = 1 .. 100;
                            let predicate = parametric_predicate(3);
                            let filtered_range = a_range.filter(predicate);
                            println!("{:?}", filtered_range.collect::&lt;Vec&lt;i64&gt;&gt;())
                        }

                        // [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99]

            </code><div class="lang">Rust</div></pre>
            <aside class="notes">
                Tout au plus les imp√©ratifs li√©s au mod√®le de gestion m√©moire de Rust imposent quelques subtilit√©s,
                comme ici l'usage du mot clef ¬´ move ¬ª pour g√©rer la capture de la variable ¬´ c ¬ª qui doit survivre
                √† l'invocation de ¬´ parametric_predicate ¬ª.
                <br><br>
                Ce que l'on pourra retenir de tout √ßa c'est qu'une lambda, une fonction anonyme, peut √™tre dynamiquement
                ou lexicalement li√©e. Et que dans le second cas pour g√©rer la capture de son environnement in faut une
                repr√©sentation des valeurs fonctionnelles que l'on appelle closure. Que les strat√©gies de mises en ≈ìuvre
                sont nombreuses et tiennent compte des sp√©cificit√©s du langage.
            </aside>
        </section>

        <section>
            <div style="display: flex; justify-content: space-between">
                <div style="margin-left: 2em; display: flex; flex-direction: column">
                    <div style="margin-top: 1em; font-size: 1.55em; text-align: left" class="green">Fr√©d√©ric Cabestre</div>
                </div>
            </div>
            <h1 style="margin-top: 1em">Merci</h1>
            <div style="display: grid; grid: 'one two three' / 1fr 1fr 1fr; margin-bottom: 100%; margin-top: 2em">
                <div style="justify-self: center; grid-area: one">
                    <div>Feedback</div>
                    <img src="./images/feedback.png" alt="">
                </div>
                <div style="justify-self: center; grid-area: two">
                    <div>Code</div>
                    <img src="./images/code.png" alt="">
                </div>
                <div style="justify-self: center; grid-area: three">
                    <div>Pr√©sentation</div>
                    <img src="./images/presentation.png" alt="">
                </div>
            </div>
        </section>
    </div>
</div>

<script src="./dist/reveal.js"></script>
<script src="./plugin/notes/notes.js"></script>
<script src="./plugin/markdown/markdown.js"></script>
<script src="./plugin/highlight-old/highlight.js"></script>
<script src="./plugin/math/math.js"></script>

<script>
    Reveal.initialize({
        controls: false,
        progress: false,
        history: true,
        center: true,
        width: 1600,
        height: 900,

        transition: "none",

        plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX],

        katex: {
            local: " ",
            trust: true
        },
    });
</script>
</body>
</html>
