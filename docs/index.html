<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>

    <title>FermÃ© pour inventaire</title>

    <meta name="description" content="Histoire et mÃ©canique des Â« closures Â»"/>
    <meta name="author" content="FrÃ©dÃ©ric Cabestre"/>

    <link rel="stylesheet" href="./dist/reset.css">
    <link rel="stylesheet" href="./dist/reveal.css">
    <link rel="stylesheet" href="./dist/theme/transparents.css" id="theme"/>

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="./plugin/highlight/zenburn.css"/>
</head>

<body>
<div class="reveal">
    <div class="slides">

        <section>
            <h1>FermÃ© pour inventaire</h1>
            <h3>Histoire et mÃ©canique des Â« closures Â»</h3>
        </section>

        <section>
            <div style="display: flex; justify-content: space-between">
                <div style="margin-left: 2em; display: flex; flex-direction: column">
                    <div style="margin-top: 1em; font-size: 1.55em; text-align: left" class="green">FrÃ©dÃ©ric Cabestre</div>
                </div>
            </div>
            <blockquote style="margin-top: 11.45em; margin-right: 2em; margin-bottom: 100%">
                Le prÃ©sent sans passÃ© n'a pas d'avenir
                <div style="font-size: smaller">&mdash; <a href="https://fr.wikipedia.org/wiki/Fernand_Braudel">Fernand Braudel</a></div>
            </blockquote>
        </section>

        <section>
            <h1><span style="font-size:2em;text-transform:lowercase">$\lambda$</span></h1>
            <aside class="notes">
                Les fonctions d'ordre supÃ©rieur (c'est-Ã -dire dont les paramÃ¨tres sont des fonctions ou dont la valeur de
                retour peut Ãªtre une fonction) font dÃ©finitivement partie de l'outillage de base du dÃ©veloppeur.
                <br><br>
                Pour celÃ  les fonctions sont devenues des entitÃ©s de premiÃ¨re classe des langages de programmation. Autrement dit
                ce sont des valeurs Ã  part entiÃ¨re que l'on peut par exemple affecter Ã  des variables.
                <br><br>
                Il n'est d'ailleurs mÃªme plus nÃ©cessaire de les nommer pour pouvoir les dÃ©finir. Nous pouvons crÃ©er des fonctions anonymes
                communÃ©ment appelÃ©es Â« lambdas Â».
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px">
                                val aList = 1..100
                                val filteredList = aList.filter({ x -> x % 2 == 0 })
                                println(filteredList)

                                /*

                                  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
                                   28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50,
                                   52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
                                   76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100]

                                */
            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Cet attirail permet d'exprimer plus l'intention que la procÃ©dure Ã  suivre. Par exemple ici en disposant d'une
                fonction Â« filter Â» sur des collections, Ã  laquelle on peut fournir un prÃ©dicat, il n'est plus besoin de s'appesantir
                sur les dÃ©tails d'une itÃ©ration. La dÃ©marche est plus dÃ©clarative que procÃ©durale.
                <br><br>
                Dans ce qui suit l'essentiel des exemples de code seront en Kotlin. J'aurais pu m'appuyer sur C#, Rust, Java
                ou Javascript... Non, quand mÃªme pas Javascript ! Mais Kotlin c'est mon langage du moment, dont la lecture
                ne devrait pas vous troubler. Contrairement Ã ...
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="language-lisp" style="max-height: 800px">

                    (defun filter (fn list)
                        (cond ((null list) nil)
                              (t (cond ((funcall (eval fn) (car list)) (cons (car list) (filter fn (cdr list))))
                                       (t (filter fn (cdr list)))))))

                    (filter '(lambda (x) (= (mod x 2) 0)) '(1 2 3 4 5 6))

            </code><div class="lang">Lisp</div></pre>
            <aside class="notes">
                ... Common Lisp. Si Lisp va Ãªtre une sorte de fil rouge historique de cette prÃ©sentation, je n'avais pas
                envie de vous perdre bÃªtement en route. D'autant que, moi qui ai enseignÃ© en TP de Lisp Ã  la Fac il y a
                plus de 25 ans, j'en ai un peu bavÃ© pour Ã©crire cet exemple pourtant simple.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        aList.filter(<span class="ch">{ x -> x % 2 == 0 }</span>)

            </code><div class="lang">Kotlin</div></pre>
            <pre class="fragment" style="font-size: 1.1ex; margin-top: 1ex"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        aList.filter({ <span class="ch">it</span> % 2 == 0 })

            </code><div class="lang">Kotlin</div></pre>
            <pre class="fragment" style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        aList.filter { it % 2 == 0 }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Dans cet exemple la partie en surbrillance est donc une lambda prenant en paramÃ¨tre un entier et vÃ©rifiant
                s'il est pair (le reste de la division par 2 doit Ãªtre 0).
                <br><br>
                ParticularitÃ© de Kotlin, on peut dans certains cas, comme ici, nommer implicitement un paramÃ¨tre unique
                Â« it Â».
                <br><br>
                Et autre particularitÃ© de Kotlin, une lambda derniÃ¨re position des paramÃ¨tres d'une fonction peut Ãªtre
                sortie de la liste des paramÃ¨tres. C'est un emprunt Ã  Groovy, je crois, qui contribue Ã  faire de Kotlin
                un langage sympathique pour faire des DSL embarquÃ©s... Mais Ã§a sera l'objet d'un autre prÃ©sentation.
                <br><br>
                En tout Ã©tat de cause, cet exemple n'est pas des plus intÃ©ressants pour notre exploration...
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun longComputation(x: Int): Int {
                            return x * x // ğŸ¤¡
                        }

                        fun parametricPredicate(x: Int, y: Int): Boolean {
                            val c = longComputation(x)
                            return y % c == 0
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre class="fragment" style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px">

                        fun main() {
                            val aList = 1..100
                            val filteredList = aList.filter { y -> parametricPredicate(3, y) }
                            println(filteredList)

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                ConsidÃ©rons plutÃ´t celui-ciÂ : un prÃ©dicat paramÃ©trable par son premier argument pour vÃ©rifier une
                propriÃ©tÃ© du second argument. Et tant qu'Ã  faire, ce paramÃ©trage est le rÃ©sultat d'un calcul arbitrairement
                long effectuÃ© sur le premier argument.
                <br><br>
                Et si l'on veut utiliser ce prÃ©dicat Ã  deux arguments, dans le mÃªme contexte que prÃ©cÃ©demment, il va
                falloir l'adapter, Ã  l'aide d'une fonction anonyme...
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun longComputation(x: Int): Int {
                            return x * x // ğŸ¤¡
                        }

                        fun parametricPredicate(x: Int, y: Int): Boolean {
                            val c = longComputation(x)
                            return y % c == 0
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val filteredList = aList.filter <span class="ch">{ y -> parametricPredicate(3, y) }</span>
                            println(filteredList)

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                ... en fixant ce premier argument pour le ramener Ã  un seul argument Ã  tester.
                <br><br>
                Un inconvÃ©nient de cette approche est que Â« longComputation Â» sera effectuÃ©e Ã  chaque itÃ©ration de Â« filter Â».
                Une faÃ§on de rÃ©soudre ce problÃ¨me est de sortir ce long calcul de Â« parametricPredicate Â». Mais j'ai envie
                de vous prÃ©senter une autre approche qui serait de pouvoir appliquer partiellement Â« parametricPredicate Â» Ã 
                un argument. Et pour cela je dois vous parler de...
            </aside>
        </section>

        <section>
            <h1>Curryfication</h1>
            <aside class="notes">
                Ce terme est dÃ©rivÃ© du nom d'Haskell Curry, un logicien du 20áµ‰ siÃ¨cle ayant menÃ© des travaux sur la logique
                combinatoire et qui donnÃ© son prÃ©nom Ã  un cÃ©lÃ¨bre langage fonctionnel. En rÃ©alitÃ© ce concept
                est plutÃ´t du Ã  Moses SchÃ¶nfinkel, mais SchÃ¶nfinkelification aurait Ã©tÃ© plus difficile Ã  prononcer.
                <br><br>
                Alors de quoi s'agit-il ?
            </aside>
        </section>

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;  display: grid; grid-template-rows: 2fr 1fr">
                <div style="margin-top: .5em; font-size: 2.11em">$f: (A, B) \rightarrow C$</div>
                <div class="fragment" style="margin-top: .25em; font-size: 2.11em">$f: A \rightarrow (B \rightarrow C)$</div>
            </div>
            <aside class="notes">
                Tout simplement de voir une fonction Ã  2 arguments comme Ã©quivalente Ã  une fonction d'un argument
                produisant un autre fonction d'un argument.
                <br><br>
                Et donc comme une fonction que l'on peut appliquer partiellement ou graduellement Ã  plusieurs arguments.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int, y: Int): Boolean {
                            val c = longComputation(x)
                            return y % c == 0
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = { y -> parametricPredicate(3, y) }
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Si l'on repart de notre example de travail, curryfier Â« parametricPredicate Â» revient Ã  la transformer ainsi...
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = parametricPredicate(3)
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Que peut-on constater ici ?
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): <span class="ch">(Int) -> Boolean</span> {
                            val c = longComputation(x)
                            return <span class="ch">{ y -> y % c == 0 }</span>
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = parametricPredicate(3)
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Qu'elle ne prend plus qu'un seul paramÃ¨tre, celui qui va servir Ã  Â« longComputation Â». Et que son type
                indique bien qu'elle retourne une fonction de Int vers Boolean.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = <span class="ch">parametricPredicate(3)</span>
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Que l'on peut Ã©ventuellement affecter son rÃ©sultat Ã  une variable. N'oublions pas que les fonctions sont
                ici des citoyens de premiÃ¨re class...
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = parametricPredicate(3)
                            println(aList.filter(<span class="ch">predicate</span>))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Et donc qu'on peut utiliser ce rÃ©sultat comme prÃ©dicat pour Â« filter Â» et accessoirement cette fois
                le long calcul n'est effectuÃ© qu'une seule fois et no Ã  chaque itÃ©ration du filtre.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        val parametricPredicate: (Int) -> (Int) -> Boolean = { x ->
                            val c = longComputation(x);
                            { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = parametricPredicate(3)
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Soit dit en passant on aurait aussi pu faire un pas de plus et dire que Â« parametricPredicate Â» est...
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        val parametricPredicateCurried: <span class="ch">(Int) -> (Int) -> Boolean</span> = { x ->
                            val c = longComputation(x);
                            { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = parametricPredicate(3)
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                ... qui reÃ§oit une fonction de Int qui retourne une fonction de Int vers Boolean. Mais bon, restons lÃ ...
            </aside>
        </section>

        <section>
            <h1>Lisp 1.5</h1>
            <h2>1958</h2>
            <aside class="notes">
                Mais avant d'aller plus loin, faisons un premier saut en 1958 Ã  la naissance de LISP.
            </aside>
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: auto auto; grid-template-rows: auto auto">
                <div>
                    <div style="grid-column: 1; grid-row: 1">
                        <img src="./images/john-mccarthy.png" alt="">
                    </div>
                    <div class="fragment" style="grid-column: 1; grid-row: 2">John MacCarthy</div>
                </div>
                <div class="fragment">
                    <div style="grid-column: 2; grid-row: 1/2">
                        <a href="http://www-formal.stanford.edu/jmc/recursive.pdf"><img style="border: thin solid black" src="./images/Lisp.png" alt=""></a>
                    </div>
                </div>
            </div>

            <aside class="notes">
                John McCarthy (1927-2011)
                <ul>
                    <li>Chercheur Ã  l'universitÃ© de Standford essentiellement</li>
                    <li>Prix Turing 1971</li>
                    <li>Co-inventeur des systÃ¨mes Ã  temps partagÃ©</li>
                    <li>Pionnier de l'IA (on lui doit le terme)</li>
                    <li>1956 : Algorithme Alpha-BÃ©ta</li>
                    <li>1958 : Lisp - LISt Processing</li>
                    <li>Premier langage de manipulation symbolique</li>
                    <li>Second langage aprÃ¨s FORTRAN (1954)</li>
                </ul>
            </aside>
        </section>

        <section>
            <a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf"><img src="./images/HistoryOfLisp.png" alt=""></a>
            <aside class="notes">
                Lisp est un langage conÃ§u avant pour la manipulation symbolique, par opposition Ã  FORTRAN dont le but et
                le calcul numÃ©rique. L'idÃ©e Ã©tait d'avoir un langage facilitant l'Ã©criture d'algorithmes tels que la
                dÃ©rivation symbolique de fonctions (une des premiÃ¨res applications) et largement adoptÃ© de ce fait dans
                la recherche en IA et en thÃ©orie des langages (de programmation ou naturels)...
            </aside>
        </section>

        <section>
            <img src="./images/HistoryOfLispHighlighted.png" alt="">
            <aside class="notes">
                Et de maniÃ¨re assez cocasse, c'Ã©tait Ã  l'origine un langage sans fonctions d'ordre supÃ©rieur avec une
                syntaxe proche de FORTRAN (le M-language) permettant de manipuler des structures de liste (le S-language).
                Rapidement, on s'est aperÃ§u qu'il est possible de plonger le premier dans le second grace aux fonctions
                EVAL et APPLY, rendant LISP homo iconique. C'est-Ã -dire que la structure du langage et structure des donnÃ©es
                manipulÃ©es est identique. Ã‡a ouvre une porte Ã  la mÃ©ta-programmation qui s'apparente Ã  la rÃ©flexivitÃ©.
            </aside>
        </section>

        <section>
            <h1>Funarg Problem</h1>
            <aside class="notes">
                Dans la foulÃ©e, LISP gagne les fonctions d'ordre supÃ©rieur et la possibilitÃ© de dÃ©finir des fonctions
                anonymes, des LAMBDAS. Un argument fonctionnel de fonction est ce que l'on nomme FUNARG dans le jargon
                Lispien.
                <br><br>
                J'ai cru pendant longtemps de LISP Ã©tait avant tout fonctionnel et avait Ã©tÃ© inspirÃ©
                pas le lambda calcul. En fait LISP 1.5 Ã©tait encore trÃ¨s impÃ©ratif (SETQ, RPLACA...) et McCarthy aurait
                indiquÃ© en avoir Ã©tÃ© peu inspirÃ©.
            </aside>
        </section>

        <section>
            <a href="https://dspace.mit.edu/bitstream/handle/1721.1/5854/AIM-199.pdf"><img style="border: thin solid black; margin-bottom: 100%; margin-top: 3em" src="./images/funarg-problem.png" alt=""></a>
            <aside class="notes">
                Sauf que dans les premiÃ¨res moutures de LISP, les FUNARG avaient un problÃ¨me Ã©tudiÃ© (ici par Joel Moses
                dans un mÃ©mo de MIT) et longuement dÃ©battu.
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px">
                                fun longComputation(x: Int): Int {
                                    return x * x
                                }

                                fun parametricPredicate(x: Int): (Int) -> Boolean {
                                    val c = longComputation(x)
                                    return { y -> c % y == 0 }
                                }

                                fun main() {
                                    val c = 42
                                    val predicate: (Int) -> Boolean = parametricPredicate(3)
                                    if (predicate(81)) println("Ok") else println("Ko")
                                }
            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                Pour illustrer ce problÃ¨me, reprenons notre exemple (pas en LISP bien sÃ»r). C'est peu ou prou l'exemple
                initial, mais l'appel Ã  Â« filter Â» et avec une variable Â« c Â» dÃ©finie dans Â« main Â».
            </aside>

        </section>

        <section>
            <h2>Les fonctions <span class="green">(rÃ©cursives)</span> dÃ©cortiquÃ©es</h2>
            <a style="margin-bottom: 100%" href="https://www.youtube.com/watch?v=aTDSZtHCIGU"><img src="./images/Devoxx-2022.png" alt=""></a>
            <aside class="notes">
                En passant, je me permets une petite promotion Ã©hontÃ©e pour une de mes prÃ©sentations passÃ©es qui parle des
                fonctions, Ã©ventuellement rÃ©cursives, et de leur mise en Å“uvre. PrÃ©sentation qui pourrait Ãªtre un
                complÃ©ment intÃ©ressant Ã  celle-ci.
            </aside>

        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/1.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Nous allons suivre pas Ã  pas le dÃ©roulement de ce programme. Comme je l'explique plus en dÃ©tail dans
                mon autre prÃ©sentation, l'environnement d'exÃ©cution d'une fonction est fourni par un enregistrement
                d'activation plus tous ceux des fonctions appelantes. Un enregistrement est crÃ©Ã© Ã  l'activation de la
                fonction et dÃ©truit quand elle se termine. Et dans la plupart des langages (mais pas tous) cette gestion
                se fait sous forme de pile.
                <br><br>
                Donc ici on commence avec l'enregistrement d'activation de Â« main Â» dans la pile.
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    <span class="ch">val c = 42</span>
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/2.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Â« c Â» se voit affecter la valeur 42
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/2.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Puis on appelle la fonction Â« parametricPredicate Â» currifiÃ©e avec 3 en argument.
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = <span class="ch">longComputation(x)</span>
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/3.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Ce qui gÃ©nÃ¨re un nouvel enregistrement d'activation pour elle sur la pile. Ã€ son tour Â« longComputation Â»
                est appelÃ©e avec 3 en argument.
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = <span class="ch">longComputation(x)</span>
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return <span class="ch">x * x</span>
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/4.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Et un nouvel enregistrement d'activation lui est allouÃ©e. Â« longComputation Â» produit et retourne son
                rÃ©sultat 9.
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = <span class="ch">longComputation(x)</span>
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/5.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Qui est affectÃ© Ã  Â« c Â» dans l'environnement de Â« parametricPredicate Â».
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return <span class="ch">{ y -> c % y == 0 }</span>
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/5.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Et c'est que les AthÃ©niens s'atteignirent ! Â« parametricPrÃ©dicate Â» doit retourner une fonction
                anonyme, et naÃ¯vement, on pourrait considÃ©rer (comme en langage C par exemple) qu'il s'agit d'un pointeur
                sur fonction.
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/6.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Ici l'adresse du code compilÃ© de la fonction Â« @Lambda0 Â» est retournÃ© et affectÃ© Ã  la variable
                Â« predicate Â» dans l'environnement de Â« main Â».
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if <span class="ch">(predicate(81))</span> println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/6.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Puis on appelle Â« predicate Â» avec 81 en paramÃ¨tre Ã  tester... Donc, on lui alloue un enregistrement
                d'activation.
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if <span class="ch">(predicate(81))</span> println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/7.svg"></object>
                </div>
            </div>
            <aside class="notes">
                Mais dans cet environnement Â« c Â» n'a pas de valeur, alors on remonte la chaÃ®ne des environnements pour
                en trouver une. On tombe sur le 42 initial. Et lÃ , c'est le drame ! On s'attend Ã  un rÃ©sultat positif
                (81 est divisible par 9 en nombre entier), pourtant c'est faux parce que la lambda n'utilise pas la
                bonne valeur de Â« c Â». Il pourrait mÃªme ne pas y avoir de valeur pour Â« c Â».
                <br><br>
                Ã€ vrai dire, je ne sais pas ce qui est le pire entre un programme qui plante clairement ou qui rÃ©pond Ã 
                cÃ´tÃ© sans que l'on s'en aperÃ§oive.
                <br><br>
                Alors ne nous mÃ©prenons pas : cela peut Ãªtre considÃ©rÃ© comme une fonctionnalitÃ© lÃ©gitime. Ã‡a s'appelle
                de la liaison dynamique. Et pendant longtemps, le sujet a Ã©tÃ© dÃ©battu, avec ses partisans et ces dÃ©tracteurs.
                Et c'est mÃªme devenu un idÃ®ome LISP. On parle d'idÃ®ome dans un langage quand un design pattern est trÃ¨s
                liÃ© Ã  la sÃ©mantique du langage.
                <br><br>
                Je serais enclin Ã  dire, si l'on se place dans un cadre de programmation fonctionnelle, que le principe
                de raisonnement local est mis Ã  mal par un tel mÃ©canisme. Quand je code, j'ai du mal avec les effets
                contextuels d'utilisation d'une fonction autre que ses paramÃ¨tres d'entrÃ©e.
            </aside>
        </section>

        <section>
            <h1>Scheme</h1>
            <h2>1975</h2>
            <aside class="notes">
                Donc le sujet est dÃ©battu pendant plus de 15 ans dans le monde lispien. Jusqu'Ã  l'arrivÃ©e de SCHEME.
            </aside>
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: auto auto; grid-template-rows: auto auto">
                <div>
                    <div style="grid-column: 1; grid-row: 1">
                        <img src="./images/Guy_Steele.jpg" alt="">
                    </div>
                    <div class="fragment" style="grid-column: 1; grid-row: 2">Guy L. Steele Jr.</div>
                </div>
                <div class="fragment">
                    <div style="grid-column: 2; grid-row: 1/2">
                        <a href="https://media.githubusercontent.com/media/sarabander/sicp-pdf/master/sicp.pdf"><img src="./images/SICP.png" alt=""></a>
                    </div>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>CrÃ©ateur d'Emacs avec David Moon</li>
                    <li>David Moon futur Symbolics (machines langage LISP)</li>
                    <li>Premier portage de TeX</li>
                    <li>Co-crÃ©ateur de Scheme (1975) avec Gerald Sussmann</li>
                    <li>EmployÃ© par Thinking Machines (*Lisp et C*)</li>
                    <li>EmployÃ© par Sun (1994) puis Oracle (2010)</li>
                    <li>CommitÃ©s de normalisation de Common Lisp, C, Fortran</li>
                    <li>Verse d'Epic Games avec Simon Peyton-Jones</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: auto auto; grid-template-rows: auto auto">
                <div>
                    <div style="grid-column: 1; grid-row: 1">
                        <img src="./images/Guy_Steele.jpg" alt="">
                    </div>
                    <div style="grid-column: 1; grid-row: 2">Guy L. Steele Jr.</div>
                </div>
                <div>
                    <div style="grid-column: 2; grid-row: 1/2">
                        <a href="https://dspace.mit.edu/bitstream/handle/1721.1/5753/AIM-443.pdf"><img style="border: thin solid black" src="./images/LambdaTheUltimate.png" alt=""></a>
                    </div>
                </div>
            </div>
            <aside class="notes">
                Il est aussi l'auteur des Â« Î» the ultimate Â» papers. C'est une sÃ©rie d'articles parfois coÃ©crits avec
                Sussmann, qui prend le partit de la liaison lexicale. Il s'agit de faire en sorte, mÃªme au prix d'un
                surcoÃ»t Ã  l'exÃ©cution d'un programme, que les variables libres d'une lambda prennent la valeur qu'elles
                avaient au moment de leur dÃ©finition et non au moment de l'exÃ©cution.
                <br><br>
                Et au travers de multiples exemples, il montre toute l'utilitÃ© de ce concept.
            </aside>
        </section>

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;  display: grid; grid-template-columns: 3fr 2fr">
                <div style="justify-self: center">$x$</div>
                <div style="justify-self: start"> Variable</div>
                <div style="justify-self: center">$\lambda x.\,M$</div>
                <div style="justify-self: start"> Abstraction</div>
                <div style="justify-self: center; margin-bottom: 2.5em">$M\,N$</div>
                <div style="margin-bottom: 2.5em; justify-self: start"> Application</div>
                <div style="justify-self: center">$\lambda x.\,(f\,x) \rightarrow f$</div>
                <div style="justify-self: start">$\eta$-reduction</div>
                <div style="justify-self: center">$\lambda x.\,M[x] \rightarrow \lambda y.\,M[y]$</div>
                <div style="justify-self: start">$\alpha$-conversion</div>
                <div class="yellow" style="justify-self: center">$(\lambda x.\,M)\:E \rightarrow M[x:=E]$</div>
                <div class="yellow" style="justify-self: start">$\beta$-reduction</div>
            </div>
            <aside class="notes">
                Pour la peine, la liaison lexicale est au fondement de l'interprÃ©tation du lambda calcul.
            </aside>
        </section>

        <section>
            <a href="https://www.cs.tufts.edu/comp/150FP/archive/peter-landin/mechanical-eval.pdf"><img style="border: thin solid black; margin-bottom: 100%; margin-top: 3em" src="./images/Landin.png" alt=""></a>
            <aside class="notes">
                Et sa mise en Å“uvre concrÃ¨te est depuis longtemps comprise, comme dans cet article fondateur de Peter Landin
                datant de 1964 ! Accessoirement lui doit aussi le terme Â« sucre syntaxique Â» !
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return <span class="ch">{ y -> c % y == 0 }</span>
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/5.svg"></object>
                </div>
            </div>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/6.svg"></object>
                </div>
            </div>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/7.svg"></object>
                </div>
            </div>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if <span class="ch">(predicate(81))</span> println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> c % y == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/8.svg"></object>
                </div>
            </div>
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 2fr">
                <div style="grid-column: 1; grid-row: 1">
                    <img src="./images/Haskell-logo.png" alt="">
                </div>
                <div class="fragment" data-fragment-index="1" style="grid-column: 1; grid-row: 2">
                    <a href="https://www.cambridge.org/core/services/aop-cambridge-core/content/view/S0956796800000319"><img style="border: solid black 1px; margin-top: 2.5em" src="./images/Haskell.png" alt=""></a>
                </div>
                <div style="grid-column: 2; grid-row: 1">
                    <img src="./images/OCaml-logo.png" alt="">
                </div>
                <div class="fragment" data-fragment-index="1" style="grid-column: 2; grid-row: 2">
                    <a href="https://inria.hal.science/inria-00070049/document"><img style="border: solid black 1px; margin-top: 2.5em" src="./images/OCaml.png" alt=""></a>
                </div>
            </div>
        </section>

        <section>
            <h1>Clojure</h1>
            <h2>2007</h2>
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: auto auto; grid-template-rows: auto auto">
                <div>
                    <div style="grid-column: 1; grid-row: 1">
                        <img src="./images/Hickey.png" alt="">
                    </div>
                    <div class="fragment" style="grid-column: 1; grid-row: 2">Rich Hickey</div>
                </div>
                <div class="fragment">
                    <div style="grid-column: 2; grid-row: 1/2">
                        <a href="https://dl.acm.org/doi/pdf/10.1145/3386321"><img style="border: thin solid black" src="./images/Clojure.png" alt=""></a>
                    </div>
                </div>
            </div>

           <aside class="notes">
            </aside>
        </section>

        <section>
            <h1><span style="text-transform:lowercase">$\lambda$</span>-lifting</h1>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre class="fragment" style="font-size: 1.1ex; margin-top: 1em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicateLambda(c: Int, yy: Int): Boolean = yy % c == 0

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> parametricPredicateLambda(c, y) }
                        }

            </code><div class="lang">Kotlin</div></pre>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        <span class="ch">fun parametricPredicateLambda(c: Int, yy: Int): Boolean = yy % c == 0</span>

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> parametricPredicateLambda(c, y) }
                        }

            </code><div class="lang">Kotlin</div></pre>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicateLambda(c: Int, yy: Int): Boolean = yy % c == 0

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> <span class="ch">parametricPredicateLambda(c, y)</span> }
                        }

            </code><div class="lang">Kotlin</div></pre>
        </section>

        <section>
            <h1>Closure conversion</h1>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(<span class="ch">val capture: C</span>, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, <span class="ch">val code: (C, I) -> O</span>)

            </code><div class="lang">Kotlin</div></pre>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): Closure&lt;Int, Int, Boolean&gt; {
                            val c = longComputation(x)
                            return Closure(c, ::parametricPredicateLambda)
                        }

                        fun main() {
                            val c = 42
                            val predicate: Closure&lt;Int, Int, Boolean> = parametricPredicate(3)
                            if (predicate.code(predicate.capture, 81)) println("Ok") else println("Ko")
                        }

            </code><div class="lang">Kotlin</div></pre>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): Closure&lt;Int, Int, Boolean&gt; {
                            val c = longComputation(x)
                            return <span class="ch">Closure(c, ::parametricPredicateLambda)</span>
                        }

                        fun main() {
                            val c = 42
                            val predicate: Closure&lt;Int, Int, Boolean> = parametricPredicate(3)
                            if (predicate.code(predicate.capture, 81)) println("Ok") else println("Ko")
                        }

            </code><div class="lang">Kotlin</div></pre>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): Closure&lt;Int, Int, Boolean&gt; {
                            val c = longComputation(x)
                            return Closure(c, ::parametricPredicateLambda)
                        }

                        fun main() {
                            val c = 42
                            val predicate: Closure&lt;Int, Int, Boolean> = parametricPredicate(3)
                            if (<span class="ch">predicate.code(predicate.capture, 81)</span>) println("Ok") else println("Ko")
                        }

            </code><div class="lang">Kotlin</div></pre>
        </section>

        <section>
            <h1>Java 8</h1>
            <h2>2014</h2>
        </section>

        <section>
            <img style="border: thin solid" src="./images/JSR335.png" alt="">
        </section>

        <section>
            <a href="http://gafter.blogspot.com/2007/01/definition-of-closures.html"><img style="border: thin solid black" src="./images/Gafter.png" alt=""></a>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

  public static final kotlin.jvm.functions.Function1&lt;java.lang.Integer, java.lang.Boolean&gt; parametricSieve(int);
    descriptor: (I)Lkotlin/jvm/functions/Function1;
    flags: (0x0019) ACC_PUBLIC, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=2, args_size=1
         0: iload_0
         1: invokestatic  #14                 // Method longComputation:(I)I
         4: istore_1
         5: iload_1
         6: invokedynamic #33,  0             // InvokeDynamic #0:invoke:(I)Lkotlin/jvm/functions/Function1;
        11: areturn
      LineNumberTable:
        line 8: 0
        line 9: 5
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            5       7     1     c   I
            0      12     0     x   I
    Signature: #11                          // (I)Lkotlin/jvm/functions/Function1&lt;Ljava/lang/Integer;Ljava/lang/Boolean;&gt;
    RuntimeInvisibleAnnotations:
      0: #12()
        org.jetbrains.annotations.NotNull

            </code></pre>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

  public static final kotlin.jvm.functions.Function1&lt;java.lang.Integer, java.lang.Boolean&gt; parametricSieve(int);
    descriptor: (I)Lkotlin/jvm/functions/Function1;
    flags: (0x0019) ACC_PUBLIC, ACC_STATIC, ACC_FINAL
    Code:
      stack=1, locals=2, args_size=1
         0: iload_0
         1: invokestatic  #14                 // Method longComputation:(I)I
         4: istore_1
         5: iload_1
         6: <span class="ch">invokedynamic</span> #33,  0             // InvokeDynamic #0:invoke:(I)Lkotlin/jvm/functions/Function1;
        11: areturn
      LineNumberTable:
        line 8: 0
        line 9: 5
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            5       7     1     c   I
            0      12     0     x   I
    Signature: #11                          // (I)Lkotlin/jvm/functions/Function1&lt;Ljava/lang/Integer;Ljava/lang/Boolean;&gt;
    RuntimeInvisibleAnnotations:
      0: #12()
        org.jetbrains.annotations.NotNull

            </code></pre>
        </section>

        <section>
            <h1>Conclusion</h1>
        </section>

        <section>
            <div style="display: flex; justify-content: space-between">
                <div style="margin-left: 2em; display: flex; flex-direction: column">
                    <div style="margin-top: 1em; font-size: 1.55em; text-align: left" class="green">FrÃ©dÃ©ric Cabestre</div>
                </div>
            </div>
            <h1 style="margin-top: 1.5em">Merci</h1>
            <div style="display: grid; grid: 'one two three four' / 1fr 1fr 1fr 1fr">
                <img style="grid-area: four; margin-bottom: 100%" src="./images/qrcode.png" alt="QR code">
            </div>
        </section>
    </div>
</div>

<script src="./dist/reveal.js"></script>
<script src="./plugin/notes/notes.js"></script>
<script src="./plugin/markdown/markdown.js"></script>
<script src="./plugin/highlight-old/highlight.js"></script>
<script src="./plugin/math/math.js"></script>

<script>
    Reveal.initialize({
        controls: false,
        progress: false,
        history: true,
        center: true,
        width: 1600,
        height: 900,

        transition: "none",

        plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX],

        katex: {
            local: " ",
            trust: true
        },
    });
</script>
</body>
</html>
