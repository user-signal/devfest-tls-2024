<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>

    <title>Ferm√© pour inventaire</title>

    <meta name="description" content="Histoire et m√©canique des ¬´ closures ¬ª"/>
    <meta name="author" content="Fr√©d√©ric Cabestre"/>

    <link rel="stylesheet" href="./dist/reset.css">
    <link rel="stylesheet" href="./dist/reveal.css">
    <link rel="stylesheet" href="./dist/theme/transparents.css" id="theme"/>

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="./plugin/highlight/zenburn.css"/>
</head>

<body>
<div class="reveal">
    <div class="slides">

        <section>
            <h1>Ferm√© pour inventaire</h1>
            <h3>Histoire et m√©canique des ¬´ closures ¬ª</h3>
            <aside class="notes">
                Bonjour √† tous, et merci d'avoir choisi cette session dans laquelle il ne sera question ni de Kubernetes,
                ni d'IA... Quoique ? Il y sera en revanche question fonctions anonymes et de leur mise en ≈ìuvre. Et cel√†
                au travers de nombreux fragments de code qui devraient √™tre suffisamment faciles √† suivre. Dans tous les
                cas √† la fin vous trouverez des pointeurs vers cette pr√©sentation elle-m√™me et le code associ√© sur GitHub.
            </aside>
        </section>

        <section>
            <div style="display: flex; justify-content: space-between">
                <div style="margin-left: 2em; display: flex; flex-direction: column">
                    <div style="margin-top: 1em; font-size: 1.55em; text-align: left" class="green">Fr√©d√©ric Cabestre</div>
                </div>
            </div>
            <blockquote style="margin-top: 8em; margin-right: 2em; margin-bottom: 100%">
                Soy cantor, soy embustero<br>
                Me gusta el juego y el vino, tengo alma de marinero<br>
                ¬øQu√© le voy a hacer si yo nac√≠ en el Mediterr√°neo?
                <div style="margin-top:1ex; font-size: smaller">&mdash; Juan Manuel Serrat</div>
            </blockquote>
<!--            <blockquote style="margin-top: 11.45em; margin-right: 2em; margin-bottom: 100%">-->
<!--                Le pr√©sent sans pass√© n'a pas d'avenir-->
<!--                <div style="font-size: smaller">&mdash; <a href="https://fr.wikipedia.org/wiki/Fernand_Braudel">Fernand Braudel</a></div>-->
<!--            </blockquote>-->
            <aside class="notes">
                Je suis Fr√©d√©ric Cabestre, un artisan du logiciel ind√©pendant issu il y a fort longtemps du monde
                acad√©mique... Ce qui a laiss√© quelques traces. Si vous avez des soucis avec des sujets √©sot√©riques ou
                tout simplement besoin de faire accompagner une √©quipe de d√©veloppement, vous pouvez me contacter...
                Vous trouverez bien comment faire.
            </aside>
        </section>

        <section>
            <h1><span style="font-size:2em;text-transform:lowercase">$\lambda$</span></h1>
            <aside class="notes">
                <ul>
                    <li>Fonctions d'ordre sup√©rieur</li>
                    <li>Outils de base</li>
                    <li>Citoyen de premi√®re classe</li>
                    <li>Valeur fonctionnelle</li>
                    <li>Lambda / anonyme</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Les fonctions d'ordre sup√©rieur (c'est-√†-dire dont les param√®tres sont des fonctions ou dont la valeur de-->
<!--                retour peut √™tre une fonction) font d√©finitivement partie de l'outillage de base du d√©veloppeur.-->
<!--                <br><br>-->
<!--                Pour cel√† les fonctions sont devenues des entit√©s de premi√®re classe des langages de programmation. Autrement dit-->
<!--                ce sont des valeurs √† part enti√®re que l'on peut par exemple affecter √† des variables.-->
<!--                <br><br>-->
<!--                Il n'est d'ailleurs m√™me plus n√©cessaire de les nommer pour pouvoir les d√©finir. Nous pouvons cr√©er des fonctions anonymes-->
<!--                commun√©ment appel√©es ¬´ lambdas ¬ª.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px">

                                val aList = 1..100
                                val filteredList = aList.filter({ x -> x % 2 == 0 })
                                println(filteredList)

                                /*

                                  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
                                   28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50,
                                   52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
                                   76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100]

                                */

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>Kotlin</li>
                    <li>C#, Rust, Java ou Javascript</li>
                    <li>pas de trouble, typage </li>
                    <li>contrairement √†...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Dans ce qui suit l'essentiel des exemples de code seront en Kotlin. J'aurais pu m'appuyer sur C#, Rust, Java-->
<!--                ou Javascript... Non, quand m√™me pas Javascript ! Mais Kotlin c'est mon langage du moment, dont la lecture-->
<!--                ne devrait pas vous troubler. Contrairement √†...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="language-lisp" style="max-height: 800px">

                    (defun filter (fn list)
                        (cond ((null list) nil)
                              (t (cond ((funcall (eval fn) (car list)) (cons (car list) (filter fn (cdr list))))
                                       (t (filter fn (cdr list)))))))

                    (filter '(lambda (x) (= (mod x 2) 0)) '(1 2 3 4 5 6))

            </code><div class="lang">Lisp</div></pre>
            <aside class="notes">
                <ul>
                    <li>Common Lisp</li>
                    <li>Fil rouge historique</li>
                    <li>Enseign√© √† la fac</li>
                    <li>Bav√©</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                ... Common Lisp. Si Lisp va √™tre une sorte de fil rouge historique de cette pr√©sentation, je n'avais pas-->
<!--                envie de vous perdre b√™tement en route. D'autant que, moi qui ai enseign√© en TP de Lisp √† la Fac il y a-->
<!--                plus de 25 ans, j'en ai un peu bav√© pour √©crire cet exemple pourtant simple.-->
<!--            </aside>-->
        </section>

        <section>

            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                                val aList = 1..100
                                val filteredList = aList.filter({ x -> x % 2 == 0 })
                                println(filteredList)

                                /*

                                  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
                                   28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50,
                                   52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
                                   76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100]

                                */

            </code><div class="lang">Kotlin</div></pre>
            <pre class="fragment" style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        public inline fun &lt;T&gt; <span class="ch">Iterable&lt;T&gt;</span>.filter(predicate: (T) -> Boolean): List&lt;T&gt; {
                            return filterTo(ArrayList&lt;T&gt;(), predicate)
                        }

            </code><div class="lang">Kotlin</div></pre>
           <aside class="notes">
               <ul>
                   <li>Intention plus que proc√©dure</li>
                   <li>Filter...</li>
               </ul>
           </aside>
<!--           <aside class="notes">-->
<!--               Cet attirail permet d'exprimer plus l'intention que la proc√©dure √† suivre. Par exemple ici en disposant d'une-->
<!--               fonction ¬´ filter ¬ª sur des collections, √† laquelle on peut fournir un pr√©dicat, il n'est plus besoin de s'appesantir-->
<!--               sur les d√©tails d'une it√©ration. La d√©marche est plus d√©clarative que proc√©durale.-->
<!--           </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                                val aList = 1..100
                                val filteredList = aList.filter({ x -> x % 2 == 0 })
                                println(filteredList)

                                /*

                                  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
                                   28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50,
                                   52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
                                   76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100]

                                */
                
            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        public inline fun &lt;T&gt; Iterable&lt;T&gt;.filter(predicate: <span class="ch">(T) -> Boolean</span>): List&lt;T&gt; {
                            return filterTo(ArrayList&lt;T&gt;(), predicate)
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>... iterable, pr√©dicat en param√®tre</li>
                    <li>D√©marche plus d√©clarative que proc√©durale</li>
                </ul>
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        (Int) -> Boolean

                        <span class="fragment">(Int, String) -> String</span>

                        <span class="fragment">((Float) -> Float) -> Float</span>

                        <span class="fragment">(Float) -> (Float) -> Float</span>

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>fonctions citoyens de premi√®re classe</li>
                    <li>description type</li>
                    <li>exemple</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                En Kotlin les fonctions sont des citoyens de premi√®re classe, et en tant que telles, on doit pouvoir en-->
<!--                d√©crire le type. Ici, nous avons plusieurs exemples. Le type des fonctions qui prennent :-->
<!--                <ul>-->
<!--                   <li>un entier en param√®tre et retournent un booleen</li>-->
<!--                   <li>une paire entier, cha√Æne de caract√®re en param√®tre et retournent un booleen</li>-->
<!--                   <li>une fonction de flottant vers flottant et retournent un flottant</li>-->
<!--                   <li>un flottant et retournent une fonction de flottant vers flottant </li>-->
<!--                </ul>-->
<!--                Notez l'importance des parenth√®ses entre les deux derniers exemples, du fait de l'associativit√© √† droite-->
<!--                de l'op√©rateur ->.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        aList.filter(<span class="ch">{ x -> x % 2 == 0 }</span>)

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>lambda surbrillance</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Dans cet exemple la partie en surbrillance est donc une lambda prenant en param√®tre un entier et v√©rifiant-->
<!--                s'il est pair (le reste de la division par 2 doit √™tre 0).-->
<!--            </aside>-->
        </section>

<!--        <section>-->
<!--            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>-->

<!--                        aList.filter(<span class="ch">{ x -> x % 2 == 0 }</span>)-->

<!--            </code><div class="lang">Kotlin</div></pre>-->
<!--            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>-->

<!--                        aList.filter({ x<span class="ch">: Int</span> -> x % 2 == 0 })-->

<!--            </code><div class="lang">Kotlin</div></pre>-->
<!--            <aside class="notes">-->
<!--                <ul>-->
<!--                    <li>Inf√©rence type</li>-->
<!--                </ul>-->
<!--            </aside>-->
<!--            <aside class="notes">-->
<!--                Kotlin, comme beaucoup de langages aujourd'hui, dispose de capacit√©s d'inf√©rence de type. Ce qui permet-->
<!--                dans une certaine mesure de s'√©conomiser quelques annotations de type.-->
<!--            </aside>-->
<!--        </section>-->

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        aList.filter({ x -> x % 2 == 0 })

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        aList.filter({ <span class="ch">it</span> % 2 == 0 })

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>Particularit√© Kotlin</li>
                    <li>it</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Particularit√© de Kotlin, on peut dans certains cas, comme ici, nommer implicitement un param√®tre unique-->
<!--                ¬´ it ¬ª.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        aList.filter({ x -> x % 2 == 0 })

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        aList.filter({ it % 2 == 0 })

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        aList.filter { it % 2 == 0 }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>Particularit√© Kotlin</li>
                    <li>lambda en derni√®re position des param√®tre</li>
                    <li>Groovy</li>
                    <li>DSL embarqu√©s</li>
                    <li>Mais pas le meilleur exemple...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et autre particularit√© de Kotlin, une lambda en derni√®re position des param√®tres d'une fonction peut √™tre-->
<!--                sortie de la liste des param√®tres. C'est un emprunt √† Groovy, je crois, qui contribue √† faire de Kotlin-->
<!--                un langage sympathique pour faire des DSL embarqu√©s... Mais √ßa sera l'objet d'une autre pr√©sentation.-->
<!--                Qui sait ?-->
<!--                <br><br>-->
<!--                En tout √©tat de cause, cet exemple n'est pas des plus int√©ressants pour notre exploration...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun longComputation(x: Int): Int {
                            return x * x // ü§°
                        }

                        fun parametricPredicate(x: Int, y: Int): Boolean {
                            val c = longComputation(x)
                            return y % c == 0
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre class="fragment" style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px">

                        fun main() {
                            val aList = 1..100
                            val filteredList = aList.filter { y -> parametricPredicate(3, y) }
                            println(filteredList)

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>pr√©dicat ajustable</li>
                    <li>long calcul</li>
                    <li>tir√© par les cheveux</li>
                    <li>adapter avec fonction anonyme</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Consid√©rons plut√¥t celui-ci¬†: un pr√©dicat ajustable par son premier param√®tre ( ¬´ x ¬ª) pour v√©rifier une-->
<!--                propri√©t√© du second param√®tre (¬´ y ¬ª). Et tant qu'√† faire, cet ajustement est le r√©sultat d'un calcul-->
<!--                arbitrairement long effectu√© sur ¬´ x ¬ª.-->
<!--                <br><br>-->
<!--                Je vous l'accorde, c'est un exemple tir√© par le peu de cheveux qu'il me reste. Mais il faut faire simple-->
<!--                pour parler de choses compliqu√©es.-->
<!--                <br><br>-->
<!--                Et si l'on veut utiliser ce pr√©dicat √† deux arguments, dans le m√™me contexte que pr√©c√©demment, il va-->
<!--                falloir l'adapter, √† l'aide d'une fonction anonyme...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun longComputation(x: Int): Int {
                            return x * x // ü§°
                        }

                        fun parametricPredicate(x: Int, y: Int): Boolean {
                            val c = longComputation(x)
                            return y % c == 0
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val filteredList = aList.filter <span class="ch">{ y -> parametricPredicate(3, y) }</span>
                            println(filteredList)

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>ramener √† un seul param√®tre</li>
                    <li>¬´ longComputation ¬ª √† chaque it√©ration de ¬´ filter ¬ª</li>
                    <li>sortir ce long calcul de ¬´ parametricPredicate ¬ª</li>
                    <li>application partielle</li>
                    <li>...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                ... en fixant le premier argument pour le ramener √† un seul param√®tre √† tester.-->
<!--                <br><br>-->
<!--                Un inconv√©nient de cette approche est que ¬´ longComputation ¬ª sera effectu√©e √† chaque it√©ration de ¬´ filter ¬ª.-->
<!--                <br><br>-->
<!--                Une fa√ßon de r√©soudre ce probl√®me est de sortir ce long calcul de ¬´ parametricPredicate ¬ª. Mais j'ai envie-->
<!--                de vous pr√©senter une autre approche qui serait de pouvoir appliquer partiellement ¬´ parametricPredicate ¬ª √†-->
<!--                un argument. Et pour cela je dois vous parler de...-->
<!--            </aside>-->
        </section>

        <section>
            <h1>Curryfication</h1>
            <aside class="notes">
                <ul>
                    <li>Haskell Curry</li>
                    <li>logicien 20·µâ si√®cle</li>
                    <li>logique combinatoire</li>
                    <li>langage Haskell</li>
                    <li>Moses Sch√∂nfinkel</li>
                    <li>De quoi s'agit-il ?</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Ce terme est d√©riv√© du nom d'Haskell Curry, un logicien du 20·µâ si√®cle ayant men√© des travaux sur la logique-->
<!--                combinatoire et qui donn√© son pr√©nom √† un c√©l√®bre langage fonctionnel. En r√©alit√© ce concept-->
<!--                est plut√¥t d√ª √† Moses Sch√∂nfinkel, mais Sch√∂nfinkelification aurait √©t√© plus difficile √† prononcer.-->
<!--                <br><br>-->
<!--                Alors de quoi s'agit-il ?-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;  display: grid; grid-template-rows: 2fr 1fr">
                <div style="margin-top: .5em; font-size: 2.11em">$f: (A, B) \rightarrow C$</div>
                <div class="fragment" style="margin-top: .25em; font-size: 2.11em">$f: A \rightarrow (B \rightarrow C)$</div>
            </div>
            <aside class="notes">
                <ul>
                    <li>fonction √† 2 param√®tres...</li>
                    <li>r√©cursivement N param√®tres...</li>
                    <li>application partielle</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Tout simplement de voir une fonction √† 2 param√®tres...-->
<!--                <br><br>-->
<!--                ... comme √©quivalente √† une fonction √† un param√®tre produisant un autre fonction √† un param√®tre.-->
<!--                <br><br>-->
<!--                Et donc comme une fonction que l'on peut appliquer partiellement ou graduellement √† plusieurs arguments.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int, y: Int): Boolean {
                            val c = longComputation(x)
                            return y % c == 0
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = { y -> parametricPredicate(3, y) }
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>exemple de ravail</li>
                    <li>curryfier  ¬´ parametricPredicate ¬ª...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Si l'on repart de notre example de travail, curryfier ¬´ parametricPredicate ¬ª revient √† le transformer ainsi...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = parametricPredicate(3)
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>Que peut-on constater ici ?</li>
                </ul>
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): <span class="ch">(Int) -> Boolean</span> {
                            val c = longComputation(x)
                            return <span class="ch">{ y -> y % c == 0 }</span>
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = parametricPredicate(3)
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>Un seul param√®tre</li>
                    <li>retourne une fonction</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Qu'elle ne prend plus qu'un seul param√®tre, celui qui va servir √† ¬´ longComputation ¬ª. Et que son type-->
<!--                indique bien qu'elle retourne une fonction de Int vers Boolean.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = <span class="ch">parametricPredicate(3)</span>
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>Affectation variable</li>
                    <li>citoyens de premi√®re classe...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Que l'on peut √©ventuellement affecter son r√©sultat √† une variable. N'oublions pas que les fonctions sont-->
<!--                ici des citoyens de premi√®re classe...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = parametricPredicate(3)
                            println(aList.filter(<span class="ch">predicate</span>))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>utilisation pour filter</li>
                    <li>long calcul 1 fois</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et donc qu'on peut utiliser ce r√©sultat comme pr√©dicat pour ¬´ filter ¬ª et accessoirement cette fois-->
<!--                le long calcul n'est effectu√© qu'une seule fois et non √† chaque it√©ration du filtre.-->
<!--            </aside>-->
        </section>

<!--        <section>-->
<!--            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>-->

<!--                        val parametricPredicate: (Int) -> (Int) -> Boolean = { x ->-->
<!--                            val c = longComputation(x);-->
<!--                            { y -> y % c == 0 }-->
<!--                        }-->

<!--            </code><div class="lang">Kotlin</div></pre>-->
<!--            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>-->

<!--                        fun main() {-->
<!--                            val aList = 1..100-->
<!--                            val predicate = parametricPredicate(3)-->
<!--                            println(aList.filter(predicate))-->

<!--                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */-->
<!--                        }-->

<!--            </code><div class="lang">Kotlin</div></pre>-->
<!--            <aside class="notes">-->
<!--                <ul>-->
<!--                    <li>un pas de plus...</li>-->
<!--                </ul>-->
<!--            </aside>-->
<!--            <aside class="notes">-->
<!--                Soit dit en passant, on aurait aussi pu faire un pas de plus et dire que ¬´ parametricPredicate ¬ª est...-->
<!--            </aside>-->
<!--        </section>-->

<!--        <section>-->
<!--            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>-->

<!--                        val parametricPredicate: <span class="ch">(Int) -> (Int) -> Boolean</span> = { x ->-->
<!--                            val c = longComputation(x);-->
<!--                            { y -> y % c == 0 }-->
<!--                        }-->

<!--            </code><div class="lang">Kotlin</div></pre>-->
<!--            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>-->

<!--                        fun main() {-->
<!--                            val aList = 1..100-->
<!--                            val predicate = parametricPredicate(3)-->
<!--                            println(aList.filter(predicate))-->

<!--                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */-->
<!--                        }-->

<!--            </code><div class="lang">Kotlin</div></pre>-->
<!--            <aside class="notes">-->
<!--                <ul>-->
<!--                    <li>variable qui re√ßoit une fonction...</li>-->
<!--                    <li>mais bon...</li>-->
<!--                </ul>-->
<!--            </aside>-->
<!--            <aside class="notes">-->
<!--                ... une variable qui re√ßoit une fonction de Int qui retourne une fonction de Int vers Boolean.-->
<!--                Mais bon, restons l√†...-->
<!--            </aside>-->
<!--        </section>-->

        <section>
            <h1>Lisp 1.5</h1>
            <h2>1958</h2>
            <aside class="notes">
                Avant d'aller plus loin, faisons un premier saut en 1958 √† la naissance de LISP.
            </aside>
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: auto auto; grid-template-rows: auto auto">
                <div>
                    <div style="grid-column: 1; grid-row: 1">
                        <img src="./images/john-mccarthy.png" alt="">
                    </div>
                    <div class="fragment" style="grid-column: 1; grid-row: 2">John MacCarthy</div>
                </div>
                <div class="fragment">
                    <div style="grid-column: 2; grid-row: 1/2">
                        <a href="http://www-formal.stanford.edu/jmc/recursive.pdf"><img style="border: thin solid black" src="./images/Lisp.png" alt=""></a>
                    </div>
                </div>
            </div>

            <aside class="notes">
                <ul>
                    <li>Cet √©l√©gant barbu est...John McCarthy (1927-2011)</li>
                    <li>Stanford</li>
                    <li>prix Turing en 1971</li>
                    <li>temps partag√© (unix)</li>
                    <li>pionier IA (terminologie de lui)</li>
                    <li>algorithme Alpha-B√©ta></li>
                    <li>LISP (58) apr√®s FORTRAN (54)</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Cet √©l√©gant barbu est...-->
<!--                <br><br>-->
<!--                John McCarthy (1927-2011), chercheur de l'universit√© de Standford ayant obtenu-->
<!--                le prix Turing en 1971, il est co-inventeur des syst√®mes √† temps partag√© (pensez Unix) et pionnier de l'IA-->
<!--                (on lui doit le terme). En 1956, il cr√©e l'algorithme d'√©lagage Alpha-B√©ta utilis√© au c≈ìur de moteurs de-->
<!--                jeux pour les √©checs par exemple.-->
<!--                <br><br>-->
<!--                Mais il a aussi contribu√© √† la cr√©ation de LISP en 1958 second langage concret apr√®s FORTRAN (1954).-->
<!--            </aside>-->
        </section>

        <section>
            <a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf"><img src="./images/HistoryOfLisp.png" alt=""></a>
            <aside class="notes">
                <ul>
                    <li> manipulation symbolique</li>
                    <li>FORTRAN calcul num√©rique</li>
                    <li>d√©rivation symbolique de fonctions math√©matiques</li>
                    <li>recherche en IA et en th√©orie des langages</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Lisp est un langage con√ßu avant tout pour la manipulation symbolique, par opposition √† FORTRAN dont le but et-->
<!--                le calcul num√©rique. L'id√©e √©tait d'avoir un langage facilitant l'√©criture d'algorithmes tels que la-->
<!--                d√©rivation symbolique de fonctions (une des premi√®res applications) et largement adopt√© de ce fait dans-->
<!--                la recherche en IA et en th√©orie des langages (de programmation ou naturels)...-->
<!--            </aside>-->
        </section>

        <section>
            <img src="./images/HistoryOfLispHighlighted.png" alt="">
            <aside class="notes">
                <ul>
                    <li>initialement sans fonctions d'ordre sup√©rieur</li>
                    <li>syntaxe proche de FORTRAN (le M-language)</li>
                    <li>structures de liste (le S-language)</li>
                    <li>plongement EVAL, APPLY</li>
                    <li>homo iconique</li>
                    <li>garbage collector</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et de mani√®re assez cocasse, c'√©tait √† l'origine un langage sans fonctions d'ordre sup√©rieur avec une-->
<!--                syntaxe proche de FORTRAN (le M-language) permettant de manipuler des structures de liste (le S-language).-->
<!--                Rapidement, on s'est aper√ßu qu'il est possible de plonger le premier dans le second grace aux fonctions-->
<!--                EVAL et APPLY, rendant LISP homo iconique. C'est-√†-dire que la structure du langage et structure des donn√©es-->
<!--                manipul√©es est identique. √áa ouvre une porte √† la m√©ta-programmation qui s'apparente √† la r√©flexivit√©.-->
<!--            </aside>-->
        </section>

        <section>
            <h1>Funarg Problem</h1>
            <aside class="notes">
                <ul>
                    <li>fonctions d'ordre sup√©rieur</li>
                    <li>LAMBDAs</li>
                    <li>FUNARG</li>
                    <li>Pas si fonctionnel, pas lambda calcul</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Dans la foul√©e, LISP gagne les fonctions d'ordre sup√©rieur et la possibilit√© de d√©finir des fonctions-->
<!--                anonymes, des LAMBDAS. Un argument fonctionnel de fonction est ce que l'on nomme un FUNARG dans le jargon-->
<!--                Lispien.-->
<!--                <br><br>-->
<!--                J'ai cru pendant longtemps de LISP √©tait avant tout fonctionnel et avait √©t√© inspir√©-->
<!--                pas le lambda calcul. En fait LISP 1.5 √©tait encore tr√®s imp√©ratif (SETQ, RPLACA...) et McCarthy aurait-->
<!--                indiqu√© s'en √™tre peu inspir√©.-->
<!--            </aside>-->
        </section>

        <section>
            <a href="https://dspace.mit.edu/bitstream/handle/1721.1/5854/AIM-199.pdf"><img style="border: thin solid black; margin-bottom: 100%; margin-top: 3em" src="./images/funarg-problem.png" alt=""></a>
            <aside class="notes">
                <ul>
                    <li>FUNARG problem</li>
                    <li>Joel Moses</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Sauf que dans les premi√®res moutures de LISP, les FUNARG avaient un probl√®me √©tudi√© (ici par Joel Moses-->
<!--                dans un m√©mo de MIT) et longuement d√©battu.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px">
                                fun longComputation(x: Int): Int {
                                    return x * x
                                }

                                fun parametricPredicate(x: Int): (Int) -> Boolean {
                                    val c = longComputation(x)
                                    return { y -> y % c == 0 }
                                }

                                fun main() {
                                    val c = 42
                                    val predicate: (Int) -> Boolean = parametricPredicate(3)
                                    if (predicate(81)) println("Ok") else println("Ko")
                                }
            </code><div class="lang">Kotlin</div></pre>
<!--            <aside class="notes">-->
<!--                Pour illustrer ce probl√®me, reprenons notre exemple (pas en LISP bien s√ªr). C'est peu ou prou l'exemple-->
<!--                initial, mais sans l'appel √† ¬´ filter ¬ª et avec une variable ¬´ c ¬ª d√©finie dans ¬´ main ¬ª.-->
<!--            </aside>-->
            <aside class="notes">
                <ul>
                    <li>exemple sans appel √† filter</li>
                    <li>variable ¬´ c ¬ª dans main</li>
                </ul>
            </aside>

        </section>

        <section>
            <h2>Les fonctions <span class="green">(r√©cursives)</span> d√©cortiqu√©es</h2>
            <a style="margin-bottom: 100%" href="https://www.youtube.com/watch?v=aTDSZtHCIGU"><img src="./images/Devoxx-2022.png" alt=""></a>
            <aside class="notes">
                <ul>
                    <li>Auto promotion</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                En passant, je me permets une petite promotion √©hont√©e pour une de mes pr√©sentations pass√©es qui parle des-->
<!--                fonctions, √©ventuellement r√©cursives, et de leur mise en ≈ìuvre. Pr√©sentation qui pourrait √™tre un-->
<!--                compl√©ment int√©ressant √† celle-ci.-->
<!--            </aside>-->

        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/1.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>environnement d'ex√©cutio</li>
                    <li>enregistrement d'activation</li>
                    <li>cr√©√© √† l'activation de la fonction</li>
                    <li>d√©truit quand elle se termine</li>
                    <li>pile (mais tous les labngages)</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Nous allons suivre pas √† pas le d√©roulement de ce programme. Comme je l'explique plus en d√©tail dans-->
<!--                mon autre pr√©sentation, l'environnement d'ex√©cution d'une fonction est fourni par un enregistrement-->
<!--                d'activation plus tous ceux des fonctions appelantes. Un enregistrement est cr√©√© √† l'activation de la-->
<!--                fonction et d√©truit quand elle se termine. Et dans la plupart des langages (mais pas tous) cette gestion-->
<!--                se fait sous forme de pile.-->
<!--                <br><br>-->
<!--                Donc ici, on commence avec l'enregistrement d'activation de ¬´ main ¬ª dans la pile.-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    <span class="ch">val c = 42</span>
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/2.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>¬´ c ¬ª se voit affecter la valeur 42</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/2.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>appel ¬´ parametricPredicate ¬ª currifi√©e avec 3 en argument</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/3.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>nouvel enregistrement d'activation</li>
                </ul>
            </aside>
        </section>


        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = <span class="ch">longComputation(x)</span>
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/3.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>appel ¬´ longComputation ¬ª</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = <span class="ch">longComputation(x)</span>
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return <span class="ch">x * x</span>
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/4.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>nouvel enregistrement d'activation </li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = <span class="ch">longComputation(x)</span>
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return <span class="ch">x * x</span>
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/4b.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>¬´ longComputation ¬ª produit et retourne son r√©sultat 9.</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = <span class="ch">longComputation(x)</span>
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/5.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>affect√© √† ¬´ c ¬ª dans l'environnement de ¬´ parametricPredicate ¬ª</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return <span class="ch">{ y -> y % c == 0 }</span>
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/5b.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>na√Øvement pointeur sur fonction</li>
                    <li>C</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/6.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>adresse du code compil√© ¬´ @Lambda0 ¬ª</li>
                    <li>retourn√© et affect√© √† la variable
                ¬´ predicate ¬ª</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if <span class="ch">(predicate(81))</span> println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/6.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>appel ¬´ predicate ¬ª avec 81 en param√®tre</li>
                    <li>allocation enregistrement d'activation</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if <span class="ch">(predicate(81))</span> println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/7.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>¬´ c ¬ª n'a pas de valeur</li>
                    <li>remonte la cha√Æne, trouve 42</li>
                    <li>r√©sultat faux, √ßa pourrait planter aussi</li>
                    <li>pire silencieusement erron√© ou plantage</li>
                    <li>liaison dynamique, sujet d√©battu</li>
                    <li>id√Æome LISP</li>
                    <li>raisonnement local</li>
                </ul>
            </aside>
<!--            <aside>-->
<!--                Mais dans cet environnement ¬´ c ¬ª n'a pas de valeur, alors on remonte la cha√Æne des environnements pour-->
<!--                en trouver une. On tombe sur le 42 initial. Et l√†, c'est le drame ! On s'attend √† un r√©sultat positif-->
<!--                (81 est divisible par 9 en nombre entier), pourtant c'est faux parce que la lambda n'utilise pas la-->
<!--                bonne valeur de ¬´ c ¬ª. Il pourrait m√™me ne pas y avoir de valeur pour ¬´ c ¬ª.-->
<!--                <br><br>-->
<!--                √Ä vrai dire, je ne sais pas ce qui est le pire entre un programme qui plante clairement ou qui r√©pond √†-->
<!--                c√¥t√© sans que l'on s'en aper√ßoive.-->
<!--                <br><br>-->
<!--                Alors ne nous m√©prenons pas : cela peut √™tre consid√©r√© comme une fonctionnalit√© l√©gitime. √áa s'appelle-->
<!--                de la liaison dynamique. Et pendant longtemps, le sujet a √©t√© d√©battu, avec ses partisans et ces d√©tracteurs.-->
<!--                Et c'est m√™me devenu un id√Æome LISP. On parle d'id√Æome dans un langage quand un design pattern est tr√®s-->
<!--                li√© √† la s√©mantique du langage.-->
<!--                <br><br>-->
<!--                Je serais enclin √† dire, si l'on se place dans un cadre de programmation fonctionnelle, que le principe-->
<!--                de raisonnement local est mis √† mal par un tel m√©canisme. Quand je code, j'ai du mal avec les effets-->
<!--                contextuels d'utilisation d'une fonction autre que ses param√®tres d'entr√©e.-->
<!--            </aside>-->
        </section>

        <section>
            <h1>Scheme</h1>
            <h2>1975</h2>
            <aside class="notes">
                <ul>
                    <li>sujet d√©battu pendant plus de 15 ans</li>
                    <li>arriv√©e de SCHEME</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: auto auto; grid-template-rows: auto auto">
                <div>
                    <div style="grid-column: 1; grid-row: 1">
                        <img src="./images/Guy_Steele.jpg" alt="">
                    </div>
                    <div class="fragment" style="grid-column: 1; grid-row: 2">Guy L. Steele Jr.</div>
                </div>
                <div class="fragment">
                    <div style="grid-column: 2; grid-row: 1/2">
<!--                        <a href="https://media.githubusercontent.com/media/sarabander/sicp-pdf/master/sicp.pdf"><img src="./images/SICP.png" alt=""></a>-->
                        <a href="https://dspace.mit.edu/bitstream/handle/1721.1/5753/AIM-443.pdf"><img style="border: thin solid black" src="./images/LambdaTheUltimate.png" alt=""></a>
                    </div>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>Guy Lewis Steel Junior</li>
                    <li>EMACS et TeX</li>
                    <li>*LISP et C*, thinking machines</li>
                    <li>Common Lisp, C, Fortran commit√©s</li>
                    <li>Java, Sun 1994, Oracle depuis 2010.</li>
                    <li>Verse, Epic Games, Simon Peyton-Jones</li>
                    <li>SCHEME 75, Gerald Jay Sussmann ¬´ Structure et interpr√©tation des programmes informatiques ¬ª</li>
                    <li>¬´ Œª the ultimate ¬ª papers</li>
                    <li>partit de la liaison lexicale</li>
                    <li>explication</li>                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Jusqu'√† croiser la route de...-->
<!--                <br><br>-->
<!--                Guy Lewis Steel Junior, √† qui on doit entre autres Emacs et le premier portage de TeX de Donald Knuth. Il-->
<!--                a √©t√© impliqu√© dans la d√©finition ou la normalisation de nombreux langages de programmation, comme *Lisp-->
<!--                et C* chez Thinking Machines ; Common Lisp, C, Fortran dans le cadre de commit√©s ; Et Java en tant-->
<!--                qu'employ√© de Sun en 1994 puis Oracle depuis 2010. Il est m√™me r√©cemment all√© travailler avec Epic Games-->
<!--                sur le langage Verse en compagnie de Simon Peyton-Jones, un des piliers d'Haskell.-->
<!--                <br><br>-->
<!--                Pour ce qui nous concerne aujourd'hui, il est surtout le co-cr√©ateur de Scheme en 1975 de SCHEME avec-->
<!--                Gerald Sussmann au MIT. Gerald Jay Sussmann auteur du livre ¬´ Structure and Interpretation of Computer-->
<!--                Programs ¬ª, que je vous invite √† parcourir tant il fait partie des fondamentaux.-->
<!--            </aside>-->
        </section>

<!--        <section>-->
<!--            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: auto auto; grid-template-rows: auto auto">-->
<!--                <div>-->
<!--                    <div style="grid-column: 1; grid-row: 1">-->
<!--                        <img src="./images/Guy_Steele.jpg" alt="">-->
<!--                    </div>-->
<!--                    <div style="grid-column: 1; grid-row: 2">Guy L. Steele Jr.</div>-->
<!--                </div>-->
<!--                <div>-->
<!--                    <div style="grid-column: 2; grid-row: 1/2">-->
<!--                        <a href="https://dspace.mit.edu/bitstream/handle/1721.1/5753/AIM-443.pdf"><img style="border: thin solid black" src="./images/LambdaTheUltimate.png" alt=""></a>-->
<!--                    </div>-->
<!--                </div>-->
<!--            </div>-->
<!--            <aside class="notes">-->
<!--                <ul>-->
<!--                    <li>¬´ Œª the ultimate ¬ª papers</li>-->
<!--                    <li>partit de la liaison lexicale</li>-->
<!--                    <li>explication</li>-->
<!--                </ul>-->
<!--            </aside>-->
<!--            <aside class="notes">-->
<!--                Il est aussi l'auteur des ¬´ Œª the ultimate ¬ª papers. C'est une s√©rie d'articles parfois co√©crits avec-->
<!--                Sussmann, qui prend le partit de la liaison lexicale. Il s'agit de faire en sorte, m√™me au prix d'un-->
<!--                surco√ªt √† l'ex√©cution d'un programme, que les variables libres d'une lambda prennent la valeur qu'elles-->
<!--                avaient au moment de leur d√©finition et non au moment de l'ex√©cution.-->
<!--                <br><br>-->
<!--                Et au travers de multiples exemples, il montre toute l'utilit√© de ce concept.-->
<!--            </aside>-->
<!--        </section>-->

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;  display: grid; grid-template-columns: 3fr 2fr">
                <div style="justify-self: center">$x$</div>
                <div style="justify-self: start"> Variable</div>
                <div style="justify-self: center">$\lambda x.\,M$</div>
                <div style="justify-self: start"> Abstraction</div>
                <div style="justify-self: center; margin-bottom: 2.5em">$M\,N$</div>
                <div style="margin-bottom: 2.5em; justify-self: start"> Application</div>
                <div style="justify-self: center">$\lambda x.\,(f\,x) \rightarrow f$</div>
                <div style="justify-self: start">$\eta$-reduction</div>
                <div style="justify-self: center">$\lambda x.\,M[x] \rightarrow \lambda y.\,M[y]$</div>
                <div style="justify-self: start">$\alpha$-conversion</div>
                <div style="justify-self: center">$(\lambda x.\,M)\:E \rightarrow M[x:=E]$</div>
                <div style="justify-self: start">$\beta$-reduction</div>
            </div>
            <aside class="notes">
                <ul>
                    <li>Lambda calcul</li>
                    <li>syntaxe, interpr√©tation</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Pour la peine, la liaison lexicale est au fondement de l'interpr√©tation du lambda calcul.-->
<!--            </aside>-->
        </section>

        <section>
            <a href="https://www.cs.tufts.edu/comp/150FP/archive/peter-landin/mechanical-eval.pdf"><img style="border: thin solid black; margin-bottom: 100%; margin-top: 3em" src="./images/Landin.png" alt=""></a>
            <aside class="notes">
                <ul>
                    <li>Peter Landin datant de 1964</li>
                    <li>sucre syntaxique</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et sa mise en ≈ìuvre concr√®te est depuis longtemps comprise, comme dans cet article fondateur de Peter Landin-->
<!--                datant de 1964 ! Accessoirement lui doit aussi le terme ¬´ sucre syntaxique ¬ª !-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return <span class="ch">{ y -> y % c == 0 }</span>
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/5.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>¬´ pointeur ¬ª sur le code insuffisant</li>
                    <li>√©lements de son environnemen</li>
                    <li>valeurs de ses variables libres</li>
                    <li>pas partie des param√®tres</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Reprenons le d√©roul√© de notre exemple l√† o√π le probl√®me apparait. Retourner un ¬´ pointeur ¬ª sur le code-->
<!--                de la fonction anonyme ne suffit pas.-->
<!--            </aside>-->
        </section>


        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return <span class="ch">{ y -> y % c == 0 }</span>
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/5b.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>structure</li>
                    <li>variables libres </li>
                    <li>pointeur sur son code</li>
                    <li>tas, survie √† d√©sallocation</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                RIl faut aussi fournir des √©lements de son environnement qui feraient d√©fault ult√©rieurement : les valeurs-->
<!--                de ses variables libres. Celles qui ne font pas partie des param√®tres de la lambda.-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/6.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>affect√© √† predicate</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et de plus, on a besoin que cette information survive √† la d√©s-allocation de l'enregistrement d'activation-->
<!--                de ¬´ parametricPredicate ¬ª. Pour cel√†, on va allouer une structure contenant valeur des variables libres de-->
<!--                la lambda et pointeur sur son code sur le tas (heap).-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/7.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>C'est une closure ou fermeture</li>
                    <li>inventaire des variables libre pour fermer la lambda</li>
                    <li>concept: lambda li√©e lexicalement</li>
                    <li>implem: closure</li>
                    <li>confusion des deux</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                C'est cette structure qu'on appelle ¬´ Closure ¬ª ou ¬´ Fermeture ¬ª : on fait l'inventaire des variables libres-->
<!--                four ¬´ fermer ¬ª la lambda. En ce sens, on peut dire qu'une fonction anonyme li√©e lexicalement est un concept-->
<!--                du langage et une ¬´ Fermeture ¬ª un d√©tail d'impl√©mentation. Apr√®s, peut-√™tre √† tort, les termes ¬´ lambda ¬ª et-->
<!--                ¬´ closure ¬ª sont devenus interchangeables dans certains discours.-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if <span class="ch">(predicate(81))</span> println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/8.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>√©valuation de ¬´ predicate(81)</li>
                    <li>bonne valeur de ¬´ c ¬ª</li>
                    <li>consensus liaison lexicale</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et maintenant, lors de l'√©valuation de ¬´ predicate(81) ¬ª on fera r√©f√©rence √† la valeur de ¬´ c ¬ª lors la-->
<!--                d√©finition de la lambda et non celle de ¬´ main ¬ª. Encore une fois, c'est un choix qui s'est d√©battu et le-->
<!--                consensus actuel veut que la liaison lexicale soit la bonne approche.-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 2fr">
                <div style="grid-column: 2; grid-row: 1">
                    <img src="./images/Haskell-logo.png" alt="">
                </div>
                <div class="fragment" data-fragment-index="1" style="grid-column: 2; grid-row: 2">
                    <a href="https://www.cambridge.org/core/services/aop-cambridge-core/content/view/S0956796800000319"><img style="border: solid black 1px; margin-top: 2.5em" src="./images/Haskell.png" alt=""></a>
                </div>
                <div style="grid-column: 1; grid-row: 1">
                    <img src="./images/OCaml-logo.png" alt="">
                </div>
                <div class="fragment" data-fragment-index="1" style="grid-column: 1; grid-row: 2">
                    <a href="https://inria.hal.science/inria-00070049/document"><img style="border: solid black 1px; margin-top: 2.5em" src="./images/OCaml.png" alt=""></a>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>programmation fonctionnelle</li>
                    <li>Ocaml et Haskell -> LISP</li>
                    <li>curryfication</li>
                    <li>rapports internes mise en ≈ìuvre</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                C'est d'ailleurs le monde de la programmation fonctionnelle, tout au long de la fin du 20·µâ si√®cle, qui a pouss√©-->
<!--                dans ce sens (avec ici deux embl√©matiques repr√©sentants, Haskell et OCaml), emportant dans son sillage le monde-->
<!--                lispien. Ici, vous avez deux rapports d√©crivant la mise en ≈ìuvre de l'un et l'autre. Et dans les deux cas la-->
<!--                notion de closure fait int√©gralement partie de la machine viiruelle (ou de l'environnement d'ex√©cution) du-->
<!--                langage.-->
<!--            </aside>-->
        </section>

<!--        <section>-->
<!--            <img style="margin-top: 3em; margin-bottom: 100%" src="./images/OcamlClosures.png" alt="">-->
<!--            <aside class="notes">-->
<!--                <ul>-->
<!--                    <li> valeur fonctionnelle est ¬´ √©videmment ¬ª repr√©sent√© pas une closure</li>-->
<!--                    <li>subtilit√©s r√©cup√©ration m√©moire.</li>-->
<!--                </ul>-->
<!--            </aside>-->
<!--            <aside class="notes">-->
<!--                Dans le cas d'OCaml, il y est dit qu'une valeur fonctionnelle est ¬´ √©videmment ¬ª repr√©sent√© pas une closure,-->
<!--                c'est-√†-dire une paire pointeur de code / environnement de liaison des variables. Il y est aussi expliqu√© qu'elles-->
<!--                sont allou√©e dans une space encore diff√©rent du tas pour de subtiles raisons de r√©cup√©ration m√©moire.-->
<!--            </aside>-->
<!--        </section>-->

<!--        <section>-->
<!--            <img style="margin-top: 2em; margin-bottom: 100%" src="./images/HaskellClosures.png" alt="">-->
<!--            <aside class="notes">-->
<!--                <ul>-->
<!--                    <li>un peu plus compliqu√©</li>-->
<!--                    <li>langage paresseux</li>-->
<!--                    <li>thunk</li>-->
<!--                    <li>couple pointeur de code / environnement</li>-->
<!--                </ul>-->
<!--            </aside>-->
<!--            <aside class="notes">-->
<!--                Pour Haskell, comme le montre ce sch√©ma, c'est un peu plus compliqu√©, ne serait-ce que du fait de choix de mise en-->
<!--                ≈ìuvre d'un langage paresseux ! Mais si on y pr√™te attention on retrouve encore le couple pointeur de code / environnement.-->
<!--            </aside>-->
<!--        </section>-->

        <section>
            <h1>Clojure</h1>
            <h2>2007</h2>
            <aside class="notes">
                <ul>
                    <li>similitude entre les ¬´ Closures ¬ª et les objets</li>
                    <li>dictionnaire de valeurs et un pointeur sur du code</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                En plissant fortement les yeux, on notera tout de m√™me une similitude entre les ¬´ Closures ¬ª et les-->
<!--                objets des langages OO : une structure avec un dictionnaire de valeurs et un pointeur sur du code qui fait-->
<!--                r√©f√©rence √† ce dictionnaire. D'ailleurs Guy Steele dans ces ¬´ lambda the ultimate ¬ª papers en parle de-->
<!--                mani√®re indirecte.-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: auto auto; grid-template-rows: auto auto">
                <div>
                    <div style="grid-column: 1; grid-row: 1">
                        <img src="./images/Hickey.png" alt="">
                    </div>
                    <div class="fragment" style="grid-column: 1; grid-row: 2">Rich Hickey</div>
                </div>
                <div class="fragment">
                    <div style="grid-column: 2; grid-row: 1/2">
                        <a href="https://dl.acm.org/doi/pdf/10.1145/3386321"><img style="border: thin solid black" src="./images/Clojure.png" alt=""></a>
                    </div>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>Rich Hickey</li>
                    <li>essai .NET, puis Java, notez le J</li>
                    <li>dialecte de SCHEME -> liaison lexicale</li>
                    <li>autres partits pris (appels terminaux et r√©cursivit√©)</li>
                    <li>¬´ Proceedings of the ACM on Programming Languages ¬ª</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                En 2007, Rich Hickey apr√®s avoir fait une premi√®re tentative sur la plateforme .NET, propose un dialecte-->
<!--                de Scheme ciblant la JVM. Et forc√©ment, il adopte la liaison lexicale comme fondement pour la-->
<!--                d√©finition des fonctions anonymes.-->
<!--                <br><br>-->
<!--                Et bien d'autres partis pris qu'il d√©taille dans cet article des-->
<!--                ¬´ Proceedings of the ACM on Programming Languages ¬ª (appels terminaux et r√©cursivit√©).-->
<!--                <br><br>-->
<!--                Voyons comment il a (ou aurait) pu proc√©der pour mettre des ¬´ closure ¬ª sur une plateforme qui n'est pas-->
<!--                initialement pr√©vue pour.-->
<!--            </aside>-->
        </section>

        <section>
            <h1><span style="text-transform:lowercase">$\lambda$</span>-lifting</h1>
            <aside class="notes">
                <ul>
                    <li>compilateurs pour des langages fonctionnels</li>
                    <li>¬´ lambda lifting ¬ª</li>
                    <li>¬´ lambda desugaring ¬ª</li>
                    <li>Forax</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                On va d'abord parler d'une transformation classique utilis√©e par les compilateurs pour des langages-->
<!--                fonctionnels. Elle n'est pas requise pour la suite, mais m√©rite qu'on la signale : Le ¬´ lambda lifting ¬ª.-->
<!--                D'autant plus que dans la compilation de Java aujourd'hui, et pour une raison qui m'√©chappe, on l'appelle-->
<!--                ¬´ lambda desugaring ¬ª. Il faudra qu'un jour, je pose la question √† R√©mi Forax...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre class="fragment" style="font-size: 1.1ex; margin-top: 1em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicateLambda(c: Int, y: Int): Boolean = y % c == 0

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> parametricPredicateLambda(c, y) }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>fonction sans variable libre</li>
                    <li>plus haut niveau</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                L'id√©e est tr√®s simple : une premi√®re transformation du code fait apparaitre une fonction sans variable-->
<!--                libre, au plus haut niveau, correspondant √† la lambda que l'on veut compiler-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        <span class="ch">fun parametricPredicateLambda(c: Int, y: Int): Boolean = y % c == 0</span>

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> parametricPredicateLambda(c, y) }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>plus de param√®tres</li>
                    <li>capture des variables libres</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Forc√©ment, elle est susceptible d'avoir plus de param√®tres que la lambda d'origine, puisque les variables-->
<!--                libres ne doivent plus l'√™tre.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicateLambda(c: Int, y: Int): Boolean = y % c == 0

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> <span class="ch">parametricPredicateLambda(c, y)</span> }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>L√†, vous me direz, on a fait que d√©placer le probl√®me... C'est pas faux !</li>
                </ul>

            </aside>
        </section>

        <section>
            <h1>Closure conversion</h1>
            <aside class="notes">
                <ul>
                    <li>transformation fondamentale</li>
                    <li>closure conversion</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                En fait, il y a une seconde transformation, qui elle en revanche en fondamentale pour notre sujet : la-->
<!--                ¬´ closure conversion ¬ª.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>similitude objet <-> closure</li>
                </ul>
                Et c'est l√† que la similitude en objet et closure se voit un peu mieux.
            </aside>
<!--            <aside class="notes">-->
<!--                Et c'est l√† que la similitude en objet et closure se voit un peu mieux.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(<span class="ch">val capture: C</span>, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>utilisation d'une structure</li>
                    <li>variable captur√©e</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Sauf qu'ici, j'ai d√©cid√© d'utiliser une structure, plut√¥t qu'une classe, qui embarque la variable captur√©e...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, <span class="ch">val code: (C, I) -> O</span>)

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>pointeur sur le code</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                ... et le pointeur sur le code.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): Closure&lt;Int, Int, Boolean&gt; {
                            val c = longComputation(x)
                            return Closure(c, ::parametricPredicateLambda)
                        }

                        fun main() {
                            val c = 42
                            val predicate: Closure&lt;Int, Int, Boolean&gt; = parametricPredicate(3)
                            if (predicate.code(predicate.capture, 81)) println("Ok") else println("Ko")
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>R√©√©criture de parametricPredicate...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Ce qui permet de r√©√©crire ¬´ parametricPredicate ¬ª...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): Closure&lt;Int, Int, Boolean&gt; {
                            val c = longComputation(x)
                            return <span class="ch">Closure(c, ::parametricPredicateLambda)</span>
                        }

                        fun main() {
                            val c = 42
                            val predicate: Closure&lt;Int, Int, Boolean&gt; = parametricPredicate(3)
                            if (predicate.code(predicate.capture, 81)) println("Ok") else println("Ko")
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>repr√©sentation de la fonction</li>
                    <li>valeur variables libres</li>
                    <li>c'est une valeur fonctionnelle</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                ... de la fa√ßon suivante : elle retourne une repr√©sentation de la fonction anonyme accompagn√©e des-->
<!--                valeurs des variables captur√©es. C'est une repr√©sentation op√©rationnelle d'une valeur fonction.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): Closure&lt;Int, Int, Boolean&gt; {
                            val c = longComputation(x)
                            return Closure(c, ::parametricPredicateLambda)
                        }

                        fun main() {
                            val c = 42
                            val predicate: Closure&lt;Int, Int, Boolean&gt; = parametricPredicate(3)
                            if (<span class="ch">predicate.code(predicate.capture, 81)</span>) println("Ok") else println("Ko")
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>ajustement de l'appel</li>
                    <li>code fonction lambda lift√©e</li>
                    <li>valeur captur√©e et celle qu'on veut tester</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et forc√©ment au point d'appel, il faut aussi effectuer une adaptation. On appelle le code de la-->
<!--                fonction lambda lift√©e avec ces deux arguments, la valeur captur√©e et celle qu'on veut tester.-->
<!--            </aside>-->
        </section>

        <section>
            <h1>Java 8</h1>
            <h2>2014</h2>
            <aside class="notes">
                <ul>
                    <li>acceptation des lambdas</li>
                    <li>sensibilit√© √† la programmation fonctionnelle</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                L'utilisation de fonctions anonymes fait son chemin dans bien des langages. Peut-√™tre parce que de plus en-->
<!--                plus de d√©veloppeurs sont sensibilis√©s √† la programmation fonctionnelle qui en use abondamment... Ou parce-->
<!--                que √ßa fait bien, allez savoir ?-->
<!--            </aside>-->
        </section>

        <section>
            <img style="border: thin solid" src="./images/JSR335.png" alt="">
            <aside class="notes">
                <ul>
                    <li>Clojure 2007 -> JSR 335 (java 8) 2014</li>
                    <li>gestation de 7 ans</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                En attendant, la gestation du support des lambda dans Java d√©bute √† la sortie de Clojure, en 2007 et va-->
<!--                quand m√™me durer 7 ans, pour voir officiellement sortir la JSR 335 dans Java 8.-->
<!--            </aside>-->
        </section>

        <section>
            <a href="http://gafter.blogspot.com/2007/01/definition-of-closures.html"><img style="border: thin solid black" src="./images/Gafter.png" alt=""></a>
            <aside class="notes">
                <ul>
                    <li>Pourquoi tant de temps ?</li>
                    <li>plus d'entit√©s li√©s lexicalement</li>
                    <li>√† minima ¬´ this ¬ª</li>
                    <li>article de Neil Gafter</li>
                    <li>r√©tro compatibilit√©</li>
                    <li>√©volutivit√©</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Pourquoi tant de temps ? Parce que Java est un langage orient√© objets et que la somme des concepts sujets-->
<!--                √† la liaison lexicale d√©passe les variables d'une fonction anonyme Lisp. Ce qui est tr√®s bien expliqu√©-->
<!--                dans cet article de Neil Gafter, membre d'un groupe ayant formul√© une des trois propositions d'int√©grations-->
<!--                initiales (rien que √ßa). Mais aussi parce que les enjeux de r√©tro compatibilit√© et d'√©volutivit√© de Java-->
<!--                en tant que plateforme sont grands.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static int longComputation(int x) {
                                    return x * x;
                                }

                                public static IntPredicate parametricPredicate(int x) {
                                    var c = longComputation(x);
                                    return y -> y % c == 0;
                                }

                                void main() {
                                    var aStream = IntStream.rangeClosed(0, 100);
                                    var predicate = parametricPredicate(3);
                                    IntStream filteredStream = aStream.filter(predicate);

                                    System.out.println(
                                            filteredStream.
                                                    mapToObj(Integer::toString).
                                                    collect(Collectors.joining(",", "[", "]")));
                                }

                                // [0,9,18,27,36,45,54,63,72,81,90,99]

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>Exemple en Java</li>
                    <li>21 plut√¥t que 8 -> Kotlin</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Voil√† √† quoi ressemble notre exemple en Java. J'ai utilis√© ici la version 21 plut√¥t que la 8 avec la-->
<!--                fonctionnalit√© classe anonyme et m√©thode 'main' d'instance pour qu'il ressemble plus √† la version Kotlin.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static int longComputation(int x) {
                                    return x * x;
                                }

                                public static IntPredicate parametricPredicate(int x) {
                                    var c = longComputation(x);
                                    return <span class="ch">y -> y % c == 0</span>;
                                }

                                void main() {
                                    var aStream = IntStream.rangeClosed(0, 100);
                                    var predicate = parametricPredicate(3);
                                    IntStream filteredStream = aStream.filter(predicate);

                                    System.out.println(
                                            filteredStream.
                                                    mapToObj(Integer::toString).
                                                    collect(Collectors.joining(",", "[", "]")));
                                }

                                // [0,9,18,27,36,45,54,63,72,81,90,99]

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>syntaxe pour les lambda</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                La syntaxe pour le lambda est assez commune et proche de celle de Kotlin (aux accolades pr√®s).-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static int longComputation(int x) {
                                    return x * x;
                                }

                                public static <span class="ch">IntPredicate</span> parametricPredicate(int x) {
                                    var c = longComputation(x);
                                    return y -> y % c == 0;
                                }

                                void main() {
                                    var aStream = IntStream.rangeClosed(0, 100);
                                    var predicate = parametricPredicate(3);
                                    IntStream filteredStream = aStream.filter(predicate);

                                    System.out.println(
                                            filteredStream.
                                                    mapToObj(Integer::toString).
                                                    collect(Collectors.joining(",", "[", "]")));
                                }

                                // [0,9,18,27,36,45,54,63,72,81,90,99]

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>pas de syntaxe pour d√©crire un type fonctionnel</li>
                    <li>type nominatif, interface</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                En revanche, il n'y a pas de syntaxe pour d√©crire un type fonctionnel. Ici le type de retour de-->
<!--                ¬´ parametricPredicate ¬ª est nominatif, c'est une interface.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                @FunctionalInterface
                                public interface IntPredicate {

                                    boolean test(int value);

                                }

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>¬´ Single Abstract Method ¬ª ou ¬´ SAM ¬ª interface</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Mais pas n'importe qu'elle interface. C'est une ¬´ Single Abstract Method ¬ª ou ¬´ SAM ¬ª interface...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                <span class="ch">@FunctionalInterface</span>
                                public interface IntPredicate {

                                    boolean test(int value);

                                }

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>annotation ¬´ @FunctionalInterface ¬ª</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                ... qui est annot√©e ¬´ @FunctionalInterface ¬ª.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                @FunctionalInterface
                                public interface IntPredicate {

                                    <span class="ch">boolean test(int value)</span>;

                                }

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>closure ressemble √† un objet avec une seule m√©thode</li>
                    <li>acc√®s aux champs</li>
                    <li>r√©trocompatibilit√©</li>
                    <li>Runnable</li>
                    <li>¬´ SAM conversion ¬ª en Kotlin</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Comme je l'ai d√©j√† dit, une closure ressemble √† un objet de disposant que d'une seule m√©thode pouvant-->
<!--                acc√©der aux champs de l'objet. C'est cette similitude qui est exploit√©e ici. On assimile une certaine-->
<!--                forme d'interface au type d'une lambda. On est l√† dans la recherche de r√©trocompatibilit√©, pour exploiter-->
<!--                des interfaces d√©j√† existantes qui auraient la bonne forme, comme ¬´ Runnable ¬ª. Apr√®s cette forme de-->
<!--                ¬´ SAM conversion ¬ª est aussi disponible en Kotlin, alors pour s'√™tre priv√© d'une syntaxe explicite, je-->
<!--                n'en sais rien.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static boolean parametricPredicateLambda(int c, int y) { return y % c == 0; }

                                public static class Closure implements IntPredicate {

                                    private final int c;

                                    public Closure(int c) {
                                        this.c = c;
                                    }

                                    @Override
                                    public boolean test(int value) {
                                        return parametricPredicateLambda(c, value);
                                    }
                                }

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>strat√©gie de compilation</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                En tout cas la strat√©gie de compilation retenue pour Java ressemble plut√¥t √† √ßa.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static boolean <span class="ch">parametricPredicateLambda</span>(int c, int y) { return y % c == 0; }

                                public static class Closure implements IntPredicate {

                                    private final int c;

                                    public Closure(int c) {
                                        this.c = c;
                                    }

                                    @Override
                                    public boolean test(int value) {
                                        return parametricPredicateLambda(c, value);
                                    }
                                }

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>fonction lambda-lift√©e</li>
                    <li>¬´ desugared ¬ª dans la terminologie de Java</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                 On dispose toujours de notre fonction lambda-lift√©e... Enfin ¬´ desugared ¬ª dans la terminologie de Java.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static boolean parametricPredicateLambda(int c, int y) { return y % c == 0; }

                                public static class <span class="ch">Closure</span> implements <span class="ch">IntPredicate</span> {

                                    private final int c;

                                    public Closure(int c) {
                                        this.c = c;
                                    }

                                    @Override
                                    public boolean test(int value) {
                                        return parametricPredicateLambda(c, value);
                                    }
                                }

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>classe cr√©√©e localement</li>
                    <li>interface fonctionnelle cible</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Mais la traduction de la lambda lexicalement li√©e, la closure, s'appuie sur une classe cr√©√©e localement √† partir de-->
<!--                l'interface fonctionnelle cible.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static boolean parametricPredicateLambda(int c, int y) { return y % c == 0; }

                                public static class Closure implements IntPredicate {

                                    private final int <span class="ch">c</span>;

                                    public <span class="ch">Closure(int c)</span> {
                                        this.c = c;
                                    }

                                    @Override
                                    public boolean test(int value) {
                                        return parametricPredicateLambda(c, value);
                                    }
                                }

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>champ pour valeur variable captur√©e </li>
                    <li>constructeur</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Elle comporte un champ pour stocker la valeur de la variable captur√©e et un constructeur pour la-->
<!--                cr√©er avec en fournissant la valeur √† capturer.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static boolean parametricPredicateLambda(int c, int y) { return y % c == 0; }

                                public static class Closure implements IntPredicate {

                                    private final int c;

                                    public Closure(int c) {
                                        this.c = c;
                                    }

                                    @Override
                                    public boolean <span class="ch">test</span>(int value) {
                                        return parametricPredicateLambda(c, value);
                                    }
                                }

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>mise ≈ìuvre de la ¬´ Single Abstract Method ¬ª</li>
                    <li>fonction anonyme lambda lift√©e</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et d'une mise ≈ìuvre de la ¬´ Single Abstract Method ¬ª qui s'appuie sur la fonction anonyme-->
<!--                lambda lift√©e... .-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="java" style="max-height: 800px" data-noescape>

                                public static int longComputation(int x) {
                                    return x * x;
                                }

                                public static IntPredicate parametricPredicate(int x) {
                                    var c = longComputation(x);
                                    return new <span class="ch">Closure(c)</span>;
                                }

            </code><div class="lang">Java</div></pre>
            <pre class="fragment" style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                var predicate = parametricPredicate(3);

                                predicate(81);



            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>cr√©er et retourner la closure</li>
                    <li>pas de syntaxe sp√©cifique ou simplifi√©e pour l'invocation</li>
                    <li>incorrect</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et comme tout √† l'heure, il ne reste plus qu'√† cr√©er et retourner la closure dans ¬´ parametricPredicate ¬ª.-->
<!--                <br><br>-->
<!--                En revanche, contrairement √† Kotlin, il n'y a pas de syntaxe sp√©cifique ou simplifi√©e pour l'invocation-->
<!--                de la fonction. On ne peut pas √©crire...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="java" style="max-height: 800px" data-noescape>

                                public static int longComputation(int x) {
                                    return x * x;
                                }

                                public static IntPredicate parametricPredicate(int x) {
                                    var c = longComputation(x);
                                    return new <span class="ch">Closure(c)</span>;
                                }

            </code><div class="lang">Java</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                var predicate = parametricPredicate(3);

                                <del>predicate(81);</del>

                                predicate.test(81);

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>invocation m√©thode de l'interface SAM</li>
                    <li>subtilit√©...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                On invoque en r√©alit√© la m√©thode de l'interface SAM.-->
<!--                <br><br>-->
<!--                Si c'est l√† bien le principe retenu pour les lambdas en Java, il est pourtant mis en ≈ìuvre avec une-->
<!--                subtilit√©..-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="Java" style="max-height: 800px" data-noescape>

                  private static boolean lambda$parametricPredicate$0(int, int);
                    descriptor: (II)Z
                    flags: (0x100a) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC
                    Code:
                      stack=2, locals=2, args_size=2
                         0: iload_1
                         1: iload_0
                         2: irem
                         3: ifne          10
                         6: iconst_1
                         7: goto          11
                        10: iconst_0
                        11: ireturn
                      LineNumberTable:
                        line 15: 0
                      StackMapTable: number_of_entries = 2
                        frame_type = 10 /* same */
                        frame_type = 64 /* same_locals_1_stack_item */
                          stack = [ int ]

            </code><div class="lang">Bytecode</div></pre>
            <aside class="notes">
                <ul>
                    <li>descendre dans la soute</li>
                    <li>bytecode g√©n√©r√© par le compilateur</li>
                    <li>javap</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                On va descendre un peu plus dans la soute et jeter un ≈ìil rapidement au bytecode g√©n√©r√© par le compilateur,-->
<!--                gr√¢ce √† la commande ¬´ javap ¬ª sorte de d√©s-assembleur pour le code de la JVM.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="Java" style="max-height: 800px" data-noescape>

                  private static boolean <span class="ch">lambda$parametricPredicate$0</span>(int, int);
                    descriptor: (II)Z
                    flags: (0x100a) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC
                    Code:
                      stack=2, locals=2, args_size=2
                         0: iload_1
                         1: iload_0
                         2: irem
                         3: ifne          10
                         6: iconst_1
                         7: goto          11
                        10: iconst_0
                        11: ireturn
                      LineNumberTable:
                        line 15: 0
                      StackMapTable: number_of_entries = 2
                        frame_type = 10 /* same */
                        frame_type = 64 /* same_locals_1_stack_item */
                          stack = [ int ]

            </code><div class="lang">Bytecode</div></pre>
            <aside class="notes">
                <ul>
                    <li>fonction anonyme lambda-lift√©e</li>
                    <li> ¬´ lambda$parametricPredicate$0 ¬ª</li>
                    <li>name mangling</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et en fouinant dans le r√©sultat, une premi√®re chose qui saute aux yeux, c'est notre fameuse-->
<!--                fonction anonyme lambda-lift√©e, ici appel√© ¬´ lambda$parametricPredicate$0 ¬ª. On voit bien-->
<!--                qu'elle a deux param√®tres au lieu d'un et qu'elle retourne un bool√©en.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="Java" style="max-height: 800px" data-noescape>

                  public static java.util.function.IntPredicate parametricPredicate(int);
                    descriptor: (I)Ljava/util/function/IntPredicate;
                    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
                    Code:
                      stack=1, locals=2, args_size=1
                         0: iload_0
                         1: invokestatic  #7        // Method longComputation:(I)I
                         4: istore_1
                         5: iload_1
                         6: invokedynamic #13,  0   // InvokeDynamic #0:test:(I)Ljava/util/function/IntPredicate;
                        11: areturn
                      LineNumberTable:
                        line 14: 0
                        line 15: 5

            </code><div class="lang">Bytecode</div></pre>
            <aside class="notes">
                <ul>
                    <li>¬´ parametricPredicate ¬ª</li>
                    <li>retourne type ¬´ IntPredicate ¬ª</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                On retrouve aussi ¬´ parametricPredicate ¬ª qui doit retourner une valeur fonction de type ¬´ IntPredicate ¬ª.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                  public static java.util.function.IntPredicate parametricPredicate(int);
                    descriptor: (I)Ljava/util/function/IntPredicate;
                    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
                    Code:
                      stack=1, locals=2, args_size=1
                         0: iload_0
                         1: invokestatic  #7        // Method longComputation:(I)I
                         4: istore_1
                         5: iload_1
                         6: <span class="ch">invokedynamic</span> #13,  0   // InvokeDynamic #0:test:(I)Ljava/util/function/IntPredicate;
                        11: areturn
                      LineNumberTable:
                        line 14: 0
                        line 15: 5

            </code><div class="lang">Bytecode</div></pre>
            <aside class="notes">
                <ul>
                    <li>concepteurs JSR 335</li>
                    <li>profiter ¬´ InvokeDynamic ¬ª Java 7</li>
                    <li>r√©sister changement futurs de mise en ≈ìuvre</li>
                    <li>g√©n√©ration instance de ¬´ IntPredicate ¬ª √† la vol√©e</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Les concepteurs de la JSR 335 vont tirer partit de l'instruction de la JVM introduite en Java 7-->
<!--                pour les langages dynamique : ¬´ InvokeDynamic ¬ª. L'id√©e, c'est de se rendre r√©sistants √† de potentiels-->
<!--                futurs choix de mise en ≈ìuvre en g√©n√©rant cette classe interne instance de ¬´ IntPredicate ¬ª √† la vol√©e.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                  public static java.util.function.IntPredicate parametricPredicate(int);
                    descriptor: (I)Ljava/util/function/IntPredicate;
                    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
                    Code:
                      stack=1, locals=2, args_size=1
                         0: iload_0
                         1: invokestatic  #7        // Method longComputation:(I)I
                         4: istore_1
                         5: iload_1
                         6: <span class="ch">invokedynamic</span> #13,  0   <span class="ch">// InvokeDynamic #0:test:(I)Ljava/util/function/IntPredicate;</span>
                        11: areturn
                      LineNumberTable:
                        line 14: 0
                        line 15: 5

            </code><div class="lang">Bytecode</div></pre>
            <aside class="notes">
                <ul>
                    <li>r√©f√©rence une m√©thode d'amor√ßage (index 0)</li>
                    <li>la m√©thode de cr√©ation pas connue avant l'ex√©cution</li>
                    <li>construction de l'invocation de cette cr√©ation</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Cette instruction r√©f√©rence une m√©thode Java dite d'amor√ßage (¬´ Bootstrap ¬ª) d√©crite √† l'index 0 d'une table des m√©thodes-->
<!--                d'amor√ßage. L'id√©e, c'est que la m√©thode que l'on va appeler effectivement n'est pas connue avant l'ex√©cution de cette m√©thode.-->
<!--                Elle va litt√©ralement construire le point d'appel d'une autre m√©thode, prenant un entier en param√®tre et retournant un-->
<!--                ¬´ IntPredicate ¬ª, √† la vol√©e.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                BootstrapMethods:
                  0: #94 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(
                                Ljava/lang/invoke/MethodHandles$Lookup;
                                Ljava/lang/String;Ljava/lang/invoke/MethodType;
                                Ljava/lang/invoke/MethodType;
                                Ljava/lang/invoke/MethodHandle;
                                Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
                    Method arguments:
                      #79 (I)Z
                      #81 REF_invokeStatic Main.lambda$parametricPredicate$0:(II)Z
                      #79 (I)Z

            </code><div class="lang">Bytecode</div></pre>
            <aside class="notes">
                <ul>
                    <li>table des m√©thodes d'amor√ßage</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et quand on cherche ladite table des m√©thodes d'amor√ßage, on trouve effectivement la description d'une-->
<!--                m√©thode statique ¬´ metafactory ¬ª de la classe ¬´ LambdaMetafactory ¬ª.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                BootstrapMethods:
                  0: #94 REF_invokeStatic java/lang/invoke/<span class="ch">LambdaMetafactory</span>.metafactory:(
                                Ljava/lang/invoke/MethodHandles$Lookup;
                                Ljava/lang/String;Ljava/lang/invoke/MethodType;
                                Ljava/lang/invoke/MethodType;
                                Ljava/lang/invoke/MethodHandle;
                                Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
                    Method arguments:
                      #79 (I)Z
                      #81 REF_invokeStatic Main.lambda$parametricPredicate$0:(II)Z
                      #79 (I)Z

            </code><div class="lang">Bytecode</div></pre>
            <aside class="notes">
                <ul>
                    <li>¬´ metafactory ¬ª de la classe ¬´ LambdaMetafactory ¬ª</li>
                </ul>
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                BootstrapMethods:
                  0: #94 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(
                                Ljava/lang/invoke/MethodHandles$Lookup;
                                Ljava/lang/String;Ljava/lang/invoke/MethodType;
                                Ljava/lang/invoke/MethodType;
                                Ljava/lang/invoke/MethodHandle;
                                Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
                    Method arguments:
                      #79 (I)Z
                      #81 REF_invokeStatic <span class="ch">Main.lambda$parametricPredicate$0:(II)Z</span>
                      #79 (I)Z

            </code><div class="lang">Bytecode</div></pre>
            <aside class="notes">
                <ul>
                    <li>argument fonction lambda-lift√©e ¬´ lambda$parametricPredicate$0 ¬ª</li>
                    <li>cr√©ation classe similaire √† ¬´ Closure ¬ª</li>
                    <li>appel du constructeur pour l'instancier</li>
                    <li>m√©thode Java tout √† fait consultable</li>
                    <li>biblioth√®que de manipulation de bytecode ¬´ ASM ¬ª</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Sans trop rentrer dans des d√©tails qui d√©passent le cadre de cette pr√©sentation, on voit qu'elle prend-->
<!--                comme argument la fonction lambda-lift√©e ¬´ lambda$parametricPredicate$0 ¬ª. Et son travail va consister-->
<!--                √† construire une classe similaire √† la classe ¬´ Closure ¬ª de mon exemple pr√©c√©dent, et √† g√©n√©rer l'appel-->
<!--                √† son constructeur avec la valeur de ¬´ c ¬ª en param√®tre. Cette m√©thode d'amor√ßage est √©crite en Java et-->
<!--                vous pouvez facilement en consulter le code qui se trouve dans la runtime. D'ailleurs pour g√©n√©rer cette-->
<!--                classe, elle s'appuie sur un clone de la biblioth√®que de manipulation de bytecode ¬´ ASM ¬ª.-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;">
                <object data="./images/Indy/1.svg"></object>
            </div>
            <aside class="notes">
                <ul>
                    <li>¬´ invokedynamic ¬ª ex√©cut√©e dans le flux de bytecode...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Tout se passe comme dans le sch√©ma suivant: l'instruction ¬´ invokedynamic ¬ª est ex√©cut√©e dans le flux de-->
<!--                bytecode...-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;">
                <object data="./images/Indy/2.svg"></object>
            </div>
            <aside class="notes">
                <ul>
                    <li>... m√©thode de bootstrap correspondante est invoqu√©e ...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                ... la m√©thode de bootstrap correspondante est invoqu√©e ...-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;">
                <object data="./images/Indy/3.svg"></object>
            </div>
            <aside class="notes">
                <ul>
                    <li>produit une classe √† la vol√©e</li>
                    <li>¬´ CallSite ¬ª, point d'appel, pour le constructeur</li>
                </ul>

            </aside>
<!--            <aside class="notes">-->
<!--                ... qui produit une classe √† la vol√©e et ¬´ CallSite ¬ª, ou point d'appel, pour son constructeur prenant-->
<!--                en argument la valeur de la variable ¬´ c ¬ª.-->

<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;">
                <object data="./images/Indy/4.svg"></object>
            </div>
            <aside class="notes">
                <ul>
                    <li>Point d'appel constant</li>
                    <li>Pas langage dynamique</li>
                    <li>Contournement de metafactory</li>
                    <li>JIT pourra optimiser le tout</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Mais dans le cas des lambdas, ce call site est de type constant (personne ne viendra le modifier comme-->
<!--                cel√† pourrait arriver dans un langage dynamique). Donc tout appel ult√©rieur sautera directement au-->
<!--                ¬´ call site ¬ª et le JIT pourra s'en donner √† c≈ìur joie pour optimiser le tout.-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;">
                <object data="./images/Indy/5.svg"></object>
            </div>
        </section>

        <section>
            <h1>Pour Conclure</h1>
            <aside class="notes">
                <ul>
                    <li>fonctions anonymes li√©es lexicalement populaires</li>
                    <li>sans r√©cup√©ration automatique de la m√©moire</li>
                    <li>C++ ou Rust</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Le fonctions anonymes li√©es lexicalement ont tellement fait leur chemin qu'on les retrouve dans des-->
<!--                langages sans processus de r√©cup√©ration automatique de la m√©moire comme C++ ou Rust.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="rust" style="max-height: 800px" data-noescape>

                        fn long_computation(x: i64) -> i64 { x * x }

                        fn parametric_predicate(x: i64) -> impl FnMut(&i64) -> bool {
                            let c = long_computation(x);
                            move |y| { y % c == 0 }
                        }

                        fn main() {
                            let a_range = 1 .. 100;
                            let predicate = parametric_predicate(3);
                            let filtered_range = a_range.filter(predicate);
                            println!("{:?}", filtered_range.collect::&lt;Vec&lt;i64&gt;&gt;())
                        }

                        // [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99]

            </code><div class="lang">Rust</div></pre>
            <aside class="notes">
                <ul>
                    <li>Graydon Hoare</li>
                    <li>¬´ language engineer ¬ª, est un amateur de d'OCaml</li>
                    <li>premiers compilos en OCaml</li>
                    <li>pas d√©pays√©s</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Dans le cas de Rust √ßa n'est pas particuli√®rement √©tonnant. Son concepteur initial, Graydon Hoare, fin-->
<!--                connaisseur de la mise en ≈ìuvre des langages de programmation et qui se d√©crit comme un ¬´ language-->
<!--                engineer ¬ª, est un amateur de d'OCaml. D'ailleurs les premi√®res versions de Rust, avant qui ne soit-->
<!--                ¬´ self hosted ¬ª, √©taient √©crite en OCaml.-->
<!--                <br><br>-->
<!--                Et effectivement √† regarder rapidement notre exemple fil rouge en Rust on n'est pas d√©pays√© !-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="rust" style="max-height: 800px" data-noescape>

                        fn long_computation(x: i64) -> i64 { x * x }

                        fn parametric_predicate(x: i64) -> <span class="ch">impl FnMut(&i64) -> bool</span> {
                            let c = long_computation(x);
                            move <span class="ch">|y| { y % c == 0 }</span>
                        }

                        fn main() {
                            let a_range = 1 .. 100;
                            let predicate = parametric_predicate(3);
                            let filtered_range = a_range.filter(predicate);
                            println!("{:?}", filtered_range.collect::&lt;Vec&lt;i64&gt;&gt;())
                        }

                        // [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99]

            </code><div class="lang">Rust</div></pre>
            <aside class="notes">
                <ul>
                    <li>d√©claration d'un type fonctionnel</li>
                    <li>√©criture d'une lambda</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                La d√©claration d'un type fonctionnel est √† mi-chemin entre Kotlin et Java, et l'√©criture d'une lambda-->
<!--                en elle-m√™me n'a rien de r√©volutionnaire.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="rust" style="max-height: 800px" data-noescape>

                        fn long_computation(x: i64) -> i64 { x * x }

                        fn parametric_predicate(x: i64) -> impl FnMut(&i64) -> bool {
                            let c = long_computation(x);
                            <span class="ch">move</span> |y| { y % <span class="ch">c</span> == 0 }
                        }

                        fn main() {
                            let a_range = 1 .. 100;
                            let predicate = parametric_predicate(3);
                            let filtered_range = a_range.filter(predicate);
                            println!("{:?}", filtered_range.collect::&lt;Vec&lt;i64&gt;&gt;())
                        }

                        // [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99]

            </code><div class="lang">Rust</div></pre>
            <aside class="notes">
                <ul>
                    <li>imp√©ratifs li√©s au mod√®le de gestion m√©moire</li>
                    <li>¬´ move ¬ª pour g√©rer la capture de la variable</li>
                    <li>lambda, une fonction anonyme</li>
                    <li> dynamiquement ou lexicalement li√©e</li>
                    <li>gestion de la capture de son environnement</li>
                    <li>valeurs fonctionnelles que l'on appelle closure</li>
                    <li>strat√©gies de mises en ≈ìuvre nombreuses</li>
                    <li>sp√©cificit√©s du langage</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Tout au plus les imp√©ratifs li√©s au mod√®le de gestion m√©moire de Rust imposent quelques subtilit√©s,-->
<!--                comme ici l'usage du mot clef ¬´ move ¬ª pour g√©rer la capture de la variable ¬´ c ¬ª qui doit survivre-->
<!--                √† l'invocation de ¬´ parametric_predicate ¬ª.-->
<!--                <br><br>-->
<!--                Ce que l'on pourra retenir de tout √ßa, c'est qu'une lambda, une fonction anonyme, peut √™tre dynamiquement-->
<!--                ou lexicalement li√©e. Et que dans le second cas pour g√©rer la capture de son environnement in faut une-->
<!--                repr√©sentation des valeurs fonctionnelles que l'on appelle closure. Que les strat√©gies de mises en ≈ìuvre-->
<!--                sont nombreuses et tiennent compte des sp√©cificit√©s du langage.-->
<!--            </aside>-->
        </section>

        <section>
            <div style="display: flex; justify-content: space-between">
                <div style="margin-left: 2em; display: flex; flex-direction: column">
                    <div style="margin-top: 1em; font-size: 1.55em; text-align: left" class="green">Fr√©d√©ric Cabestre</div>
                </div>
            </div>
            <h1 style="margin-top: 1em">Merci</h1>
            <div style="display: grid; grid: 'one two three four' / 1fr 1fr 1fr 1fr; margin-bottom: 100%; margin-top: 2em">
                <div style="justify-self: center; grid-area: one">
                    <div>Feedback</div>
                    <img src="./images/feedback.png" alt="">
                </div>
                <div style="justify-self: center; grid-area: four">
                    <div>Pr√©sentation</div>
                    <img src="./images/presentation.png" alt="">
                </div>
            </div>
        </section>
    </div>
</div>

<script src="./dist/reveal.js"></script>
<script src="./plugin/notes/notes.js"></script>
<script src="./plugin/markdown/markdown.js"></script>
<script src="./plugin/highlight-old/highlight.js"></script>
<script src="./plugin/math/math.js"></script>

<script>
    Reveal.initialize({
        controls: false,
        progress: false,
        history: true,
        center: true,
        width: 1600,
        height: 900,

        transition: "none",

        plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX],

        katex: {
            local: " ",
            trust: true
        },
    });
</script>
</body>
</html>
