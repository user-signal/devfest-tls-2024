<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>

    <title>Fermé pour inventaire</title>

    <meta name="description" content="Histoire et mécanique des « closures »"/>
    <meta name="author" content="Frédéric Cabestre"/>

    <link rel="stylesheet" href="./dist/reset.css">
    <link rel="stylesheet" href="./dist/reveal.css">
    <link rel="stylesheet" href="./dist/theme/transparents.css" id="theme"/>

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="./plugin/highlight/zenburn.css"/>
</head>

<body>
<div class="reveal">
    <div class="slides">

        <section>
            <h1>Fermé pour inventaire</h1>
            <h3>Histoire et mécanique des « closures »</h3>
            <aside class="notes">
                Bonjour à tous, et merci d'avoir choisi cette session dans laquelle il ne sera question ni de Kubernetes,
                ni d'IA... Quoique ? Il y sera en revanche question fonctions anonymes et de leur mise en œuvre. Et celà
                au travers de nombreux fragments de code qui devraient être suffisamment faciles à suivre. Dans tous les
                cas à la fin vous trouverez des pointeurs vers cette présentation elle-même et le code associé sur GitHub.
            </aside>
        </section>

        <section>
            <div style="display: flex; justify-content: space-between">
                <div style="margin-left: 2em; display: flex; flex-direction: column">
                    <div style="margin-top: 1em; font-size: 1.55em; text-align: left" class="green">Frédéric Cabestre</div>
                </div>
            </div>
            <blockquote style="margin-top: 8em; margin-right: 2em; margin-bottom: 100%">
                Soy cantor, soy embustero<br>
                Me gusta el juego y el vino, tengo alma de marinero<br>
                ¿Qué le voy a hacer si yo nací en el Mediterráneo?
                <div style="margin-top:1ex; font-size: smaller">&mdash; Juan Manuel Serrat</div>
            </blockquote>
<!--            <blockquote style="margin-top: 11.45em; margin-right: 2em; margin-bottom: 100%">-->
<!--                Le présent sans passé n'a pas d'avenir-->
<!--                <div style="font-size: smaller">&mdash; <a href="https://fr.wikipedia.org/wiki/Fernand_Braudel">Fernand Braudel</a></div>-->
<!--            </blockquote>-->
            <aside class="notes">
                Je suis Frédéric Cabestre, un artisan du logiciel indépendant issu il y a fort longtemps du monde
                académique... Ce qui a laissé quelques traces. Si vous avez des soucis avec des sujets ésotériques ou
                tout simplement besoin de faire accompagner une équipe de développement, vous pouvez me contacter...
                Vous trouverez bien comment faire.
            </aside>
        </section>

        <section>
            <h1><span style="font-size:2em;text-transform:lowercase">$\lambda$</span></h1>
            <aside class="notes">
                <ul>
                    <li>Fonctions d'ordre supérieur</li>
                    <li>Outils de base</li>
                    <li>Citoyen de première classe</li>
                    <li>Valeur fonctionnelle</li>
                    <li>Lambda / anonyme</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Les fonctions d'ordre supérieur (c'est-à-dire dont les paramètres sont des fonctions ou dont la valeur de-->
<!--                retour peut être une fonction) font définitivement partie de l'outillage de base du développeur.-->
<!--                <br><br>-->
<!--                Pour celà les fonctions sont devenues des entités de première classe des langages de programmation. Autrement dit-->
<!--                ce sont des valeurs à part entière que l'on peut par exemple affecter à des variables.-->
<!--                <br><br>-->
<!--                Il n'est d'ailleurs même plus nécessaire de les nommer pour pouvoir les définir. Nous pouvons créer des fonctions anonymes-->
<!--                communément appelées « lambdas ».-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px">

                                val aList = 1..100
                                val filteredList = aList.filter({ x -> x % 2 == 0 })
                                println(filteredList)

                                /*

                                  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
                                   28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50,
                                   52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
                                   76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100]

                                */

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>Kotlin</li>
                    <li>C#, Rust, Java ou Javascript</li>
                    <li>pas de trouble, typage </li>
                    <li>contrairement à...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Dans ce qui suit l'essentiel des exemples de code seront en Kotlin. J'aurais pu m'appuyer sur C#, Rust, Java-->
<!--                ou Javascript... Non, quand même pas Javascript ! Mais Kotlin c'est mon langage du moment, dont la lecture-->
<!--                ne devrait pas vous troubler. Contrairement à...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="language-lisp" style="max-height: 800px">

                    (defun filter (fn list)
                        (cond ((null list) nil)
                              (t (cond ((funcall (eval fn) (car list)) (cons (car list) (filter fn (cdr list))))
                                       (t (filter fn (cdr list)))))))

                    (filter '(lambda (x) (= (mod x 2) 0)) '(1 2 3 4 5 6))

            </code><div class="lang">Lisp</div></pre>
            <aside class="notes">
                <ul>
                    <li>Common Lisp</li>
                    <li>Fil rouge historique</li>
                    <li>Enseigné à la fac</li>
                    <li>Bavé</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                ... Common Lisp. Si Lisp va être une sorte de fil rouge historique de cette présentation, je n'avais pas-->
<!--                envie de vous perdre bêtement en route. D'autant que, moi qui ai enseigné en TP de Lisp à la Fac il y a-->
<!--                plus de 25 ans, j'en ai un peu bavé pour écrire cet exemple pourtant simple.-->
<!--            </aside>-->
        </section>

        <section>

            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                                val aList = 1..100
                                val filteredList = aList.filter({ x -> x % 2 == 0 })
                                println(filteredList)

                                /*

                                  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
                                   28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50,
                                   52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
                                   76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100]

                                */

            </code><div class="lang">Kotlin</div></pre>
            <pre class="fragment" style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        public inline fun &lt;T&gt; <span class="ch">Iterable&lt;T&gt;</span>.filter(predicate: (T) -> Boolean): List&lt;T&gt; {
                            return filterTo(ArrayList&lt;T&gt;(), predicate)
                        }

            </code><div class="lang">Kotlin</div></pre>
           <aside class="notes">
               <ul>
                   <li>Intention plus que procédure</li>
                   <li>Filter...</li>
               </ul>
           </aside>
<!--           <aside class="notes">-->
<!--               Cet attirail permet d'exprimer plus l'intention que la procédure à suivre. Par exemple ici en disposant d'une-->
<!--               fonction « filter » sur des collections, à laquelle on peut fournir un prédicat, il n'est plus besoin de s'appesantir-->
<!--               sur les détails d'une itération. La démarche est plus déclarative que procédurale.-->
<!--           </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                                val aList = 1..100
                                val filteredList = aList.filter({ x -> x % 2 == 0 })
                                println(filteredList)

                                /*

                                  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
                                   28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50,
                                   52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
                                   76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100]

                                */
                
            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        public inline fun &lt;T&gt; Iterable&lt;T&gt;.filter(predicate: <span class="ch">(T) -> Boolean</span>): List&lt;T&gt; {
                            return filterTo(ArrayList&lt;T&gt;(), predicate)
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>... iterable, prédicat en paramètre</li>
                    <li>Démarche plus déclarative que procédurale</li>
                </ul>
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        (Int) -> Boolean

                        <span class="fragment">(Int, String) -> String</span>

                        <span class="fragment">((Float) -> Float) -> Float</span>

                        <span class="fragment">(Float) -> (Float) -> Float</span>

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>fonctions citoyens de première classe</li>
                    <li>description type</li>
                    <li>exemple</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                En Kotlin les fonctions sont des citoyens de première classe, et en tant que telles, on doit pouvoir en-->
<!--                décrire le type. Ici, nous avons plusieurs exemples. Le type des fonctions qui prennent :-->
<!--                <ul>-->
<!--                   <li>un entier en paramètre et retournent un booleen</li>-->
<!--                   <li>une paire entier, chaîne de caractère en paramètre et retournent un booleen</li>-->
<!--                   <li>une fonction de flottant vers flottant et retournent un flottant</li>-->
<!--                   <li>un flottant et retournent une fonction de flottant vers flottant </li>-->
<!--                </ul>-->
<!--                Notez l'importance des parenthèses entre les deux derniers exemples, du fait de l'associativité à droite-->
<!--                de l'opérateur ->.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        aList.filter(<span class="ch">{ x -> x % 2 == 0 }</span>)

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>lambda surbrillance</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Dans cet exemple la partie en surbrillance est donc une lambda prenant en paramètre un entier et vérifiant-->
<!--                s'il est pair (le reste de la division par 2 doit être 0).-->
<!--            </aside>-->
        </section>

<!--        <section>-->
<!--            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>-->

<!--                        aList.filter(<span class="ch">{ x -> x % 2 == 0 }</span>)-->

<!--            </code><div class="lang">Kotlin</div></pre>-->
<!--            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>-->

<!--                        aList.filter({ x<span class="ch">: Int</span> -> x % 2 == 0 })-->

<!--            </code><div class="lang">Kotlin</div></pre>-->
<!--            <aside class="notes">-->
<!--                <ul>-->
<!--                    <li>Inférence type</li>-->
<!--                </ul>-->
<!--            </aside>-->
<!--            <aside class="notes">-->
<!--                Kotlin, comme beaucoup de langages aujourd'hui, dispose de capacités d'inférence de type. Ce qui permet-->
<!--                dans une certaine mesure de s'économiser quelques annotations de type.-->
<!--            </aside>-->
<!--        </section>-->

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        aList.filter({ x -> x % 2 == 0 })

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        aList.filter({ <span class="ch">it</span> % 2 == 0 })

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>Particularité Kotlin</li>
                    <li>it</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Particularité de Kotlin, on peut dans certains cas, comme ici, nommer implicitement un paramètre unique-->
<!--                « it ».-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        aList.filter({ x -> x % 2 == 0 })

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        aList.filter({ it % 2 == 0 })

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape="">

                        aList.filter { it % 2 == 0 }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>Particularité Kotlin</li>
                    <li>lambda en dernière position des paramètre</li>
                    <li>Groovy</li>
                    <li>DSL embarqués</li>
                    <li>Mais pas le meilleur exemple...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et autre particularité de Kotlin, une lambda en dernière position des paramètres d'une fonction peut être-->
<!--                sortie de la liste des paramètres. C'est un emprunt à Groovy, je crois, qui contribue à faire de Kotlin-->
<!--                un langage sympathique pour faire des DSL embarqués... Mais ça sera l'objet d'une autre présentation.-->
<!--                Qui sait ?-->
<!--                <br><br>-->
<!--                En tout état de cause, cet exemple n'est pas des plus intéressants pour notre exploration...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun longComputation(x: Int): Int {
                            return x * x // 🤡
                        }

                        fun parametricPredicate(x: Int, y: Int): Boolean {
                            val c = longComputation(x)
                            return y % c == 0
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre class="fragment" style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px">

                        fun main() {
                            val aList = 1..100
                            val filteredList = aList.filter { y -> parametricPredicate(3, y) }
                            println(filteredList)

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>prédicat ajustable</li>
                    <li>long calcul</li>
                    <li>tiré par les cheveux</li>
                    <li>adapter avec fonction anonyme</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Considérons plutôt celui-ci : un prédicat ajustable par son premier paramètre ( « x ») pour vérifier une-->
<!--                propriété du second paramètre (« y »). Et tant qu'à faire, cet ajustement est le résultat d'un calcul-->
<!--                arbitrairement long effectué sur « x ».-->
<!--                <br><br>-->
<!--                Je vous l'accorde, c'est un exemple tiré par le peu de cheveux qu'il me reste. Mais il faut faire simple-->
<!--                pour parler de choses compliquées.-->
<!--                <br><br>-->
<!--                Et si l'on veut utiliser ce prédicat à deux arguments, dans le même contexte que précédemment, il va-->
<!--                falloir l'adapter, à l'aide d'une fonction anonyme...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun longComputation(x: Int): Int {
                            return x * x // 🤡
                        }

                        fun parametricPredicate(x: Int, y: Int): Boolean {
                            val c = longComputation(x)
                            return y % c == 0
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val filteredList = aList.filter <span class="ch">{ y -> parametricPredicate(3, y) }</span>
                            println(filteredList)

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>ramener à un seul paramètre</li>
                    <li>« longComputation » à chaque itération de « filter »</li>
                    <li>sortir ce long calcul de « parametricPredicate »</li>
                    <li>application partielle</li>
                    <li>...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                ... en fixant le premier argument pour le ramener à un seul paramètre à tester.-->
<!--                <br><br>-->
<!--                Un inconvénient de cette approche est que « longComputation » sera effectuée à chaque itération de « filter ».-->
<!--                <br><br>-->
<!--                Une façon de résoudre ce problème est de sortir ce long calcul de « parametricPredicate ». Mais j'ai envie-->
<!--                de vous présenter une autre approche qui serait de pouvoir appliquer partiellement « parametricPredicate » à-->
<!--                un argument. Et pour cela je dois vous parler de...-->
<!--            </aside>-->
        </section>

        <section>
            <h1>Curryfication</h1>
            <aside class="notes">
                <ul>
                    <li>Haskell Curry</li>
                    <li>logicien 20ᵉ siècle</li>
                    <li>logique combinatoire</li>
                    <li>langage Haskell</li>
                    <li>Moses Schönfinkel</li>
                    <li>De quoi s'agit-il ?</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Ce terme est dérivé du nom d'Haskell Curry, un logicien du 20ᵉ siècle ayant mené des travaux sur la logique-->
<!--                combinatoire et qui donné son prénom à un célèbre langage fonctionnel. En réalité ce concept-->
<!--                est plutôt dû à Moses Schönfinkel, mais Schönfinkelification aurait été plus difficile à prononcer.-->
<!--                <br><br>-->
<!--                Alors de quoi s'agit-il ?-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;  display: grid; grid-template-rows: 2fr 1fr">
                <div style="margin-top: .5em; font-size: 2.11em">$f: (A, B) \rightarrow C$</div>
                <div class="fragment" style="margin-top: .25em; font-size: 2.11em">$f: A \rightarrow (B \rightarrow C)$</div>
            </div>
            <aside class="notes">
                <ul>
                    <li>fonction à 2 paramètres...</li>
                    <li>récursivement N paramètres...</li>
                    <li>application partielle</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Tout simplement de voir une fonction à 2 paramètres...-->
<!--                <br><br>-->
<!--                ... comme équivalente à une fonction à un paramètre produisant un autre fonction à un paramètre.-->
<!--                <br><br>-->
<!--                Et donc comme une fonction que l'on peut appliquer partiellement ou graduellement à plusieurs arguments.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int, y: Int): Boolean {
                            val c = longComputation(x)
                            return y % c == 0
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = { y -> parametricPredicate(3, y) }
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>exemple de ravail</li>
                    <li>curryfier  « parametricPredicate »...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Si l'on repart de notre example de travail, curryfier « parametricPredicate » revient à le transformer ainsi...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = parametricPredicate(3)
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>Que peut-on constater ici ?</li>
                </ul>
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): <span class="ch">(Int) -> Boolean</span> {
                            val c = longComputation(x)
                            return <span class="ch">{ y -> y % c == 0 }</span>
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = parametricPredicate(3)
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>Un seul paramètre</li>
                    <li>retourne une fonction</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Qu'elle ne prend plus qu'un seul paramètre, celui qui va servir à « longComputation ». Et que son type-->
<!--                indique bien qu'elle retourne une fonction de Int vers Boolean.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = <span class="ch">parametricPredicate(3)</span>
                            println(aList.filter(predicate))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>Affectation variable</li>
                    <li>citoyens de première classe...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Que l'on peut éventuellement affecter son résultat à une variable. N'oublions pas que les fonctions sont-->
<!--                ici des citoyens de première classe...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun main() {
                            val aList = 1..100
                            val predicate = parametricPredicate(3)
                            println(aList.filter(<span class="ch">predicate</span>))

                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>utilisation pour filter</li>
                    <li>long calcul 1 fois</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et donc qu'on peut utiliser ce résultat comme prédicat pour « filter » et accessoirement cette fois-->
<!--                le long calcul n'est effectué qu'une seule fois et non à chaque itération du filtre.-->
<!--            </aside>-->
        </section>

<!--        <section>-->
<!--            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>-->

<!--                        val parametricPredicate: (Int) -> (Int) -> Boolean = { x ->-->
<!--                            val c = longComputation(x);-->
<!--                            { y -> y % c == 0 }-->
<!--                        }-->

<!--            </code><div class="lang">Kotlin</div></pre>-->
<!--            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>-->

<!--                        fun main() {-->
<!--                            val aList = 1..100-->
<!--                            val predicate = parametricPredicate(3)-->
<!--                            println(aList.filter(predicate))-->

<!--                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */-->
<!--                        }-->

<!--            </code><div class="lang">Kotlin</div></pre>-->
<!--            <aside class="notes">-->
<!--                <ul>-->
<!--                    <li>un pas de plus...</li>-->
<!--                </ul>-->
<!--            </aside>-->
<!--            <aside class="notes">-->
<!--                Soit dit en passant, on aurait aussi pu faire un pas de plus et dire que « parametricPredicate » est...-->
<!--            </aside>-->
<!--        </section>-->

<!--        <section>-->
<!--            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>-->

<!--                        val parametricPredicate: <span class="ch">(Int) -> (Int) -> Boolean</span> = { x ->-->
<!--                            val c = longComputation(x);-->
<!--                            { y -> y % c == 0 }-->
<!--                        }-->

<!--            </code><div class="lang">Kotlin</div></pre>-->
<!--            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>-->

<!--                        fun main() {-->
<!--                            val aList = 1..100-->
<!--                            val predicate = parametricPredicate(3)-->
<!--                            println(aList.filter(predicate))-->

<!--                            /* [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99] */-->
<!--                        }-->

<!--            </code><div class="lang">Kotlin</div></pre>-->
<!--            <aside class="notes">-->
<!--                <ul>-->
<!--                    <li>variable qui reçoit une fonction...</li>-->
<!--                    <li>mais bon...</li>-->
<!--                </ul>-->
<!--            </aside>-->
<!--            <aside class="notes">-->
<!--                ... une variable qui reçoit une fonction de Int qui retourne une fonction de Int vers Boolean.-->
<!--                Mais bon, restons là...-->
<!--            </aside>-->
<!--        </section>-->

        <section>
            <h1>Lisp 1.5</h1>
            <h2>1958</h2>
            <aside class="notes">
                Avant d'aller plus loin, faisons un premier saut en 1958 à la naissance de LISP.
            </aside>
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: auto auto; grid-template-rows: auto auto">
                <div>
                    <div style="grid-column: 1; grid-row: 1">
                        <img src="./images/john-mccarthy.png" alt="">
                    </div>
                    <div class="fragment" style="grid-column: 1; grid-row: 2">John MacCarthy</div>
                </div>
                <div class="fragment">
                    <div style="grid-column: 2; grid-row: 1/2">
                        <a href="http://www-formal.stanford.edu/jmc/recursive.pdf"><img style="border: thin solid black" src="./images/Lisp.png" alt=""></a>
                    </div>
                </div>
            </div>

            <aside class="notes">
                <ul>
                    <li>Cet élégant barbu est...John McCarthy (1927-2011)</li>
                    <li>Stanford</li>
                    <li>prix Turing en 1971</li>
                    <li>temps partagé (unix)</li>
                    <li>pionier IA (terminologie de lui)</li>
                    <li>algorithme Alpha-Béta></li>
                    <li>LISP (58) après FORTRAN (54)</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Cet élégant barbu est...-->
<!--                <br><br>-->
<!--                John McCarthy (1927-2011), chercheur de l'université de Standford ayant obtenu-->
<!--                le prix Turing en 1971, il est co-inventeur des systèmes à temps partagé (pensez Unix) et pionnier de l'IA-->
<!--                (on lui doit le terme). En 1956, il crée l'algorithme d'élagage Alpha-Béta utilisé au cœur de moteurs de-->
<!--                jeux pour les échecs par exemple.-->
<!--                <br><br>-->
<!--                Mais il a aussi contribué à la création de LISP en 1958 second langage concret après FORTRAN (1954).-->
<!--            </aside>-->
        </section>

        <section>
            <a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf"><img src="./images/HistoryOfLisp.png" alt=""></a>
            <aside class="notes">
                <ul>
                    <li> manipulation symbolique</li>
                    <li>FORTRAN calcul numérique</li>
                    <li>dérivation symbolique de fonctions mathématiques</li>
                    <li>recherche en IA et en théorie des langages</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Lisp est un langage conçu avant tout pour la manipulation symbolique, par opposition à FORTRAN dont le but et-->
<!--                le calcul numérique. L'idée était d'avoir un langage facilitant l'écriture d'algorithmes tels que la-->
<!--                dérivation symbolique de fonctions (une des premières applications) et largement adopté de ce fait dans-->
<!--                la recherche en IA et en théorie des langages (de programmation ou naturels)...-->
<!--            </aside>-->
        </section>

        <section>
            <img src="./images/HistoryOfLispHighlighted.png" alt="">
            <aside class="notes">
                <ul>
                    <li>initialement sans fonctions d'ordre supérieur</li>
                    <li>syntaxe proche de FORTRAN (le M-language)</li>
                    <li>structures de liste (le S-language)</li>
                    <li>plongement EVAL, APPLY</li>
                    <li>homo iconique</li>
                    <li>garbage collector</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et de manière assez cocasse, c'était à l'origine un langage sans fonctions d'ordre supérieur avec une-->
<!--                syntaxe proche de FORTRAN (le M-language) permettant de manipuler des structures de liste (le S-language).-->
<!--                Rapidement, on s'est aperçu qu'il est possible de plonger le premier dans le second grace aux fonctions-->
<!--                EVAL et APPLY, rendant LISP homo iconique. C'est-à-dire que la structure du langage et structure des données-->
<!--                manipulées est identique. Ça ouvre une porte à la méta-programmation qui s'apparente à la réflexivité.-->
<!--            </aside>-->
        </section>

        <section>
            <h1>Funarg Problem</h1>
            <aside class="notes">
                <ul>
                    <li>fonctions d'ordre supérieur</li>
                    <li>LAMBDAs</li>
                    <li>FUNARG</li>
                    <li>Pas si fonctionnel, pas lambda calcul</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Dans la foulée, LISP gagne les fonctions d'ordre supérieur et la possibilité de définir des fonctions-->
<!--                anonymes, des LAMBDAS. Un argument fonctionnel de fonction est ce que l'on nomme un FUNARG dans le jargon-->
<!--                Lispien.-->
<!--                <br><br>-->
<!--                J'ai cru pendant longtemps de LISP était avant tout fonctionnel et avait été inspiré-->
<!--                pas le lambda calcul. En fait LISP 1.5 était encore très impératif (SETQ, RPLACA...) et McCarthy aurait-->
<!--                indiqué s'en être peu inspiré.-->
<!--            </aside>-->
        </section>

        <section>
            <a href="https://dspace.mit.edu/bitstream/handle/1721.1/5854/AIM-199.pdf"><img style="border: thin solid black; margin-bottom: 100%; margin-top: 3em" src="./images/funarg-problem.png" alt=""></a>
            <aside class="notes">
                <ul>
                    <li>FUNARG problem</li>
                    <li>Joel Moses</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Sauf que dans les premières moutures de LISP, les FUNARG avaient un problème étudié (ici par Joel Moses-->
<!--                dans un mémo de MIT) et longuement débattu.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px">
                                fun longComputation(x: Int): Int {
                                    return x * x
                                }

                                fun parametricPredicate(x: Int): (Int) -> Boolean {
                                    val c = longComputation(x)
                                    return { y -> y % c == 0 }
                                }

                                fun main() {
                                    val c = 42
                                    val predicate: (Int) -> Boolean = parametricPredicate(3)
                                    if (predicate(81)) println("Ok") else println("Ko")
                                }
            </code><div class="lang">Kotlin</div></pre>
<!--            <aside class="notes">-->
<!--                Pour illustrer ce problème, reprenons notre exemple (pas en LISP bien sûr). C'est peu ou prou l'exemple-->
<!--                initial, mais sans l'appel à « filter » et avec une variable « c » définie dans « main ».-->
<!--            </aside>-->
            <aside class="notes">
                <ul>
                    <li>exemple sans appel à filter</li>
                    <li>variable « c » dans main</li>
                </ul>
            </aside>

        </section>

        <section>
            <h2>Les fonctions <span class="green">(récursives)</span> décortiquées</h2>
            <a style="margin-bottom: 100%" href="https://www.youtube.com/watch?v=aTDSZtHCIGU"><img src="./images/Devoxx-2022.png" alt=""></a>
            <aside class="notes">
                <ul>
                    <li>Auto promotion</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                En passant, je me permets une petite promotion éhontée pour une de mes présentations passées qui parle des-->
<!--                fonctions, éventuellement récursives, et de leur mise en œuvre. Présentation qui pourrait être un-->
<!--                complément intéressant à celle-ci.-->
<!--            </aside>-->

        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/1.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>environnement d'exécutio</li>
                    <li>enregistrement d'activation</li>
                    <li>créé à l'activation de la fonction</li>
                    <li>détruit quand elle se termine</li>
                    <li>pile (mais tous les labngages)</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Nous allons suivre pas à pas le déroulement de ce programme. Comme je l'explique plus en détail dans-->
<!--                mon autre présentation, l'environnement d'exécution d'une fonction est fourni par un enregistrement-->
<!--                d'activation plus tous ceux des fonctions appelantes. Un enregistrement est créé à l'activation de la-->
<!--                fonction et détruit quand elle se termine. Et dans la plupart des langages (mais pas tous) cette gestion-->
<!--                se fait sous forme de pile.-->
<!--                <br><br>-->
<!--                Donc ici, on commence avec l'enregistrement d'activation de « main » dans la pile.-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    <span class="ch">val c = 42</span>
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/2.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>« c » se voit affecter la valeur 42</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/2.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>appel « parametricPredicate » currifiée avec 3 en argument</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/3.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>nouvel enregistrement d'activation</li>
                </ul>
            </aside>
        </section>


        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = <span class="ch">longComputation(x)</span>
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/3.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>appel « longComputation »</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = <span class="ch">longComputation(x)</span>
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return <span class="ch">x * x</span>
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/4.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>nouvel enregistrement d'activation </li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = <span class="ch">longComputation(x)</span>
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return <span class="ch">x * x</span>
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/4b.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>« longComputation » produit et retourne son résultat 9.</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = <span class="ch">longComputation(x)</span>
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/5.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>affecté à « c » dans l'environnement de « parametricPredicate »</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return <span class="ch">{ y -> y % c == 0 }</span>
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/5b.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>naïvement pointeur sur fonction</li>
                    <li>C</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/6.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>adresse du code compilé « @Lambda0 »</li>
                    <li>retourné et affecté à la variable
                « predicate »</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if <span class="ch">(predicate(81))</span> println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/6.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>appel « predicate » avec 81 en paramètre</li>
                    <li>allocation enregistrement d'activation</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if <span class="ch">(predicate(81))</span> println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem/7.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>« c » n'a pas de valeur</li>
                    <li>remonte la chaîne, trouve 42</li>
                    <li>résultat faux, ça pourrait planter aussi</li>
                    <li>pire silencieusement erroné ou plantage</li>
                    <li>liaison dynamique, sujet débattu</li>
                    <li>idîome LISP</li>
                    <li>raisonnement local</li>
                </ul>
            </aside>
<!--            <aside>-->
<!--                Mais dans cet environnement « c » n'a pas de valeur, alors on remonte la chaîne des environnements pour-->
<!--                en trouver une. On tombe sur le 42 initial. Et là, c'est le drame ! On s'attend à un résultat positif-->
<!--                (81 est divisible par 9 en nombre entier), pourtant c'est faux parce que la lambda n'utilise pas la-->
<!--                bonne valeur de « c ». Il pourrait même ne pas y avoir de valeur pour « c ».-->
<!--                <br><br>-->
<!--                À vrai dire, je ne sais pas ce qui est le pire entre un programme qui plante clairement ou qui répond à-->
<!--                côté sans que l'on s'en aperçoive.-->
<!--                <br><br>-->
<!--                Alors ne nous méprenons pas : cela peut être considéré comme une fonctionnalité légitime. Ça s'appelle-->
<!--                de la liaison dynamique. Et pendant longtemps, le sujet a été débattu, avec ses partisans et ces détracteurs.-->
<!--                Et c'est même devenu un idîome LISP. On parle d'idîome dans un langage quand un design pattern est très-->
<!--                lié à la sémantique du langage.-->
<!--                <br><br>-->
<!--                Je serais enclin à dire, si l'on se place dans un cadre de programmation fonctionnelle, que le principe-->
<!--                de raisonnement local est mis à mal par un tel mécanisme. Quand je code, j'ai du mal avec les effets-->
<!--                contextuels d'utilisation d'une fonction autre que ses paramètres d'entrée.-->
<!--            </aside>-->
        </section>

        <section>
            <h1>Scheme</h1>
            <h2>1975</h2>
            <aside class="notes">
                <ul>
                    <li>sujet débattu pendant plus de 15 ans</li>
                    <li>arrivée de SCHEME</li>
                </ul>
            </aside>
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: auto auto; grid-template-rows: auto auto">
                <div>
                    <div style="grid-column: 1; grid-row: 1">
                        <img src="./images/Guy_Steele.jpg" alt="">
                    </div>
                    <div class="fragment" style="grid-column: 1; grid-row: 2">Guy L. Steele Jr.</div>
                </div>
                <div class="fragment">
                    <div style="grid-column: 2; grid-row: 1/2">
<!--                        <a href="https://media.githubusercontent.com/media/sarabander/sicp-pdf/master/sicp.pdf"><img src="./images/SICP.png" alt=""></a>-->
                        <a href="https://dspace.mit.edu/bitstream/handle/1721.1/5753/AIM-443.pdf"><img style="border: thin solid black" src="./images/LambdaTheUltimate.png" alt=""></a>
                    </div>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>Guy Lewis Steel Junior</li>
                    <li>EMACS et TeX</li>
                    <li>*LISP et C*, thinking machines</li>
                    <li>Common Lisp, C, Fortran commités</li>
                    <li>Java, Sun 1994, Oracle depuis 2010.</li>
                    <li>Verse, Epic Games, Simon Peyton-Jones</li>
                    <li>SCHEME 75, Gerald Jay Sussmann « Structure et interprétation des programmes informatiques »</li>
                    <li>« λ the ultimate » papers</li>
                    <li>partit de la liaison lexicale</li>
                    <li>explication</li>                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Jusqu'à croiser la route de...-->
<!--                <br><br>-->
<!--                Guy Lewis Steel Junior, à qui on doit entre autres Emacs et le premier portage de TeX de Donald Knuth. Il-->
<!--                a été impliqué dans la définition ou la normalisation de nombreux langages de programmation, comme *Lisp-->
<!--                et C* chez Thinking Machines ; Common Lisp, C, Fortran dans le cadre de commités ; Et Java en tant-->
<!--                qu'employé de Sun en 1994 puis Oracle depuis 2010. Il est même récemment allé travailler avec Epic Games-->
<!--                sur le langage Verse en compagnie de Simon Peyton-Jones, un des piliers d'Haskell.-->
<!--                <br><br>-->
<!--                Pour ce qui nous concerne aujourd'hui, il est surtout le co-créateur de Scheme en 1975 de SCHEME avec-->
<!--                Gerald Sussmann au MIT. Gerald Jay Sussmann auteur du livre « Structure and Interpretation of Computer-->
<!--                Programs », que je vous invite à parcourir tant il fait partie des fondamentaux.-->
<!--            </aside>-->
        </section>

<!--        <section>-->
<!--            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: auto auto; grid-template-rows: auto auto">-->
<!--                <div>-->
<!--                    <div style="grid-column: 1; grid-row: 1">-->
<!--                        <img src="./images/Guy_Steele.jpg" alt="">-->
<!--                    </div>-->
<!--                    <div style="grid-column: 1; grid-row: 2">Guy L. Steele Jr.</div>-->
<!--                </div>-->
<!--                <div>-->
<!--                    <div style="grid-column: 2; grid-row: 1/2">-->
<!--                        <a href="https://dspace.mit.edu/bitstream/handle/1721.1/5753/AIM-443.pdf"><img style="border: thin solid black" src="./images/LambdaTheUltimate.png" alt=""></a>-->
<!--                    </div>-->
<!--                </div>-->
<!--            </div>-->
<!--            <aside class="notes">-->
<!--                <ul>-->
<!--                    <li>« λ the ultimate » papers</li>-->
<!--                    <li>partit de la liaison lexicale</li>-->
<!--                    <li>explication</li>-->
<!--                </ul>-->
<!--            </aside>-->
<!--            <aside class="notes">-->
<!--                Il est aussi l'auteur des « λ the ultimate » papers. C'est une série d'articles parfois coécrits avec-->
<!--                Sussmann, qui prend le partit de la liaison lexicale. Il s'agit de faire en sorte, même au prix d'un-->
<!--                surcoût à l'exécution d'un programme, que les variables libres d'une lambda prennent la valeur qu'elles-->
<!--                avaient au moment de leur définition et non au moment de l'exécution.-->
<!--                <br><br>-->
<!--                Et au travers de multiples exemples, il montre toute l'utilité de ce concept.-->
<!--            </aside>-->
<!--        </section>-->

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;  display: grid; grid-template-columns: 3fr 2fr">
                <div style="justify-self: center">$x$</div>
                <div style="justify-self: start"> Variable</div>
                <div style="justify-self: center">$\lambda x.\,M$</div>
                <div style="justify-self: start"> Abstraction</div>
                <div style="justify-self: center; margin-bottom: 2.5em">$M\,N$</div>
                <div style="margin-bottom: 2.5em; justify-self: start"> Application</div>
                <div style="justify-self: center">$\lambda x.\,(f\,x) \rightarrow f$</div>
                <div style="justify-self: start">$\eta$-reduction</div>
                <div style="justify-self: center">$\lambda x.\,M[x] \rightarrow \lambda y.\,M[y]$</div>
                <div style="justify-self: start">$\alpha$-conversion</div>
                <div style="justify-self: center">$(\lambda x.\,M)\:E \rightarrow M[x:=E]$</div>
                <div style="justify-self: start">$\beta$-reduction</div>
            </div>
            <aside class="notes">
                <ul>
                    <li>Lambda calcul</li>
                    <li>syntaxe, interprétation</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Pour la peine, la liaison lexicale est au fondement de l'interprétation du lambda calcul.-->
<!--            </aside>-->
        </section>

        <section>
            <a href="https://www.cs.tufts.edu/comp/150FP/archive/peter-landin/mechanical-eval.pdf"><img style="border: thin solid black; margin-bottom: 100%; margin-top: 3em" src="./images/Landin.png" alt=""></a>
            <aside class="notes">
                <ul>
                    <li>Peter Landin datant de 1964</li>
                    <li>sucre syntaxique</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et sa mise en œuvre concrète est depuis longtemps comprise, comme dans cet article fondateur de Peter Landin-->
<!--                datant de 1964 ! Accessoirement lui doit aussi le terme « sucre syntaxique » !-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return <span class="ch">{ y -> y % c == 0 }</span>
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/5.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>« pointeur » sur le code insuffisant</li>
                    <li>élements de son environnemen</li>
                    <li>valeurs de ses variables libres</li>
                    <li>pas partie des paramètres</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Reprenons le déroulé de notre exemple là où le problème apparait. Retourner un « pointeur » sur le code-->
<!--                de la fonction anonyme ne suffit pas.-->
<!--            </aside>-->
        </section>


        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return <span class="ch">{ y -> y % c == 0 }</span>
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/5b.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>structure</li>
                    <li>variables libres </li>
                    <li>pointeur sur son code</li>
                    <li>tas, survie à désallocation</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                RIl faut aussi fournir des élements de son environnement qui feraient défault ultérieurement : les valeurs-->
<!--                de ses variables libres. Celles qui ne font pas partie des paramètres de la lambda.-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/6.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>affecté à predicate</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et de plus, on a besoin que cette information survive à la dés-allocation de l'enregistrement d'activation-->
<!--                de « parametricPredicate ». Pour celà, on va allouer une structure contenant valeur des variables libres de-->
<!--                la lambda et pointeur sur son code sur le tas (heap).-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = <span class="ch">parametricPredicate(3)</span>
    if (predicate(81)) println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/7.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>C'est une closure ou fermeture</li>
                    <li>inventaire des variables libre pour fermer la lambda</li>
                    <li>concept: lambda liée lexicalement</li>
                    <li>implem: closure</li>
                    <li>confusion des deux</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                C'est cette structure qu'on appelle « Closure » ou « Fermeture » : on fait l'inventaire des variables libres-->
<!--                four « fermer » la lambda. En ce sens, on peut dire qu'une fonction anonyme liée lexicalement est un concept-->
<!--                du langage et une « Fermeture » un détail d'implémentation. Après, peut-être à tort, les termes « lambda » et-->
<!--                « closure » sont devenus interchangeables dans certains discours.-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 1em; display: grid; grid: [row1-start] 'left center right' [row1-end][row1-start] 'bottom bottom bottom' [row1-end] / 1fr 1fr 1fr">
                <div style="grid-area: left">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun main() {
    val c = 42
    val predicate: (Int) -> Boolean = parametricPredicate(3)
    if <span class="ch">(predicate(81))</span> println("Ok") else println("Ko")
}
                    </code></pre>
                </div>
                <div style="grid-area: center">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun parametricPredicate(x: Int): (Int) -> Boolean {
    val c = longComputation(x)
    return { y -> y % c == 0 }
}

                    </code></pre>
                </div>
                <div style="grid-area: right">
                    <pre style="max-height: 800px; font-size: 0.8ex; margin-top: 0"><code class="Kotlin" data-noescape>
fun longComputation(x: Int): Int {
    return x * x
}


                    </code></pre>
                </div>
                <div style="grid-area: bottom; margin-bottom: 100%;">
                    <object data-fragment-index="4" data="./images/funarg-problem-solved/8.svg"></object>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>évaluation de « predicate(81)</li>
                    <li>bonne valeur de « c »</li>
                    <li>consensus liaison lexicale</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et maintenant, lors de l'évaluation de « predicate(81) » on fera référence à la valeur de « c » lors la-->
<!--                définition de la lambda et non celle de « main ». Encore une fois, c'est un choix qui s'est débattu et le-->
<!--                consensus actuel veut que la liaison lexicale soit la bonne approche.-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 2fr">
                <div style="grid-column: 2; grid-row: 1">
                    <img src="./images/Haskell-logo.png" alt="">
                </div>
                <div class="fragment" data-fragment-index="1" style="grid-column: 2; grid-row: 2">
                    <a href="https://www.cambridge.org/core/services/aop-cambridge-core/content/view/S0956796800000319"><img style="border: solid black 1px; margin-top: 2.5em" src="./images/Haskell.png" alt=""></a>
                </div>
                <div style="grid-column: 1; grid-row: 1">
                    <img src="./images/OCaml-logo.png" alt="">
                </div>
                <div class="fragment" data-fragment-index="1" style="grid-column: 1; grid-row: 2">
                    <a href="https://inria.hal.science/inria-00070049/document"><img style="border: solid black 1px; margin-top: 2.5em" src="./images/OCaml.png" alt=""></a>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>programmation fonctionnelle</li>
                    <li>Ocaml et Haskell -> LISP</li>
                    <li>curryfication</li>
                    <li>rapports internes mise en œuvre</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                C'est d'ailleurs le monde de la programmation fonctionnelle, tout au long de la fin du 20ᵉ siècle, qui a poussé-->
<!--                dans ce sens (avec ici deux emblématiques représentants, Haskell et OCaml), emportant dans son sillage le monde-->
<!--                lispien. Ici, vous avez deux rapports décrivant la mise en œuvre de l'un et l'autre. Et dans les deux cas la-->
<!--                notion de closure fait intégralement partie de la machine viiruelle (ou de l'environnement d'exécution) du-->
<!--                langage.-->
<!--            </aside>-->
        </section>

<!--        <section>-->
<!--            <img style="margin-top: 3em; margin-bottom: 100%" src="./images/OcamlClosures.png" alt="">-->
<!--            <aside class="notes">-->
<!--                <ul>-->
<!--                    <li> valeur fonctionnelle est « évidemment » représenté pas une closure</li>-->
<!--                    <li>subtilités récupération mémoire.</li>-->
<!--                </ul>-->
<!--            </aside>-->
<!--            <aside class="notes">-->
<!--                Dans le cas d'OCaml, il y est dit qu'une valeur fonctionnelle est « évidemment » représenté pas une closure,-->
<!--                c'est-à-dire une paire pointeur de code / environnement de liaison des variables. Il y est aussi expliqué qu'elles-->
<!--                sont allouée dans une space encore différent du tas pour de subtiles raisons de récupération mémoire.-->
<!--            </aside>-->
<!--        </section>-->

<!--        <section>-->
<!--            <img style="margin-top: 2em; margin-bottom: 100%" src="./images/HaskellClosures.png" alt="">-->
<!--            <aside class="notes">-->
<!--                <ul>-->
<!--                    <li>un peu plus compliqué</li>-->
<!--                    <li>langage paresseux</li>-->
<!--                    <li>thunk</li>-->
<!--                    <li>couple pointeur de code / environnement</li>-->
<!--                </ul>-->
<!--            </aside>-->
<!--            <aside class="notes">-->
<!--                Pour Haskell, comme le montre ce schéma, c'est un peu plus compliqué, ne serait-ce que du fait de choix de mise en-->
<!--                œuvre d'un langage paresseux ! Mais si on y prête attention on retrouve encore le couple pointeur de code / environnement.-->
<!--            </aside>-->
<!--        </section>-->

        <section>
            <h1>Clojure</h1>
            <h2>2007</h2>
            <aside class="notes">
                <ul>
                    <li>similitude entre les « Closures » et les objets</li>
                    <li>dictionnaire de valeurs et un pointeur sur du code</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                En plissant fortement les yeux, on notera tout de même une similitude entre les « Closures » et les-->
<!--                objets des langages OO : une structure avec un dictionnaire de valeurs et un pointeur sur du code qui fait-->
<!--                référence à ce dictionnaire. D'ailleurs Guy Steele dans ces « lambda the ultimate » papers en parle de-->
<!--                manière indirecte.-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-bottom: 100%; margin-top: 3em; display: grid; grid-template-columns: auto auto; grid-template-rows: auto auto">
                <div>
                    <div style="grid-column: 1; grid-row: 1">
                        <img src="./images/Hickey.png" alt="">
                    </div>
                    <div class="fragment" style="grid-column: 1; grid-row: 2">Rich Hickey</div>
                </div>
                <div class="fragment">
                    <div style="grid-column: 2; grid-row: 1/2">
                        <a href="https://dl.acm.org/doi/pdf/10.1145/3386321"><img style="border: thin solid black" src="./images/Clojure.png" alt=""></a>
                    </div>
                </div>
            </div>
            <aside class="notes">
                <ul>
                    <li>Rich Hickey</li>
                    <li>essai .NET, puis Java, notez le J</li>
                    <li>dialecte de SCHEME -> liaison lexicale</li>
                    <li>autres partits pris (appels terminaux et récursivité)</li>
                    <li>« Proceedings of the ACM on Programming Languages »</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                En 2007, Rich Hickey après avoir fait une première tentative sur la plateforme .NET, propose un dialecte-->
<!--                de Scheme ciblant la JVM. Et forcément, il adopte la liaison lexicale comme fondement pour la-->
<!--                définition des fonctions anonymes.-->
<!--                <br><br>-->
<!--                Et bien d'autres partis pris qu'il détaille dans cet article des-->
<!--                « Proceedings of the ACM on Programming Languages » (appels terminaux et récursivité).-->
<!--                <br><br>-->
<!--                Voyons comment il a (ou aurait) pu procéder pour mettre des « closure » sur une plateforme qui n'est pas-->
<!--                initialement prévue pour.-->
<!--            </aside>-->
        </section>

        <section>
            <h1><span style="text-transform:lowercase">$\lambda$</span>-lifting</h1>
            <aside class="notes">
                <ul>
                    <li>compilateurs pour des langages fonctionnels</li>
                    <li>« lambda lifting »</li>
                    <li>« lambda desugaring »</li>
                    <li>Forax</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                On va d'abord parler d'une transformation classique utilisée par les compilateurs pour des langages-->
<!--                fonctionnels. Elle n'est pas requise pour la suite, mais mérite qu'on la signale : Le « lambda lifting ».-->
<!--                D'autant plus que dans la compilation de Java aujourd'hui, et pour une raison qui m'échappe, on l'appelle-->
<!--                « lambda desugaring ». Il faudra qu'un jour, je pose la question à Rémi Forax...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre class="fragment" style="font-size: 1.1ex; margin-top: 1em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicateLambda(c: Int, y: Int): Boolean = y % c == 0

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> parametricPredicateLambda(c, y) }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>fonction sans variable libre</li>
                    <li>plus haut niveau</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                L'idée est très simple : une première transformation du code fait apparaitre une fonction sans variable-->
<!--                libre, au plus haut niveau, correspondant à la lambda que l'on veut compiler-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        <span class="ch">fun parametricPredicateLambda(c: Int, y: Int): Boolean = y % c == 0</span>

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> parametricPredicateLambda(c, y) }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>plus de paramètres</li>
                    <li>capture des variables libres</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Forcément, elle est susceptible d'avoir plus de paramètres que la lambda d'origine, puisque les variables-->
<!--                libres ne doivent plus l'être.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> y % c == 0 }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicateLambda(c: Int, y: Int): Boolean = y % c == 0

                        fun parametricPredicate(x: Int): (Int) -> Boolean {
                            val c = longComputation(x)
                            return { y -> <span class="ch">parametricPredicateLambda(c, y)</span> }
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>Là, vous me direz, on a fait que déplacer le problème... C'est pas faux !</li>
                </ul>

            </aside>
        </section>

        <section>
            <h1>Closure conversion</h1>
            <aside class="notes">
                <ul>
                    <li>transformation fondamentale</li>
                    <li>closure conversion</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                En fait, il y a une seconde transformation, qui elle en revanche en fondamentale pour notre sujet : la-->
<!--                « closure conversion ».-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>similitude objet <-> closure</li>
                </ul>
                Et c'est là que la similitude en objet et closure se voit un peu mieux.
            </aside>
<!--            <aside class="notes">-->
<!--                Et c'est là que la similitude en objet et closure se voit un peu mieux.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(<span class="ch">val capture: C</span>, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>utilisation d'une structure</li>
                    <li>variable capturée</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Sauf qu'ici, j'ai décidé d'utiliser une structure, plutôt qu'une classe, qui embarque la variable capturée...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, <span class="ch">val code: (C, I) -> O</span>)

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>pointeur sur le code</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                ... et le pointeur sur le code.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px">

                        fun parametricPredicate(x: Int): Closure&lt;Int, Int, Boolean&gt; {
                            val c = longComputation(x)
                            return Closure(c, ::parametricPredicateLambda)
                        }

                        fun main() {
                            val c = 42
                            val predicate: Closure&lt;Int, Int, Boolean&gt; = parametricPredicate(3)
                            if (predicate.code(predicate.capture, 81)) println("Ok") else println("Ko")
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>Réécriture de parametricPredicate...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Ce qui permet de réécrire « parametricPredicate »...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): Closure&lt;Int, Int, Boolean&gt; {
                            val c = longComputation(x)
                            return <span class="ch">Closure(c, ::parametricPredicateLambda)</span>
                        }

                        fun main() {
                            val c = 42
                            val predicate: Closure&lt;Int, Int, Boolean&gt; = parametricPredicate(3)
                            if (predicate.code(predicate.capture, 81)) println("Ok") else println("Ko")
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>représentation de la fonction</li>
                    <li>valeur variables libres</li>
                    <li>c'est une valeur fonctionnelle</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                ... de la façon suivante : elle retourne une représentation de la fonction anonyme accompagnée des-->
<!--                valeurs des variables capturées. C'est une représentation opérationnelle d'une valeur fonction.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="kotlin" style="max-height: 800px" data-noescape>

                        data class Closure&lt;C, I, O&gt;(val capture: C, val code: (C, I) -> O)

            </code><div class="lang">Kotlin</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="kotlin" style="max-height: 800px" data-noescape>

                        fun parametricPredicate(x: Int): Closure&lt;Int, Int, Boolean&gt; {
                            val c = longComputation(x)
                            return Closure(c, ::parametricPredicateLambda)
                        }

                        fun main() {
                            val c = 42
                            val predicate: Closure&lt;Int, Int, Boolean&gt; = parametricPredicate(3)
                            if (<span class="ch">predicate.code(predicate.capture, 81)</span>) println("Ok") else println("Ko")
                        }

            </code><div class="lang">Kotlin</div></pre>
            <aside class="notes">
                <ul>
                    <li>ajustement de l'appel</li>
                    <li>code fonction lambda liftée</li>
                    <li>valeur capturée et celle qu'on veut tester</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et forcément au point d'appel, il faut aussi effectuer une adaptation. On appelle le code de la-->
<!--                fonction lambda liftée avec ces deux arguments, la valeur capturée et celle qu'on veut tester.-->
<!--            </aside>-->
        </section>

        <section>
            <h1>Java 8</h1>
            <h2>2014</h2>
            <aside class="notes">
                <ul>
                    <li>acceptation des lambdas</li>
                    <li>sensibilité à la programmation fonctionnelle</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                L'utilisation de fonctions anonymes fait son chemin dans bien des langages. Peut-être parce que de plus en-->
<!--                plus de développeurs sont sensibilisés à la programmation fonctionnelle qui en use abondamment... Ou parce-->
<!--                que ça fait bien, allez savoir ?-->
<!--            </aside>-->
        </section>

        <section>
            <img style="border: thin solid" src="./images/JSR335.png" alt="">
            <aside class="notes">
                <ul>
                    <li>Clojure 2007 -> JSR 335 (java 8) 2014</li>
                    <li>gestation de 7 ans</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                En attendant, la gestation du support des lambda dans Java débute à la sortie de Clojure, en 2007 et va-->
<!--                quand même durer 7 ans, pour voir officiellement sortir la JSR 335 dans Java 8.-->
<!--            </aside>-->
        </section>

        <section>
            <a href="http://gafter.blogspot.com/2007/01/definition-of-closures.html"><img style="border: thin solid black" src="./images/Gafter.png" alt=""></a>
            <aside class="notes">
                <ul>
                    <li>Pourquoi tant de temps ?</li>
                    <li>plus d'entités liés lexicalement</li>
                    <li>à minima « this »</li>
                    <li>article de Neil Gafter</li>
                    <li>rétro compatibilité</li>
                    <li>évolutivité</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Pourquoi tant de temps ? Parce que Java est un langage orienté objets et que la somme des concepts sujets-->
<!--                à la liaison lexicale dépasse les variables d'une fonction anonyme Lisp. Ce qui est très bien expliqué-->
<!--                dans cet article de Neil Gafter, membre d'un groupe ayant formulé une des trois propositions d'intégrations-->
<!--                initiales (rien que ça). Mais aussi parce que les enjeux de rétro compatibilité et d'évolutivité de Java-->
<!--                en tant que plateforme sont grands.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static int longComputation(int x) {
                                    return x * x;
                                }

                                public static IntPredicate parametricPredicate(int x) {
                                    var c = longComputation(x);
                                    return y -> y % c == 0;
                                }

                                void main() {
                                    var aStream = IntStream.rangeClosed(0, 100);
                                    var predicate = parametricPredicate(3);
                                    IntStream filteredStream = aStream.filter(predicate);

                                    System.out.println(
                                            filteredStream.
                                                    mapToObj(Integer::toString).
                                                    collect(Collectors.joining(",", "[", "]")));
                                }

                                // [0,9,18,27,36,45,54,63,72,81,90,99]

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>Exemple en Java</li>
                    <li>21 plutôt que 8 -> Kotlin</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Voilà à quoi ressemble notre exemple en Java. J'ai utilisé ici la version 21 plutôt que la 8 avec la-->
<!--                fonctionnalité classe anonyme et méthode 'main' d'instance pour qu'il ressemble plus à la version Kotlin.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static int longComputation(int x) {
                                    return x * x;
                                }

                                public static IntPredicate parametricPredicate(int x) {
                                    var c = longComputation(x);
                                    return <span class="ch">y -> y % c == 0</span>;
                                }

                                void main() {
                                    var aStream = IntStream.rangeClosed(0, 100);
                                    var predicate = parametricPredicate(3);
                                    IntStream filteredStream = aStream.filter(predicate);

                                    System.out.println(
                                            filteredStream.
                                                    mapToObj(Integer::toString).
                                                    collect(Collectors.joining(",", "[", "]")));
                                }

                                // [0,9,18,27,36,45,54,63,72,81,90,99]

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>syntaxe pour les lambda</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                La syntaxe pour le lambda est assez commune et proche de celle de Kotlin (aux accolades près).-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static int longComputation(int x) {
                                    return x * x;
                                }

                                public static <span class="ch">IntPredicate</span> parametricPredicate(int x) {
                                    var c = longComputation(x);
                                    return y -> y % c == 0;
                                }

                                void main() {
                                    var aStream = IntStream.rangeClosed(0, 100);
                                    var predicate = parametricPredicate(3);
                                    IntStream filteredStream = aStream.filter(predicate);

                                    System.out.println(
                                            filteredStream.
                                                    mapToObj(Integer::toString).
                                                    collect(Collectors.joining(",", "[", "]")));
                                }

                                // [0,9,18,27,36,45,54,63,72,81,90,99]

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>pas de syntaxe pour décrire un type fonctionnel</li>
                    <li>type nominatif, interface</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                En revanche, il n'y a pas de syntaxe pour décrire un type fonctionnel. Ici le type de retour de-->
<!--                « parametricPredicate » est nominatif, c'est une interface.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                @FunctionalInterface
                                public interface IntPredicate {

                                    boolean test(int value);

                                }

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>« Single Abstract Method » ou « SAM » interface</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Mais pas n'importe qu'elle interface. C'est une « Single Abstract Method » ou « SAM » interface...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                <span class="ch">@FunctionalInterface</span>
                                public interface IntPredicate {

                                    boolean test(int value);

                                }

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>annotation « @FunctionalInterface »</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                ... qui est annotée « @FunctionalInterface ».-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                @FunctionalInterface
                                public interface IntPredicate {

                                    <span class="ch">boolean test(int value)</span>;

                                }

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>closure ressemble à un objet avec une seule méthode</li>
                    <li>accès aux champs</li>
                    <li>rétrocompatibilité</li>
                    <li>Runnable</li>
                    <li>« SAM conversion » en Kotlin</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Comme je l'ai déjà dit, une closure ressemble à un objet de disposant que d'une seule méthode pouvant-->
<!--                accéder aux champs de l'objet. C'est cette similitude qui est exploitée ici. On assimile une certaine-->
<!--                forme d'interface au type d'une lambda. On est là dans la recherche de rétrocompatibilité, pour exploiter-->
<!--                des interfaces déjà existantes qui auraient la bonne forme, comme « Runnable ». Après cette forme de-->
<!--                « SAM conversion » est aussi disponible en Kotlin, alors pour s'être privé d'une syntaxe explicite, je-->
<!--                n'en sais rien.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static boolean parametricPredicateLambda(int c, int y) { return y % c == 0; }

                                public static class Closure implements IntPredicate {

                                    private final int c;

                                    public Closure(int c) {
                                        this.c = c;
                                    }

                                    @Override
                                    public boolean test(int value) {
                                        return parametricPredicateLambda(c, value);
                                    }
                                }

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>stratégie de compilation</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                En tout cas la stratégie de compilation retenue pour Java ressemble plutôt à ça.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static boolean <span class="ch">parametricPredicateLambda</span>(int c, int y) { return y % c == 0; }

                                public static class Closure implements IntPredicate {

                                    private final int c;

                                    public Closure(int c) {
                                        this.c = c;
                                    }

                                    @Override
                                    public boolean test(int value) {
                                        return parametricPredicateLambda(c, value);
                                    }
                                }

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>fonction lambda-liftée</li>
                    <li>« desugared » dans la terminologie de Java</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                 On dispose toujours de notre fonction lambda-liftée... Enfin « desugared » dans la terminologie de Java.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static boolean parametricPredicateLambda(int c, int y) { return y % c == 0; }

                                public static class <span class="ch">Closure</span> implements <span class="ch">IntPredicate</span> {

                                    private final int c;

                                    public Closure(int c) {
                                        this.c = c;
                                    }

                                    @Override
                                    public boolean test(int value) {
                                        return parametricPredicateLambda(c, value);
                                    }
                                }

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>classe créée localement</li>
                    <li>interface fonctionnelle cible</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Mais la traduction de la lambda lexicalement liée, la closure, s'appuie sur une classe créée localement à partir de-->
<!--                l'interface fonctionnelle cible.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static boolean parametricPredicateLambda(int c, int y) { return y % c == 0; }

                                public static class Closure implements IntPredicate {

                                    private final int <span class="ch">c</span>;

                                    public <span class="ch">Closure(int c)</span> {
                                        this.c = c;
                                    }

                                    @Override
                                    public boolean test(int value) {
                                        return parametricPredicateLambda(c, value);
                                    }
                                }

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>champ pour valeur variable capturée </li>
                    <li>constructeur</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Elle comporte un champ pour stocker la valeur de la variable capturée et un constructeur pour la-->
<!--                créer avec en fournissant la valeur à capturer.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                public static boolean parametricPredicateLambda(int c, int y) { return y % c == 0; }

                                public static class Closure implements IntPredicate {

                                    private final int c;

                                    public Closure(int c) {
                                        this.c = c;
                                    }

                                    @Override
                                    public boolean <span class="ch">test</span>(int value) {
                                        return parametricPredicateLambda(c, value);
                                    }
                                }

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>mise œuvre de la « Single Abstract Method »</li>
                    <li>fonction anonyme lambda liftée</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et d'une mise œuvre de la « Single Abstract Method » qui s'appuie sur la fonction anonyme-->
<!--                lambda liftée... .-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="java" style="max-height: 800px" data-noescape>

                                public static int longComputation(int x) {
                                    return x * x;
                                }

                                public static IntPredicate parametricPredicate(int x) {
                                    var c = longComputation(x);
                                    return new <span class="ch">Closure(c)</span>;
                                }

            </code><div class="lang">Java</div></pre>
            <pre class="fragment" style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                var predicate = parametricPredicate(3);

                                predicate(81);



            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>créer et retourner la closure</li>
                    <li>pas de syntaxe spécifique ou simplifiée pour l'invocation</li>
                    <li>incorrect</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et comme tout à l'heure, il ne reste plus qu'à créer et retourner la closure dans « parametricPredicate ».-->
<!--                <br><br>-->
<!--                En revanche, contrairement à Kotlin, il n'y a pas de syntaxe spécifique ou simplifiée pour l'invocation-->
<!--                de la fonction. On ne peut pas écrire...-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em"><code class="java" style="max-height: 800px" data-noescape>

                                public static int longComputation(int x) {
                                    return x * x;
                                }

                                public static IntPredicate parametricPredicate(int x) {
                                    var c = longComputation(x);
                                    return new <span class="ch">Closure(c)</span>;
                                }

            </code><div class="lang">Java</div></pre>
            <pre style="font-size: 1.1ex; margin-top: 1ex; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                                var predicate = parametricPredicate(3);

                                <del>predicate(81);</del>

                                predicate.test(81);

            </code><div class="lang">Java</div></pre>
            <aside class="notes">
                <ul>
                    <li>invocation méthode de l'interface SAM</li>
                    <li>subtilité...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                On invoque en réalité la méthode de l'interface SAM.-->
<!--                <br><br>-->
<!--                Si c'est là bien le principe retenu pour les lambdas en Java, il est pourtant mis en œuvre avec une-->
<!--                subtilité..-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="Java" style="max-height: 800px" data-noescape>

                  private static boolean lambda$parametricPredicate$0(int, int);
                    descriptor: (II)Z
                    flags: (0x100a) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC
                    Code:
                      stack=2, locals=2, args_size=2
                         0: iload_1
                         1: iload_0
                         2: irem
                         3: ifne          10
                         6: iconst_1
                         7: goto          11
                        10: iconst_0
                        11: ireturn
                      LineNumberTable:
                        line 15: 0
                      StackMapTable: number_of_entries = 2
                        frame_type = 10 /* same */
                        frame_type = 64 /* same_locals_1_stack_item */
                          stack = [ int ]

            </code><div class="lang">Bytecode</div></pre>
            <aside class="notes">
                <ul>
                    <li>descendre dans la soute</li>
                    <li>bytecode généré par le compilateur</li>
                    <li>javap</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                On va descendre un peu plus dans la soute et jeter un œil rapidement au bytecode généré par le compilateur,-->
<!--                grâce à la commande « javap » sorte de dés-assembleur pour le code de la JVM.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="Java" style="max-height: 800px" data-noescape>

                  private static boolean <span class="ch">lambda$parametricPredicate$0</span>(int, int);
                    descriptor: (II)Z
                    flags: (0x100a) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC
                    Code:
                      stack=2, locals=2, args_size=2
                         0: iload_1
                         1: iload_0
                         2: irem
                         3: ifne          10
                         6: iconst_1
                         7: goto          11
                        10: iconst_0
                        11: ireturn
                      LineNumberTable:
                        line 15: 0
                      StackMapTable: number_of_entries = 2
                        frame_type = 10 /* same */
                        frame_type = 64 /* same_locals_1_stack_item */
                          stack = [ int ]

            </code><div class="lang">Bytecode</div></pre>
            <aside class="notes">
                <ul>
                    <li>fonction anonyme lambda-liftée</li>
                    <li> « lambda$parametricPredicate$0 »</li>
                    <li>name mangling</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et en fouinant dans le résultat, une première chose qui saute aux yeux, c'est notre fameuse-->
<!--                fonction anonyme lambda-liftée, ici appelé « lambda$parametricPredicate$0 ». On voit bien-->
<!--                qu'elle a deux paramètres au lieu d'un et qu'elle retourne un booléen.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="Java" style="max-height: 800px" data-noescape>

                  public static java.util.function.IntPredicate parametricPredicate(int);
                    descriptor: (I)Ljava/util/function/IntPredicate;
                    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
                    Code:
                      stack=1, locals=2, args_size=1
                         0: iload_0
                         1: invokestatic  #7        // Method longComputation:(I)I
                         4: istore_1
                         5: iload_1
                         6: invokedynamic #13,  0   // InvokeDynamic #0:test:(I)Ljava/util/function/IntPredicate;
                        11: areturn
                      LineNumberTable:
                        line 14: 0
                        line 15: 5

            </code><div class="lang">Bytecode</div></pre>
            <aside class="notes">
                <ul>
                    <li>« parametricPredicate »</li>
                    <li>retourne type « IntPredicate »</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                On retrouve aussi « parametricPredicate » qui doit retourner une valeur fonction de type « IntPredicate ».-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                  public static java.util.function.IntPredicate parametricPredicate(int);
                    descriptor: (I)Ljava/util/function/IntPredicate;
                    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
                    Code:
                      stack=1, locals=2, args_size=1
                         0: iload_0
                         1: invokestatic  #7        // Method longComputation:(I)I
                         4: istore_1
                         5: iload_1
                         6: <span class="ch">invokedynamic</span> #13,  0   // InvokeDynamic #0:test:(I)Ljava/util/function/IntPredicate;
                        11: areturn
                      LineNumberTable:
                        line 14: 0
                        line 15: 5

            </code><div class="lang">Bytecode</div></pre>
            <aside class="notes">
                <ul>
                    <li>concepteurs JSR 335</li>
                    <li>profiter « InvokeDynamic » Java 7</li>
                    <li>résister changement futurs de mise en œuvre</li>
                    <li>génération instance de « IntPredicate » à la volée</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Les concepteurs de la JSR 335 vont tirer partit de l'instruction de la JVM introduite en Java 7-->
<!--                pour les langages dynamique : « InvokeDynamic ». L'idée, c'est de se rendre résistants à de potentiels-->
<!--                futurs choix de mise en œuvre en générant cette classe interne instance de « IntPredicate » à la volée.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                  public static java.util.function.IntPredicate parametricPredicate(int);
                    descriptor: (I)Ljava/util/function/IntPredicate;
                    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
                    Code:
                      stack=1, locals=2, args_size=1
                         0: iload_0
                         1: invokestatic  #7        // Method longComputation:(I)I
                         4: istore_1
                         5: iload_1
                         6: <span class="ch">invokedynamic</span> #13,  0   <span class="ch">// InvokeDynamic #0:test:(I)Ljava/util/function/IntPredicate;</span>
                        11: areturn
                      LineNumberTable:
                        line 14: 0
                        line 15: 5

            </code><div class="lang">Bytecode</div></pre>
            <aside class="notes">
                <ul>
                    <li>référence une méthode d'amorçage (index 0)</li>
                    <li>la méthode de création pas connue avant l'exécution</li>
                    <li>construction de l'invocation de cette création</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Cette instruction référence une méthode Java dite d'amorçage (« Bootstrap ») décrite à l'index 0 d'une table des méthodes-->
<!--                d'amorçage. L'idée, c'est que la méthode que l'on va appeler effectivement n'est pas connue avant l'exécution de cette méthode.-->
<!--                Elle va littéralement construire le point d'appel d'une autre méthode, prenant un entier en paramètre et retournant un-->
<!--                « IntPredicate », à la volée.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                BootstrapMethods:
                  0: #94 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(
                                Ljava/lang/invoke/MethodHandles$Lookup;
                                Ljava/lang/String;Ljava/lang/invoke/MethodType;
                                Ljava/lang/invoke/MethodType;
                                Ljava/lang/invoke/MethodHandle;
                                Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
                    Method arguments:
                      #79 (I)Z
                      #81 REF_invokeStatic Main.lambda$parametricPredicate$0:(II)Z
                      #79 (I)Z

            </code><div class="lang">Bytecode</div></pre>
            <aside class="notes">
                <ul>
                    <li>table des méthodes d'amorçage</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Et quand on cherche ladite table des méthodes d'amorçage, on trouve effectivement la description d'une-->
<!--                méthode statique « metafactory » de la classe « LambdaMetafactory ».-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                BootstrapMethods:
                  0: #94 REF_invokeStatic java/lang/invoke/<span class="ch">LambdaMetafactory</span>.metafactory:(
                                Ljava/lang/invoke/MethodHandles$Lookup;
                                Ljava/lang/String;Ljava/lang/invoke/MethodType;
                                Ljava/lang/invoke/MethodType;
                                Ljava/lang/invoke/MethodHandle;
                                Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
                    Method arguments:
                      #79 (I)Z
                      #81 REF_invokeStatic Main.lambda$parametricPredicate$0:(II)Z
                      #79 (I)Z

            </code><div class="lang">Bytecode</div></pre>
            <aside class="notes">
                <ul>
                    <li>« metafactory » de la classe « LambdaMetafactory »</li>
                </ul>
            </aside>
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="java" style="max-height: 800px" data-noescape>

                BootstrapMethods:
                  0: #94 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(
                                Ljava/lang/invoke/MethodHandles$Lookup;
                                Ljava/lang/String;Ljava/lang/invoke/MethodType;
                                Ljava/lang/invoke/MethodType;
                                Ljava/lang/invoke/MethodHandle;
                                Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
                    Method arguments:
                      #79 (I)Z
                      #81 REF_invokeStatic <span class="ch">Main.lambda$parametricPredicate$0:(II)Z</span>
                      #79 (I)Z

            </code><div class="lang">Bytecode</div></pre>
            <aside class="notes">
                <ul>
                    <li>argument fonction lambda-liftée « lambda$parametricPredicate$0 »</li>
                    <li>création classe similaire à « Closure »</li>
                    <li>appel du constructeur pour l'instancier</li>
                    <li>méthode Java tout à fait consultable</li>
                    <li>bibliothèque de manipulation de bytecode « ASM »</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Sans trop rentrer dans des détails qui dépassent le cadre de cette présentation, on voit qu'elle prend-->
<!--                comme argument la fonction lambda-liftée « lambda$parametricPredicate$0 ». Et son travail va consister-->
<!--                à construire une classe similaire à la classe « Closure » de mon exemple précédent, et à générer l'appel-->
<!--                à son constructeur avec la valeur de « c » en paramètre. Cette méthode d'amorçage est écrite en Java et-->
<!--                vous pouvez facilement en consulter le code qui se trouve dans la runtime. D'ailleurs pour générer cette-->
<!--                classe, elle s'appuie sur un clone de la bibliothèque de manipulation de bytecode « ASM ».-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;">
                <object data="./images/Indy/1.svg"></object>
            </div>
            <aside class="notes">
                <ul>
                    <li>« invokedynamic » exécutée dans le flux de bytecode...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Tout se passe comme dans le schéma suivant: l'instruction « invokedynamic » est exécutée dans le flux de-->
<!--                bytecode...-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;">
                <object data="./images/Indy/2.svg"></object>
            </div>
            <aside class="notes">
                <ul>
                    <li>... méthode de bootstrap correspondante est invoquée ...</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                ... la méthode de bootstrap correspondante est invoquée ...-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;">
                <object data="./images/Indy/3.svg"></object>
            </div>
            <aside class="notes">
                <ul>
                    <li>produit une classe à la volée</li>
                    <li>« CallSite », point d'appel, pour le constructeur</li>
                </ul>

            </aside>
<!--            <aside class="notes">-->
<!--                ... qui produit une classe à la volée et « CallSite », ou point d'appel, pour son constructeur prenant-->
<!--                en argument la valeur de la variable « c ».-->

<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;">
                <object data="./images/Indy/4.svg"></object>
            </div>
            <aside class="notes">
                <ul>
                    <li>Point d'appel constant</li>
                    <li>Pas langage dynamique</li>
                    <li>Contournement de metafactory</li>
                    <li>JIT pourra optimiser le tout</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Mais dans le cas des lambdas, ce call site est de type constant (personne ne viendra le modifier comme-->
<!--                celà pourrait arriver dans un langage dynamique). Donc tout appel ultérieur sautera directement au-->
<!--                « call site » et le JIT pourra s'en donner à cœur joie pour optimiser le tout.-->
<!--            </aside>-->
        </section>

        <section>
            <div style="margin-top: 5em; margin-bottom: 100%;">
                <object data="./images/Indy/5.svg"></object>
            </div>
        </section>

        <section>
            <h1>Pour Conclure</h1>
            <aside class="notes">
                <ul>
                    <li>fonctions anonymes liées lexicalement populaires</li>
                    <li>sans récupération automatique de la mémoire</li>
                    <li>C++ ou Rust</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Le fonctions anonymes liées lexicalement ont tellement fait leur chemin qu'on les retrouve dans des-->
<!--                langages sans processus de récupération automatique de la mémoire comme C++ ou Rust.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="rust" style="max-height: 800px" data-noescape>

                        fn long_computation(x: i64) -> i64 { x * x }

                        fn parametric_predicate(x: i64) -> impl FnMut(&i64) -> bool {
                            let c = long_computation(x);
                            move |y| { y % c == 0 }
                        }

                        fn main() {
                            let a_range = 1 .. 100;
                            let predicate = parametric_predicate(3);
                            let filtered_range = a_range.filter(predicate);
                            println!("{:?}", filtered_range.collect::&lt;Vec&lt;i64&gt;&gt;())
                        }

                        // [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99]

            </code><div class="lang">Rust</div></pre>
            <aside class="notes">
                <ul>
                    <li>Graydon Hoare</li>
                    <li>« language engineer », est un amateur de d'OCaml</li>
                    <li>premiers compilos en OCaml</li>
                    <li>pas dépaysés</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Dans le cas de Rust ça n'est pas particulièrement étonnant. Son concepteur initial, Graydon Hoare, fin-->
<!--                connaisseur de la mise en œuvre des langages de programmation et qui se décrit comme un « language-->
<!--                engineer », est un amateur de d'OCaml. D'ailleurs les premières versions de Rust, avant qui ne soit-->
<!--                « self hosted », étaient écrite en OCaml.-->
<!--                <br><br>-->
<!--                Et effectivement à regarder rapidement notre exemple fil rouge en Rust on n'est pas dépaysé !-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="rust" style="max-height: 800px" data-noescape>

                        fn long_computation(x: i64) -> i64 { x * x }

                        fn parametric_predicate(x: i64) -> <span class="ch">impl FnMut(&i64) -> bool</span> {
                            let c = long_computation(x);
                            move <span class="ch">|y| { y % c == 0 }</span>
                        }

                        fn main() {
                            let a_range = 1 .. 100;
                            let predicate = parametric_predicate(3);
                            let filtered_range = a_range.filter(predicate);
                            println!("{:?}", filtered_range.collect::&lt;Vec&lt;i64&gt;&gt;())
                        }

                        // [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99]

            </code><div class="lang">Rust</div></pre>
            <aside class="notes">
                <ul>
                    <li>déclaration d'un type fonctionnel</li>
                    <li>écriture d'une lambda</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                La déclaration d'un type fonctionnel est à mi-chemin entre Kotlin et Java, et l'écriture d'une lambda-->
<!--                en elle-même n'a rien de révolutionnaire.-->
<!--            </aside>-->
        </section>

        <section>
            <pre style="font-size: 1.1ex; margin-top: 5em; margin-bottom: 100%"><code class="rust" style="max-height: 800px" data-noescape>

                        fn long_computation(x: i64) -> i64 { x * x }

                        fn parametric_predicate(x: i64) -> impl FnMut(&i64) -> bool {
                            let c = long_computation(x);
                            <span class="ch">move</span> |y| { y % <span class="ch">c</span> == 0 }
                        }

                        fn main() {
                            let a_range = 1 .. 100;
                            let predicate = parametric_predicate(3);
                            let filtered_range = a_range.filter(predicate);
                            println!("{:?}", filtered_range.collect::&lt;Vec&lt;i64&gt;&gt;())
                        }

                        // [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99]

            </code><div class="lang">Rust</div></pre>
            <aside class="notes">
                <ul>
                    <li>impératifs liés au modèle de gestion mémoire</li>
                    <li>« move » pour gérer la capture de la variable</li>
                    <li>lambda, une fonction anonyme</li>
                    <li> dynamiquement ou lexicalement liée</li>
                    <li>gestion de la capture de son environnement</li>
                    <li>valeurs fonctionnelles que l'on appelle closure</li>
                    <li>stratégies de mises en œuvre nombreuses</li>
                    <li>spécificités du langage</li>
                </ul>
            </aside>
<!--            <aside class="notes">-->
<!--                Tout au plus les impératifs liés au modèle de gestion mémoire de Rust imposent quelques subtilités,-->
<!--                comme ici l'usage du mot clef « move » pour gérer la capture de la variable « c » qui doit survivre-->
<!--                à l'invocation de « parametric_predicate ».-->
<!--                <br><br>-->
<!--                Ce que l'on pourra retenir de tout ça, c'est qu'une lambda, une fonction anonyme, peut être dynamiquement-->
<!--                ou lexicalement liée. Et que dans le second cas pour gérer la capture de son environnement in faut une-->
<!--                représentation des valeurs fonctionnelles que l'on appelle closure. Que les stratégies de mises en œuvre-->
<!--                sont nombreuses et tiennent compte des spécificités du langage.-->
<!--            </aside>-->
        </section>

        <section>
            <div style="display: flex; justify-content: space-between">
                <div style="margin-left: 2em; display: flex; flex-direction: column">
                    <div style="margin-top: 1em; font-size: 1.55em; text-align: left" class="green">Frédéric Cabestre</div>
                </div>
            </div>
            <h1 style="margin-top: 1em">Merci</h1>
            <div style="display: grid; grid: 'one two three four' / 1fr 1fr 1fr 1fr; margin-bottom: 100%; margin-top: 2em">
                <div style="justify-self: center; grid-area: one">
                    <div>Feedback</div>
                    <img src="./images/feedback.png" alt="">
                </div>
                <div style="justify-self: center; grid-area: four">
                    <div>Présentation</div>
                    <img src="./images/presentation.png" alt="">
                </div>
            </div>
        </section>
    </div>
</div>

<script src="./dist/reveal.js"></script>
<script src="./plugin/notes/notes.js"></script>
<script src="./plugin/markdown/markdown.js"></script>
<script src="./plugin/highlight-old/highlight.js"></script>
<script src="./plugin/math/math.js"></script>

<script>
    Reveal.initialize({
        controls: false,
        progress: false,
        history: true,
        center: true,
        width: 1600,
        height: 900,

        transition: "none",

        plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX],

        katex: {
            local: " ",
            trust: true
        },
    });
</script>
</body>
</html>
